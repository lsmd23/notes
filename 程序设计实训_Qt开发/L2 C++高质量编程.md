#### 高质量代码
- 可维护性
- 可扩展性
- 安全性
## 可维护性
1. **统一的代码风格**
    - 空格及{}的使用
    - 行间排版：缩进和语句规范
2. **命名规范**
    - 名称应带有描述性，表示变量意义
    - 统一命名风格
    - 避免缩写和相似的命名
    - 通过**命名空间**避免命名冲突
    - **命名规则**：
        - 匈牙利命名法：变量名=属性+类型+对象描述
        - 驼峰命名法：首字母小写其他单词首字母大写
        - 帕斯卡命名法：单词首字母大写
        - ![[Pasted image 20240820102122.jpg]]
        - 其它命名习惯：
            - 抽象类：I+类型描述
            - 继承类：C+/Impl+类型描述
            - 私有成员以_开头或结尾
            - 常量名以k开头
            - 避免嵌套的命名空间
        *静态局部变量：一直存在的变量，只初始化一次，不多次初始化*
        ![[Pasted image 20240820103348.png]]
3. **合理使用const关键字**
    - 利用const的特性提高可读性，保证特定变量不能被修改
    - ![[Pasted image 20240820105032.png]]
    - constexpr关键字：修饰在表达式，让表达式的值在编译期完成，变成常量
4. **提供完整的注释**
    - 保持注释风格的统一和规整
    - 注释的内容：
        - 函数注释：参数、返回值、注意事项和异常情况结果
        - 类注释：类的功能和用法
        - 文档注释：版权，版本，作者，日期，内容简介
        - TODO注释：对临时的可优化的解决方案或者以后需要拓展的解决方案，可以使用TODO并注释信息
    - doxygen文档生成工具
5. **传值和引用**
    - 大型对象，需要改变参数值以及动态多态时，需要传入引用
    - 传入值时，有可能会发生数据切片和丢失！
6. **资源的获取和释放**
    - **RAII**：对象初始化即获取资源，离开作用域则释放使用的所有资源
    - 实现方式：将资源的管理置于类的构造函数和析构函数中
    - 资源的类型：内存、文件、线程、网络、锁等等
    - 所有的创建都应该有对应的释放：`new/delete;socket.connect();/socket.close();fopen/fclose`
        - 特别注意，异常情况往往是出现泄露的原因
        - 尽量延迟变量的声明及初始化
        - 合理使用智能指针解决内存释放问题
            - 将指针装在一个类的对象里，在对象被析构时尝试释放指针指向的地址
            - 多个指针指向同一个内存时，使用智能指针以避免野指针的出现
            - 指针不要指向栈内存，因为栈内存在会在函数结束被销毁
            - 使用指针前先分配动态内存
            - 使用nullptr赋值给空指针的值而不是NULL或0
            *栈内存和堆内存：**栈区**内存stack由编译器自动管理，**堆区**内存heap由程序员管理，静态区则存储全局变量和静态变量。栈区内存速度更快，但内存区域较小，堆区内存较大，但速度慢，且不连续，用链表进行管理*
7. **其它编程规范**：
    - 一般要将程序输出目录直接设置为源文件目
    - 不要在.h文件中使用using namespace，但尽量把自己的函数和类定义在namespace中
    - 头文件务必使用`#pragma once`或`#ifndefXXX...#define...#endif`
        - `#pragma once`由编译器提供保证，在某些平台上可能不被支持
    - for循环下使用{}
    - 避免特别长的一行代码
    - 合理使用include""和include<>格式
    - 尽量让声明和初始化在一起
    - 类的成员变量尽量使用初始化列表构造
    - 可以用{}来给每个成员赋予初始值
    - 谨慎处理stl的返回类型：不要滥用auto关键字
        *auto在编译期确定类型，用于复杂类型的自动推导，也用于模板函数中变量的类型自动推导，常和decltype连用推导表达式类型*
    - 使用.hpp和.cpp
    - 编程时不要混合使用Tab和space：不同编辑器对两者的处理不同，可能造成代码“混乱
    - 不要在assert()中放置实际运算代码
        *assert的作用是先计算表达式expression，如果其值为假(即为0)，那么它先向stderr打印一条出错信息，然后通过调用abort来终止程序运行*
    - 重载运算符要谨慎，防止意义不清晰的运算符重载，重载运算符后，相关的运算符都要重载
    - 使用explicit关键字：防止隐式的转化，只有参数完全匹配时才能显式地调用
8. **可维护性**
    - 减少预编译和宏，这会导致你和编译器看到的代码不同，出现难以发现的问题
        - 解决方法：使用namespace，在其中定义一个常量类，在类内定义一个static const变量并**在类外**赋值（只有整型和枚举类型可以类内初始化）
    - 改进for循环：`for(const auto &it:vec)`遍历vector
    - 一些其它的STL容器：
        - array容器：定长且可以查询容量
        - tuple容器：存放多个不同类型的值
    - 合理使用override和final关键字处理虚函数
## 可扩展性
合理分析可能被扩展的需求，选择合适的设计模式或算法
1. **设计模式**：解决问题的通用方法
    - 观察者模式、策略模式……
    - 以观察者模式为例：
        - 特点：观察者(人)->观察物(监视器+门)->变化事件(门开了)；观察者关心事件、观察物产生事件；观察物预先不知道且不想知道有哪些观察者和通知方式
        - 方式：将变化事件的多态性放在观察者类中实现
## 安全性
1. **对输入的判断**：“所有的输入都是邪恶的“
    - 所有用户输入都应该足够正确地验证
2. **异常处理**：
    - 判断输入的合法性
    - 运行中数据的检验
    - 对运行结果的判断
3. **其他安全性**
    - 仔细定义函数的返回值
        - 类的成员变量
        - 使用&或const&可减小程序开销
        - 值返回有助于threadsafety。返回的引用可以修改成员变量，某些成员函数也可以
    - 局部变量只能返回值，不能返回引用或指针
    - 内置类型无需使用引用
    - 避免直接的内存访问，多使用智能指针
    - 类型转换使用C++风格：使用`static_cast<>()`进行类型转换
    - 线程控制安全性