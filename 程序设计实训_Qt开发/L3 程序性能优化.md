C++程序优化策略：算法优化；代码优化；使用性能库
## 算法优化
- **算法**：用于实现特定任务的有限步骤集合。算法代表着用系统的方法描述解决问题的策略机制。不同的算法可能用不同的时间、空间或效率来完成同样的任务
    - 特点：有穷性；“确切性”；输入输出；可行性(有效性)；高效性；健壮性
- **算法的效率**：使用处理器的时间和空间
    - 复杂度：算法执行时间需要通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。通常有两种方法:
        - 事后统计：利用计算机的内部计时功能，把程序编写好运行一下进行计时。缺点：依赖于计算机性能，且必须编好代码运行
          *Visual Studio中的性能分析工具：Profiler*
        - 事先分析估计：依据算法选用的策略，问题的规模，书写程序的语言（对于同一个算法, 实现语言的级别越高, 执行效率就越低），编译程序产生的机器代码的质量和机器执行指令的速度进行估计
    - 效率的度量：一个特定算法“运行工作量”的大小只依赖于问题的规模（通常用整数量n表示），是问题规模的函数f(n)
        - 时间复杂度：一个算法是由控制结构（顺序、分支和循环）和原操作（指固有数据类型的操作）构成的,，一般以某基本运算的原操作重复执行的次数作为算法的时间复杂度量度
             - 计算算法的时间复杂度需要计算算法中包含的步骤的所需时间。最差情况下执行所有步骤所需的时间即为默认情况下所谓的算法的时间复杂度。步骤的执行取决于算法中指定的条件，因此，可以根据算法中涉及的条件来测量算法的时间复杂度
        - 空间复杂度：是程序运行所需要消耗的存储空间
             *一般递归算法有O(n)的空间复杂度*
    - 程序算法的优化：一个算法的总复杂度是一定的，一般我们更关注时间复杂度，会采取牺牲空间换取时间的方法优化
## 代码优化
- 优化的类型：
	- 局部代码优化：在基本块内进行的优化，考察一个基本块就可完成。基本块是指程序中顺序执行的语句序列，其中只有一个入口语句和一个出口语句，程序的执行只能从入口语句进入，从出口语句退出。包括局部公共子表达式删除、删除多余代码、交换语句次序、重命名临时变量等
	- **循环优化**：指程序中可能反复执行的代码序列。包括代码外提、删除归纳变量、强度削弱等
	- 全局优化：一个过程不同基本块之间的优化，必须在考察基本块之间的相互联系与影响的基础上才能完成。常用的全局优化技术有复写传播(copy propagation)、常量折叠(conatanrfoldin)、删除全局公共子表达式等
    - Pipeline优化模式：流水线模型，将不同硬件的任务错开进行，实现资源利用最大化![[Pasted image 20240822204808.png]]
	- 机器相关优化：针对机器语言，依赖于目标机器的结构和特点。例如，寄存器优化、多处理器优化、特殊指令优化等
	- 机器无关优化：针对中间代码，不依赖于目标机器的结构和特点。例如，合并常量优化、消除公共子表达式、代码外提、删除归纳变量、强度削弱和删除无用代码等
- 典型的优化方法：
    - 删除不想要的循环部件：不循环的量放在循环外
	    - ![[Pasted image 20240822205122.png]]
    - 合并循环：遵循相同循环逻辑的代码一起循环
	    - ![[Pasted image 20240822205139.png]]
	- 循环并行：使用`#pragma omp parallel for`指令用新线程处理循环
		- ![[Pasted image 20240822205152.png]]
	- 减少循环内的工作（循环不变外提）：对循环中计算形式和值都不变的量，提前在循环外计算
		- ![[Pasted image 20240822205406.png]]
	- 删除多余的运算：如果有表达式e1和e2，且它们的值始终相同，则e2的计算部分可以省略, 只要用e1的值即可
		- 注意: 只有形式相同还不行，必须值也要相同。即形式相同并不能保证值相同。例：
			- ![[Pasted image 20240822205545.png]]
	- 使用sentinel值：标记数据的末尾，简化了对边界条件的处理
		- ![[Pasted image 20240822205606.png]]
	- 查看循环顺序：由缓存机制所带来的效率不同
		- ![[Pasted image 20240822205810.png]]
		- Cache机制介绍：
			- ![[Pasted image 20240822205834.png]]
			- ![[Pasted image 20240822205845.png]]
			- ![[Pasted image 20240822205900.png]]
			- 将内存中的内容读入缓存时，会将附近的一块数据都进行读入。因此在编程时需要注意：按照数据存储的顺序、以尽量小的步长来连续读取数据，且一旦读取了某一个数据，就先尽量多地使用它
	- 强度削弱：把高强度运算改为低强度运算，编译器常常会做这种操作
		- 乘法改为加法，避免除法
		- 移位实现乘除法
	- 归纳变量删除：
		- 在循环中，如果变量I的值随着循环的每次重复都固定地增加或者减少某个常量,，则称i为循环的归纳变量。如果循环中对I只有唯一的形如I=I+c的赋值，且其中c为循环不变量，则称I为循环中的基本归纳变量。若J=c1×I+c2, 且其中c1,c2为循环不变量，即J在循环中的值总是可归化为I的同一线性函数，则称J是归纳变量，并称它与I同族。如果在一个循环中有多个归纳变量, 归纳变量的个数可以减少，即归纳变量的删除
		- ![[Pasted image 20240823090820.png]]
	- 删除无用的赋值：如果表达式z=x op y之后, 对z赋予的该值再也没有被使用到，那么这个表达式可以被删除
	- 复写传播：尽量不引用那些在程序中仅仅只传递信息而不改变其值，也不影响其运行结果的变量
		- ![[Pasted image 20240823194826.png]]其中T4即是这样的变量
	- 过程内嵌：针对源程序中的某些过程调用，如果该过程体短小而且没有循环，则将它拷贝到调用处，从而消除过程调用的开销，如内联函数
	- 常量合并：即常数表达式求值，是指在编译时刻就对已知操作数的值为常数的表达式求值，并且用该结果值来替代这部分表达式
	- 检测函数：函数是性能优化的主体
		- 使用较快的函数
		- 了解标准函数：标准函数算法较优
		- 将本地函数声明为静态函数：静态存储区访问快
	- 检测分支：
		- 合理分配循环的条件，用频率对判断排序
		- 合理使用switch语句和if-else语句（击中第一，第二选项的速度if语句快，击中第四以及第四之后的选项的速度switch语句快）
	- 变量定义：
		- 变量定义时避免类型不匹配造成临时变量的产生
		- 变量延时定义。当某个变量需要提前定义时，定义为指针，初始化为空指针，从而避免多调用构造函数
		- 复杂对象可以使用移动构造函数来减少临时变量的产生
- 优化的误区：
	- 认为程序无需优化, 因为该程序似乎速度很快
	- 认为编译器执行的优化就已足够（有些确实被编译器考虑了）
	- 认为短代码更有效
	- 认为特定的解决方案将十分有效而不需要验证性能结果
	- 认为在编程时进行优化是一个很好的实践
## 性能库的使用
- 性能库的优点：
    - 高效，准确，快速，省时省力
    - 种类丰富，可以满足各种需求
- 多文件编程：大的项目中，编译和链接是分开进行的，头文件用于声明，在链接时找到实现
- C++中的库：
	- 库的定义：是已经写好的，可以复用的代码，例如标准库，以及一些第三方库
	- 静态库：静态库在链接阶段，将编译生成的目标文件与库文件一起链接到可执行文件中
		- 库文件(.lib)是一系列.o文件的集合
		- 静态库头文件依然需要引用，否则编译器不会进行链接![[Pasted image 20240823200309.png]]
		- 优点：
			- 程序在运行时与函数库再无关系，方便移植
			- 所有相关的编译目标文件与库文件被链接成一个可执行文件
		- 缺点：
			- 静态库存在空间浪费问题，不同程序使用同一个库时，静态库会被单独链接到每个程序中，空间代价较大
	        - 静态库对程序的更新和发布也会带来麻烦。如果静态库更新了，使用它的应用程序都需要重新编译链接、发布给用户
	- 动态库：动态库文件.dll在程序编译时并不会被链接到可执行程序中，而是在程序运行时才被载入，其.lib文件仅用于导入库，要小很多
		- 特点：
			- 动态库把一些库函数的载入推迟到程序运行时期
			- 不同的应用程序如果调用相同的库，则只需要有一份该库的实例，可以实现进程之间的资源共享。
			- 动态库独立于可执行程序，更新与发布比静态库更加简单
			- 可以在程序代码中显示调用来控制库的载入
			- 库文件.dll与可执行文件分离，容易出现文件丢失
