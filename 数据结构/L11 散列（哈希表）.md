- 是为了解决精确查询问题提出的算法
- 查找算法：![[Pasted image 20241204100123.png]]
## 散列函数（哈希函数）

- 哈希表方法：
	- 无需比较，直接通过关键码定位目标的存储地址
	- **存储地址是关键码的函数**，称为散列函数，每个关键码对应一个存储位置
	- 散列技术将所有记录存储在一片**连续空间**（使用**向量**作为支撑结构），这块连续空间称为散列表（哈希表）。其元素间不存在逻辑关系，只和关键码相关，是一种**只面向查找功能**的数据结构。
- 散列函数：
	- 直接定址法：
		- 例：![[Pasted image 20241204101008.png]]
		- 线性定址：![[Pasted image 20241204101027.png]]
		- 问题：对依靠学号的学生信息，分布不均匀，单一的哈希方法会带来空间利用率的下降
	- **散列函数的设计**：
		- 实现关键码到整数的转换，同时关键码的范围R应当远大于散列地址空间M
		- 设计准则：确定性，快速可计算性，高空间利用率（装填因子），随机性（均匀性）——关键码映射到各个桶的概率尽可能为$\frac{1}{M}$，最大限度避免哈希冲突
	- 除余法：
		- $hash =f(key)=key \% M$
		- M为表长，一般取**质数**，减小散列冲突
			- 假设关键码之间常具有周期性增长的S，当S与M的最大公约数为1时，关键码的周期性增长进行除余操作，可覆盖$[0,M-1]$的所有桶单元，是相对高效的
			- 为此，取质数以保证其和任何数都是互素的
			- ![[Pasted image 20241204102721.png]]
	- MAD法：
		- $hash=f(key)=(a × key +b) \% M$
		- 相邻关键码在除余法中依然相邻，连续性导致局部聚集,采用MAD法可克服原有方法连续性问题
		- ![[Pasted image 20241204103514.png]]
	- 数字分析法：
		- 抽取关键码的若干位作为散列函数（例如11位的手机号码，前面3位对应运营商，中间4位对应归属地，后4位才是真正的用户号，故采用后4位作为散列地址是不错的选择）
		- 适用于**关键码位数比较多**，并且事先知道关**键码若干位分布比较均匀**的情况
		- 还可进一步对抽取数字反转、移位等操作增加随机性
	- 平方取中法：
		- hashaddress = f(123) = ~~1~~512~~9~~ = 512；hashaddress = f(1234) = ~~15~~227~~56~~ = 227
		- 适用于关键码位数不大，但不明分布的情况
	- 折叠法：
		- 将关键码从左至右分为位数相等的几部分，然后将几部分叠加求和，并按照散列表表长取后几位作为地址：hashaddress = f(9876543210) = 987+654+321+0 = ~~1~~962 = 962
		- 可回折提高随机性 = 789+654+123+0=~~1~~566=566
		- 适用于关键码位数较大，但不明分布的情况
	- （伪）随机数法：
		- 散列函数追求随机，f(key)=random(key)
		- 采用C/C++提供的rand函数再将其映射到桶地址$hash=f(key)=rand(key) \% M$
		- 当关键码长度不等时，采用该方法比较合适
		- 需注意不同计算环境的伪随机数发生器各不相同，代码在不同平台间移植性不好
- 散列码转换：针对不同类型关键码进行散列函数计算的预处理
	- 强制转换为整数：byte，short，int，char不超过32位
	- 成员对象求和：long long和double，可分多个32位相加
	- 字符串多项式转换：例如”data structure”，可先将各字母对应整数$(x_i=1,2,3,…,26)$，进而使用多项式转换：$x_0 a^{n-1}+x_1 a^{n-2}+…+x_{n-2} a^1+a^0$，实验证明对于英文字符串，a取33,37,39或41较合适
## 散列冲突

- 冲突的普遍性：
	- 散列表的基本构思：开辟物理地址连续的桶数组ht[]，借助散列函数hash()，将词条关键码key映射到桶地址hash(key)，从而快速确定待操作词条的物理位置
	- 冲突是不可避免的，只能尽可能消解冲突
- 冲突排解：
	- **多槽位法**：
		- 将各桶分解为更细小的槽位单元(slot)，每一槽位可组织成向量
		- put(key,value)操作，可先通过hashaddress定位桶单元，然后查询该桶内槽位单元是否有key。若无，则创建词条(key,value)，并将其插入到桶单元内的空闲槽位
		- get(key)和remove(key)操作类似
		- ![[Pasted image 20241204102459.png]]
		- 缺点：若每个桶细分为k个槽位，则空间利用率为原来的1/k；且难以预测并设定合适的k值
	- **独立链法**：
		- 将各桶相互冲突的词条串成一个列表
		- 相比于多槽位法，空间利用率高
		- 查询类似多槽位法
		- 查找复杂度不高，接近常数复杂度
		- ![[Pasted image 20241204102633.png]]
	- **公共溢出区法**：
		- 在原散列表(a)之外另设一词典结构(b)作为公共溢出区，凡冲突的词条进入(b)
		- 查找时，若在(a)中查找不成功，可在(b)中顺序查找
		- 这一方法适合冲突数据很少的情况
		- ![[Pasted image 20241204102842.png]]
	- *开放定址：线性试探法*
		- 独立链等结构需要额外的内存空间，并且物理内存不连续，在散列表较大情况下，IO处理消耗大量时间，因此，可以**就地排解散列冲突**，为每个冲突码在散列表内部选择空的桶（即使不是散列函数计算出的地址）
		- 因此，每个词条均有可能落到任意的散列地址，称作开放定址（open addressing）同时，因可用的散列地址仅限于散列表所覆盖的范围内，所以称为闭散列策略（closed hashing）
		- 在插入$key$时，若发现桶单元$ht[hash(key)]$已经被占用，则转而试探$ht[hash(key)+1]$；若也被占用，则试探$ht[hash(key)+2]$，第i次试探的桶单元为：$ht[hash(key)+i] \% M$
		- 查找算法：同样线性试探![[Pasted image 20241204105426.png]]
			- 当前桶单元命中目标关键码，则成功返回
			- 当前桶单元非空，但其关键码与目标关键码不等，则转入下一桶单元试探
			- 当前桶单元为空，则返回查找失败
			- 查找的复杂度并没有特别大的开销
		- 删除算法：![[Pasted image 20241204105738.png]]
			- 简单地删除会导致查找链断裂，将后续词条全部取出插入复杂度又过高
			- 解决：设置标记，保证查找链不断，且后续插入可以进入该桶
		- 性能和优缺点：
			- 理论分析和实验表明，对于闭散列策略而言，散列表的空间利用率（填装因子）λ保持在**λ<0.5**，会获得较理想的水平
			- 当填装因子过大时，采用重散列方法，即扩容策略，将原散列整体**搬迁到新的容量扩充散列**中（详见教材9.3.8）
			- 闭散列策略保持连续的物理存储空间，查找操作几乎不涉及I/O处理
	- 开放定址：平方试探法
		- 线性试探法会产生聚集现象，会导致一些不必要的复杂度升高
		- 平方试探法：第k次试探地址为$(hash(key)+k^2) mod M,  k=0,1,2….$，即按照平方规律向后试探，避免连续的聚集区域
		- ![[Pasted image 20241204110649.png]]
	- 开放定址：双向平方试探法
		- 平方试探无法遍历散列表所有空桶（即使表长为素数），因此，采用正负双向的平方试探法
		- ![[Pasted image 20241204110848.png]]
		- 数论证明：**若表长M取模4余3，则在前M次试探必可遍历M中的所有桶**
## 散列的应用

- 桶排序：
	- 给定$[0,M)$范围内的n个整数，引入长度为M的哈希表，使用散列函数对每个待排序整数进行哈希映射，即可完成排序
	- 复杂度：空间复杂度$O(M)$，时间复杂度：关键码插入耗时$O(n)$，依次读取关键码耗时$O(max(M,n))$，整体$O(max(M,n))$
	- 若允许输入发生冲突，则可以使用独立链法排解冲突，按照独立链读取即可![[Pasted image 20241206184955.png]]
	- 这一排序突破了$O(n\log n)$复杂度，最多可以降低为$O(n)$
- 基数排序：
	- 假若关键码由多个域（字段）组成，可按照优先级从低到高进行桶排序
	- 例：![[Pasted image 20241206185010.png]]
	- 复杂度：各字段取值范围$[0,M_i), i\leq t$，若$M=max(M_i)$，则：复杂度：$O(n+M_1)+ O(n+M_2)+ … + O(n+M_t) = O(t(n+M))$