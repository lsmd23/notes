## 概述
- 按某种其他顺序确定优先级，而不是简单地按照入队顺序处理的队列
- 用堆实现：堆是一种基于完全二叉树的数据结构
- 操作接口：
	- ![[Pasted image 20241113103318.png]]
	- 基于向量或二叉搜索树实现，复杂度较高（无需查找其他的结果，有复杂度上的“浪费”）
	- 基于堆实现，只需维护最大值，而无需维护其他元素的全局有序性，以“堆”实现优先级队列，实现更为简单，维护成本更低，时间复杂度依然为O(logn)，但实际效率更高
		- 以数组为存储结构，以完全二叉树为逻辑结构
		- 完全二叉树的向量表示：![[Pasted image 20241120104147.png]]
			- **$Parent(i)=(i-1)≫1$**
			- $lChild(i)=(i≪1)+1$
			- $rChild(i)=(i≪1)+2$
		- 接口：![[Pasted image 20241120103939.png]]
## 二叉堆
- 概念：
	- 堆是一种二叉树，每个顶点的值大于或等于其左右孩子的值称为大顶堆，反之则为小顶堆
	- ![[Pasted image 20241120104712.png]]
	- 对优先级队列，采用大顶堆，根节点为极大值点，可以很方便的实现取堆顶操作
- 插入：上滤
	- 算法：直接在向量末尾插入，若新节点大于其父节点，与父节点值进行互换，其它节点不受影响。迭代此过程，直到满足堆序性要求（实际可缓存新插入节点值，上滤改变每个需要调整的节点值，最后用新值取代终止节点值，提高效率）、
	- ![[Pasted image 20241120105403.png]]复杂度：**O(logn)**
	- 实现：![[Pasted image 20241120105430.png]]
- 删除：置换+下滤
	- 算法：
		- 最大元素在二叉堆的根节点，也即对应向量的第一个元素
		- 使用最后一个元素取代根节点值，把原堆顶置于向量最末
		- 比较新根节点的两个孩子，与其大的孩子交换
		- 迭代该过程，直至全树满足堆序性要求
	- ![[Pasted image 20241120105952.png]]复杂度：**O(logn)**
	- 实现：![[Pasted image 20241120110023.png]]![[Pasted image 20241120110054.png]]
- 堆构建：
	- 蛮力算法：按插入算法，逐个插入，复杂度：O(nlogn)
	- 堆合并法（Floyd算法）：自底向上（向量中则自右向左）进行堆合并。假设左子堆和右子堆满足堆序性，对左右子堆及它们的父节点进行类似删除最大元素后的下滤调整
		- ![[Pasted image 20241120111056.png]]
		- 从内部节点自底向上作堆合并
		- 例：![[Pasted image 20241120111329.png]]
	- 复杂度比较：![[Pasted image 20241120111348.png]]
	- 实现：![[Pasted image 20241120111438.png]]
- 堆排序： ^e10732
	- 选择排序：![[Pasted image 20241120111810.png]]
	- 利用堆，可以对选择排序进行改进：构建堆需要O(n)的复杂度，n次选择共计O(nlogn)复杂度，整体复杂度降低为O(nlogn)
	- 例：![[Pasted image 20241120112510.png]]![[Pasted image 20241120112526.png]]![[Pasted image 20241120112541.png]]
	- 实现：![[Pasted image 20241120112558.png]]
- 应用：
	- 哈夫曼编码树就是一个二叉堆，每个父节点的码值都是两个子节点的码值之和
		- 例：![[Pasted image 20241120112945.png]]
	- 大型浮点数集合的和：由于比较小的浮点数和比较大的浮点数相加会损失比较大的精度，所以要在集合中找出两个比较小的浮点数进行相加
	- 离散时间动态调度：对于动态离散时间，根据优先级确定调度与服务
		- 对银行处理业务的离散时间模型，事件处理队列就是一个优先级队列，总之将时间靠前的排在队头
		- 例：![[Pasted image 20241120113535.png]]
	- 优先级队列的STL使用：
		- STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称
		- STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会
		- 优先级队列的STL接口![[Pasted image 20241120113949.png]]
		- 实例：![[Pasted image 20241120114034.png]]![[Pasted image 20241120114051.png]]
---
[[L10 图]]