# 递归的算法设计与复杂度分析

- 迭代与递归：
	- 迭代：利用循环实现重复调用
	- 递归：程序调用自身的技巧
		- 减治：求解一个大规模问题，逐渐划分并解决一平凡子问题
		- 分治：求解一个大规模问题，将其划分为规模相当的子问题
		- 复杂度：使用复杂度递推方程计算
# 向量
### 数据结构的分类
- ![[Pasted image 20240918101802.png]]
- 线性表：是由n (≥0) 个数据元素的有限序列
	- 除第一个元素外，其它每个元素有且仅有一个直接前驱
	- 除最后一个元素外，其它每个元素有且仅有一个直接后继
	- 直接前驱和直接后继描述了结点之间的逻辑关系（即邻接关系）
### 概念

- 将线性表中的元素相继存放在一片连续的存储空间中（线性表基于数组的存储表示）          
- 可利用一维数组描述存储结构顺序表
- 所有元素的逻辑顺序与其物理存放顺序一致，即第 i 个表项存储于第 i 个物理位置
- 既可顺序访问，也可随机访问
- *向量是数组的抽象和泛化，由模板类实现，带有很多的操作接口*
### 操作接口

![[Pasted image 20240918102650.png]]
#### 构造、析构与内存管理
- 构造和析构：
	- 模板：![[Pasted image 20240918105355.png]]
	- 默认构造：![[Pasted image 20240918105517.png]]
	- 拷贝构造：![[Pasted image 20240918105524.png]]
	- 赋值：![[Pasted image 20240918105532.png]]
	- 析构：![[Pasted image 20240918105537.png]]
- 扩充：![[Pasted image 20240918105637.png]]
	- 复杂度分析：主要取决于搬移原数据的过程![[Pasted image 20240918110106.png]]
#### 获取与更新
![[Pasted image 20240918110328.png]]
#### 查找
无序的顺序遍历查找![[Pasted image 20240918110425.png]]
、
- 复杂度：平均为**O(n)**
#### 插入
![[Pasted image 20240918110543.png]]
- 复杂度主要源自于搬移操作，平均为**O(n)**
#### 删除
![[Pasted image 20240918110739.png]]
- 复杂度：源自搬移操作，平均为**O(n)**
#### 去重![[Pasted image 20240918110948.png]]
![[Pasted image 20240918110948.png]]
- 复杂度：基于迭代的实现，复杂度为**$O(n^2)$**
#### 遍历
![[Pasted image 20240918111335.png]]
- 复杂度：**O(n)**
#### 判序
![[Pasted image 20240918111408.png]]
#### 排序算法
1. **归并排序**：采用**分治**思想的递归排序
	- 思路：对大的向量，分解到每个小的部分的排序，先对小的子序列排序，之后把两个排好序的子序列合并成一个大的子序列，由此递推实现
	- 实现：![[Pasted image 20240918112003.png]]
	- 复杂度：两路归并时间复杂度为O(n)，递推式为T(n) = 2×T(n/2) + O(n)，计算得复杂度为**O(nlogn)**
	- *注：因为有额外的空间开销，所以算法的效率并不高*
2. **起泡排序**：
	- 思路：遍历，若发生逆序则交换，顺次比较
	- 实现：![[Pasted image 20240918113518.png]]
	- 复杂度：稳定的为**O(n2)**
3. **选择排序**：
	- 思路：每一次从待排序的元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完
	- 实现：![[Pasted image 20240918114831.png]]
	- 复杂度：**O(n2)**
- **排序算法比较**：![[Pasted image 20240918115407.png]]
#### 有序向量的去重
![[Pasted image 20240918115927.png]]
- 复杂度为**O(n)**
#### 有序向量的查找
1. **二分查找**：
	- 实现：![[Pasted image 20240918120512.png]]
	- 复杂度：O(logn)
	- 分析：![[Pasted image 20240918120551.png]]查找长度的系数是1.5，可以优化
2. **Fibonacci查找**：对二分查找的一种改进 
	- 适当减少后区间的长度，可以将查找长度的系数降低到1.44
3. **改进算法**：
	- 缩减分支，将三分支化为两分支![[Pasted image 20240919190902.png]]相比于三分支，整体更加稳定。缺点：有多个命中元素时，不能保证返回秩最大者；查找失败时返回-1，不能指示失败的位置
	- 再改进：使得可以返回秩最大者![[Pasted image 20240919191129.png]]