## 基本概念

- 定义：
	- 由字符组成的有限序列，记作$S="a_0, a_1, … ,a_{n-1}”$, 其中$a_i∈Σ, 0≤ i<n$，串中的每个成员称作一个字符（字符集Σ）
	- 串可用向量或列表来实现
	- 长度为0的串称为空串“”，注意与空白串“  ”的区别
- 一些概念：
	- 两字符串相等：$S[0,n) = T[0,m)$ 意味着$m=n$且$S[i]=T[i]$
	- 子串：$S.substr(i,k)=“a_i, a_{i+1}, … ,a{i+k-1}”=S[i, i+k)$，$S[i]$起的连续k个字符
	- 前缀：$S.prefix(k) = S.substr(0,k)=S[0, k)$，S中最靠前的k个字符
	- 后缀：$S.suffix(k) = S.substr(n-k,k)= S[n-k, n)$，S中最靠后的k个字符
		- 联系：$S. substr(i,k) = S.prefix(i+k).suffix(k)= S[i, i+k)$
		- 注：空串是任何串的子串、前缀、后缀，任何串也是自身的子串、前缀、后缀
- 接口：
	- ![[Pasted image 20241211100025.png]]
## 串匹配

- 串匹配：同一字符表的文本串T(长度n)和模式串P(长度m)，判断T中是否存在某一子串与P相同，若存在，则报告子串在T中的起始位置
	- 应用：
		- 可拓展为查找出现次数，枚举所有位置等功能
		- 从互联网中使用google搜索包含关键词的网页
		- 从蛋白质序列中寻找特定的氨基酸模式
- 蛮力匹配：
	- 固定文本串T，移动模式串P，自左向右，以字符为单位，依次移动模式串
	- 例：![[Pasted image 20241211101411.png]]
	- 算法实现：
		- 实现1：标记文本串首对齐坐标![[Pasted image 20241211101620.png]]i>n-m，则匹配失败
		- 实现2：标记文本串首对齐坐标![[Pasted image 20241211102140.png]]i-j > n-m，则匹配失败
	- 性能分析：
		- 最好情况：只经过一次匹配即找到，O(m)
		- 最坏情况：尝试所有的循环，每轮循环比对m-1次成功，1次失败，即m次比对，n-m+1次循环。因此，比对次数为m×(n-m+1)=O(n×m)
- 改进分析：
	- 比对中冗余的操作：在前几次比对中已经预含了后几次比对的信息![[Pasted image 20241211104128.png]]
	- 由此，可以改进算法，使得i不需要回退，根据模式串的结构，确定新的j值即可![[Pasted image 20241211104651.png]]确定新的j值，取决于模式串中已经匹配的部分的前缀和后缀的匹配度，并且有优先级顺序
	- 模式串分析——Next表：
		- $P[0, j)$ 中长度为 t 的真前缀，应与长度为 t 的真后缀完全匹配，故 t 来自集合：$N(P,j)=\{0≤t<j|P[0,t)=P[j-t,j)\}$
		- 为保证不遗漏可能的匹配，应在N(P,j)中挑选最大t：$next[j]=max(N(P,j))$
		- 一旦发生$P[j]$与$T[i]$失配，可转而将$P[next[j]]$与$T[i]$对齐，进行下一轮匹配
		- 例：![[Pasted image 20241211105209.png]]
- **KMP算法**：
	- 算法框架：![[Pasted image 20241211105347.png]]
	- Next表的获取和构造：
		- ![[Pasted image 20241211105717.png]]
		- Next[j]=-1的特殊处理：用于将匹配位置顺序下移![[Pasted image 20241211105906.png]]
		- 构造实现：![[Pasted image 20241211110802.png]]
	- 复杂度分析：
		- 令$k=2i-j$，由while循环的分析，每进行一次while循环，k至少+1，k的最大值可能为$2i_{max}-j_{min}=2n+1$，故while循环至多执行2n+1次。为此，复杂度为$O(n)$
	- 进一步的改进：
		- ![[Pasted image 20241211110500.png]]
		- 选定的t不能使得$P[t]=P[j]$，对集合$N(P,j)=\{0≤t<j│P[0,t)=P[j-t,j),且P(t)≠P(j)\}$，可以进一步改进KMP的Next表
			- 例：![[Pasted image 20241211110643.png]]