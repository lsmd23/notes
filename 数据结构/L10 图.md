## 基本概念

- 树和图：![[Pasted image 20241120115237.png]]
- 基本术语：
	- ![[Pasted image 20241120115257.png]]
	- ![[Pasted image 20241120115352.png]]
	- 简单路径：若路径上各顶点 $v_1, v_2, ..., v_m$ 均不互相重复, 则称这样的路径为简单路径
	- 连通图与连通分量：在无向图中, 若从顶点v1到顶点v2有路径, 则称顶点v1与v2是连通的。如果图中任意一对顶点都是连通的, 则称此图是连通图。非连通图的极大连通子图叫做连通分量
	- 强连通图与强连通分量：在有向图中, 若对于每一对顶点vi和vj, 都存在一条从vi到vj和从vj到vi的路径, 则称此图是强连通图。非强连通图的极大强连通子图叫做强连通分量
- 图的经典问题：
	- 无向图：![[Pasted image 20241120115710.png]]
	- 有向图：![[Pasted image 20241120115718.png]]
## 接口与实现

- 接口类型：![[Pasted image 20241120120537.png]]
- 存储表示：
	- 使用邻接矩阵表示：![[Pasted image 20241120120632.png]]
		- 实现：![[Pasted image 20241120120654.png]]![[Pasted image 20241120121200.png]]
	- 使用邻接表表示：![[Pasted image 20241121163546.png]]
		- 简单的实现框架：![[Pasted image 20241121163606.png]]
- 基本操作：
	- 访问一些数据属性：![[Pasted image 20241121160856.png]]
	- 动态插入顶点：对邻接矩阵进行行、列的扩展，对顶点集合插入![[Pasted image 20241121161730.png]]时间复杂度：$O(n)$，空间复杂度：$O(n^2)$
	- 动态删除顶点：对入边、出边都作删除操作，并对顶点集中的顶点删除![[Pasted image 20241121162045.png]]时间复杂度：$O(n)$，空间复杂度：$O(n^2)$
	- 动态插入、删除边：![[Pasted image 20241121163214.png]]为$O(1)$复杂度
	- 若采用邻接表的实现，空间复杂度降低到$O(n+e)$，但由于List的特性，查润边是否存在的操作需要$O(n)$的复杂度，顶点插入操作降低到$O(1)$，删除复杂度需要$O(e)$。邻接表操作有利于枚举一个顶点出发的所有边
## 图的遍历

- 基本概念：
	- 图遍历是大部分图算法的主体框架
	- 与树的遍历类似，图的每个顶点被访问一次且仅一次
	- 图的所有边也被访问一次且仅访问一次（对边进行分类）
	- 图的遍历是将图转化为树或森林的过程（**非线性到半线性结构**）
	- 遍历中组成树的一类边叫**树边**，与相应顶点构成**遍历树**（**支撑树**），其它各种边提供原图的重要信息，包括环路信息等。图遍历强调对特定状态顶点的甄别与查找，故称“图搜索”
	- 遍历包括：**广度优先搜索(BFS)、深度优先搜索(DFS)**，皆可在 **O(n+e)** 时间内完成
- 广度优先搜索： ^ce26eb
	- 类似树，使用队列进行辅助遍历
	- 概述：![[Pasted image 20241121164948.png]]
	- 实例：对边进行了分类![[Pasted image 20241121165040.png]]
	- 算法实现：![[Pasted image 20241121165005.png]]
	- 复杂度：$O(n+e)$
- 深度优先搜索：
	- 对BFS算法，将队列改为栈，即可实现深度优先的搜索：![[Pasted image 20241121165305.png]]在代码实现中，这个栈依靠递归调用的函数栈实现 ^04bcbf
	- 对树的三种序遍历，就是对树的深度优先搜索，可以看到，在时间轴上，各个节点的活跃时间是一致的，不同遍历只是选取了不同时间节点的节点作为遍历序列![[Pasted image 20241121170503.png]]
	- 算法：
		- 优先选取最后一个被访问到的顶点的邻居进行访问
		- 各顶点被访问到（将顶点标记为DISCOVERED）的次序，类似于树的先序遍历；各顶点被访问完（将顶点标记为VISITED）的次序，类似于树的后序遍历
		- 教材要求记录访问到的时间 dTime （DISCOVERED）及访问完的时间 fTime ( VISITED )
	- 代码实现：基本版，无边状态，无时间计数![[Pasted image 20241123183015.png]]
	- 对边的遍历：
		- 边分为四种类型：树边(TREE)，前向边(FORWARD)，后向边(BACKWARD)，跨边(CROSS)![[Pasted image 20241125182725.png]]
		- 算法：根据遍历时的访问顺序（时间），以及节点的访问状态，即可确定边的类型
		- 代码实现：![[Pasted image 20241125182820.png]]完整实现：![[Pasted image 20241125182832.png]]复杂度：**O(n+e)**
		- 实例：![[Pasted image 20241125182948.png]]
- 最小支撑树（最小生成树）：
	- 概念：
		- 连通图G的某一无环连通子图T若覆盖G中所有的顶点，则称作G的一棵支撑树或生成树![[Pasted image 20241125183345.png]]
		- n个顶点的连通网络的生成树有n个顶点、n-1条边
		- 不能使用产生回路的边
		- 各边上的权值的总和达到最小
		- 应用：假设有一个网络，用以表示 n 个城市之间架设通信线路，边上的权值代表架设通信线路的成本。如何架设才能使线路架设的成本达到最小？
	- 普利姆（Prim）算法： ^80b13b
		- 最小生成树总是采用联接每一割的最短跨越边
		- 下图中顶点集V和顶点集U构成$G=\{V,U\}$的一个割（cut）
		- 采用贪心迭代法，设k时刻的最小生成树为$T_k=\{V_k,E_k\}$，此时最小割为$e_min=e_k=\{v_k,u_k\}$, 则第k+1时刻的最小生成树为$T_{k+1}=\{V_k +v_k, E_k+e_k\}$![[Pasted image 20241125184234.png]]
		- 算法实现：作搜索，生成的优先级取决于到节点的边的权值，对不连通的节点，这个权值设定为无穷大![[Pasted image 20241125184326.png]]复杂度：$O(n^2)$
		- 优先级队列优化：![[Pasted image 20241127113505.png]]复杂度：$O(e\log n)$
		- 证明：反证，假设uv是割(U:G\U)的最小跨越边，而最小生成树未采用，则必有另一跨越边st联接该割（可能s=u或v=t，但不同时成立），若uv和st同时存在，则构成环。当st边不存在时，实现相同的功能，相同的边数，但代价比经过st边小，所以经过st边的方案不成立![[Pasted image 20241125184929.png]]
- 最短路径树（SPT）：
	- 概念：
		- 问题提出：如果从图中某一顶点（称为源点）到另一顶点（称为终点）的路径可能不止一条，如何找到一条路径使得沿此路径上各边上的权值总和达到最小
		- 单调性：最短路径的任意前缀也是最短路径；S到v的最短路径经过u，则沿着该路径从S到u也是u的最短路径（可反证）
		- 无环性：S到图中其它各点的最短路径的集合必无环
		- 由各个最短路径构造出的树即为最短路径树
	- 迪杰斯特拉（Dijkstra）算法：
		- 给定一个带权有向图G与源点s，求从s到G中其他顶点的最短路径（限定各边上的权值大于或等于0）
		- 按路径长度的递增次序,   逐步产生最短路径
		- 首先求出长度最短的一条最短路径(s,u)，更新SPT的顶点集及s到其他各边的最短距离（更新u的邻域），再求出s到其它顶点长度次短的一条最短路径，依次类推，直到所有顶点进入SPT集合
		- 与Prim算法相比，这里每次更新的逻辑是从根节点出发所能找到的最短路径，而不是割边的权值大小
		- 算法实现：![[Pasted image 20241127112233.png]]复杂度：$O(n^2)$
		- 优先级队列优化：![[Pasted image 20241127113536.png]]复杂度：$O(e\log n)$
- **==优先级搜索算法==**：顶点邻域优先级更新和选取最高优先级顶点之间的反复迭代
	- 对BFS，依靠队列实现优先级判断
	- 对DFS，依靠栈实现优先级判断
	- 对Prim算法，优先级标准为最小割边
	- 对Dijkstra算法，优先级标准为最短路径
	- 各个算法之间框架是统一的
- 负权值边的最短路径问题——Bellman和Ford算法：
	- Dijkstra的局限：不能解决负权值的边
		- ![[Pasted image 20241127114415.png]]
		- BC边权值为负，使用Dijkstra求从A到C最短路径为AC，代价为4，但从A到B再到C则代价为3
- **多源最短路径问题——Floyd算法**：
	- 思路：
		- 两点之间有距离，考虑引入第三个顶点是否会缩短距离，引入多个顶点是否会缩短距离
		- 维护另一个P矩阵，用于存储中转点和路径
	- 例：
		- 原图，P矩阵的存储表示两点之间没有任何中转![[Pasted image 20241127115224.png]]
		- 只允许经过1节点中转：![[Pasted image 20241127115259.png]]更新P矩阵，表示经过1中转；更新E矩阵，记录路径距离
		- 允许经过1和2两个节点：![[Pasted image 20241127115525.png]]最后通过P表查询最短路径，E表查询最短路径的值
	- 实现：
		- ![[Pasted image 20241127115648.png]]
- 拓扑排序：
	- AOV网：顶点表示活动，有向边代表优先级，有向边起始端活动须早于末端活动
		- 例如：选课网络![[Pasted image 20241127115851.png]]
	- 拓扑排序：设G=(V,E)是一个具有n个顶点的有向图，若序列$v_1,…,v_n$满足G中每条有向边的活动时间先后要求，则称$v_1,…,v_n$为G的拓扑排序
		- G存在拓扑排序必定保证G无环
		- G的拓扑排序不唯一：ABCDEFGHIJLK为上图的其中一个拓扑排序
	- 拓扑排序算法：
		- 思路：
			- 在AOV网络中选一个没有直接前驱的顶点, 并放入已排序集TS; (选取最优)
			- 从图中删去该顶点, 同时删去所有它发出的有向边，更新邻域入度; (邻域更新)
			- 重复以上直到： 全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；或图中还有未输出的顶点(所有剩余顶点入度都不为0)，这时网络中必存在有向环
			- 同样，也是顶点邻域优先级更新和选取最高优先级顶点入集的过程
		- 实现：基于栈![[Pasted image 20241127120346.png]]