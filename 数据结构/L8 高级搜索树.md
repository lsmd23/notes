## B树
- **伸展树**：一种平衡二叉搜索树
	- 当某个节点被访问时，伸展树会通过旋转使该节点成为树根。以使得下次访问该节点时，能够迅速的访问到该节点
	- 是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去
	- ![[Pasted image 20241106100007.png]]
- 背景：
	- 数据规模的增长远远快于存储能力的增长，但盲目扩大内存会降低访问速度，因此需要使用高速缓存策略（分级存储）
		- 静态随机访问存储器（SRAM），CPU的高速缓存，是磁盘（硬盘）存取速度的100万倍（$10^6$）
		- 动态随机访问存储器（DRAM），内存，是磁盘（硬盘）存取速度的10万倍（$10^5$）
	- 计算机由内存与外存构成二级存储系统，数据全部存放于外存，内存则作为高速缓存。两个相邻存储级别直接的数据传输称为“I/O操作”，设计算法时，要可能降低这个操作的次数，也即尽可能**降低外存访问的次数**
	- 读取外存数据时，读取连续一千个字节和读取单个字节几乎没有区别，且由于局部性原理（当一个数据被用到时，其附近的数据也通常会马上被使用），因此，可以改进传统的AVL树，将每个节点存储的数据规模扩大
- 多路平衡查找：
	- 多路搜索树：增大每个节点的数据
		- 获取：![[Pasted image 20241106101246.png]]
	- 多路平衡搜索树：![[Pasted image 20241106101741.png]]
		- 所有**叶节点深度相同，根结点至少有两个分支**
		- 除叶子节点外，节点的分支数（度数）比关键码个数多1
		- m限制节点的分支数可能，根据节点的**分支数允许范围**$[⌈\frac{m}{2}⌉, m]$命名B-树，如(2,3)树，(2,4)树
		- $[⌈m/2⌉, m]$树，每个非根节点的关键码个数不能过少，也不能超过m-1，$$⌈\frac{m}{2}⌉-1≤n≤m-1$$
		- 第k层关键码总数$N_k$，其上一层分支总数$L_{k-1}$，本层分支总数$L_k$，满足：$L_{k-1} +N_k = L_k$，因此，**最底层叶子节点的分支总数比树的关键码总数N多1**
		- **树高h**：
			- 只有一个根节点树高定为1
			- 关系：$$log_m (N+1)≤h≤log_{⌈\frac{m}{2}⌉}  ⌊\frac{N+1}{2}⌋+1$$
			- 证明：![[Pasted image 20241106102802.png]]![[Pasted image 20241106102817.png]]
- 实现：![[Pasted image 20241106104150.png]]![[Pasted image 20241106104550.png]]
- 关键码查找：
	- 对于活跃的B-树，其根节点会常驻于内存；任一时刻通常只有另一节点常驻于内存。各节点内包含多个关键码，需经过多次内存比较，才能确定应该转入下一层哪个节点继续查找
	- 实现：![[Pasted image 20241106104955.png]]
		- 复杂度：每次访···问需做$O(log_mN)$次外存读取，为原先的$\frac{1}{log_2m}$。m通常为256至1024，故改进效率在一个数量级左右
- 关键码插入：
	- 算法：![[Pasted image 20241106105305.png]]
	- 上溢与分裂：取中间位置，上移到父节点，递归操作![[Pasted image 20241106105633.png]]
		- 实例：![[Pasted image 20241106105859.png]]![[Pasted image 20241106105913.png]]![[Pasted image 20241106110009.png]]
- 关键码删除：
	- 算法：![[Pasted image 20241106110146.png]]
	- 下溢与“旋转-合并”：
		- 旋转：![[Pasted image 20241106110626.png]]
		- 合并：![[Pasted image 20241106110915.png]]
		- 实例：![[Pasted image 20241106111512.png]]![[Pasted image 20241106111526.png]]![[Pasted image 20241106111541.png]]
## 红黑树
- 背景：
	- AVL树在删除时，父节点可能会失衡，重平衡调整至少为$O(log n)$
	- 加入节点的颜色属性，使得对任何一次动态的操作（插入与删除），引起的结构变化不至于超过O(1)
- 特性：
	- 定义与条件：**根节点为黑色**；**外部节点NIL均为黑色**；**其余节点若为红色，其父节点和孩子为黑**；从任一外部节点到根节点沿途，经过的黑节点数目一样
	- 黑深度：除去根节点，沿途所经过黑节点（包括外部节点）总数称为该节点黑深度；根节点黑深度为0
	- 除去外部节点，沿途所经过黑节点总数称为该节点黑高度；外部节点黑高度为0，根节点黑高度为全树黑高度
	- ![[Pasted image 20241106112534.png]]
- 等价性：红黑树可以和B树等价
	- 自顶向下，每遇一个红节点，都将其对应子树整体提升一层，从而与父节点（必为黑）对齐，二者联边调整为横向
	- 每棵红黑树**等价于一棵(2,4)树**，前者节点对应后者关键码
	- 通往红节点的边对B-树高度无贡献，在图中为虚线
	- ![[Pasted image 20241106113253.png]]
	- 转换后的(2,4)树**每个节点应包含且仅包含一个黑关键码，红色关键码不超过两个，若有两红色关键码，必有黑色关键码居中**
	- ![[Pasted image 20241106113327.png]]
- 平衡性：
	- 由B-树特性，红黑树的黑高度是平衡的
	- 可以证明红黑树高度h满足：$$log_2 (n+1)≤h≤2∙log_2 (n+1)$$
		- 证明：左侧显然，对右侧，若黑树高为H，则由B-树的结论，$$H\leq1+log_{⌈\frac{4}{2}⌉}⌊\frac{n+1}{2}⌋≤1+log_2(\frac{n+1}{2})≤log_2 {(n+1)}$$且任意通路不包含相邻的红节点，故$$h≤2H≤2log_2 {(n+1)}$$
	- 红黑树的适度平衡标准被放宽，节点左右子树高度不超过两倍即为平衡，降低了动态调整成本
- 节点插入：
	- 算法：
		- 首先调用search在树中查找关键码，若查找成功返回false；
		- 否则，在查找终止位置x处创建节点，并为它染成红色；
		- 红黑树的4条准则仅有3可能不满足，即新入的红节点的父亲也为红色，此时需解决**双红缺陷**，调用SolveDoubleRed()；找出节点x的父节点p，祖父节点g，叔父节点u，视u的颜色，分情况进行双红缺陷处理
	- 实现：![[Pasted image 20241111161557.png]]
	- 双红修正：
		- RR-1修正：按双红假设，父节点p为红，祖父g必为黑，因g为内部节点，其必有另一孩子u(可能为外部节点)，若u为黑色，由路径所经过黑节点数目相等，推知$T_0,T_1,T_2$根节点都为黑![[Pasted image 20241111161733.png]]
		- RR-2修正：若u为红色，u的左右孩子非空且根节点为黑色，则$T_0,T_1,T_2,T_3,T_4$的根节点都为黑![[Pasted image 20241111161911.png]]![[Pasted image 20241111162008.png]]
		- 验证：![[Pasted image 20241111162310.png]]
		- 复杂度：可以证明是常数复杂度，对树的拓扑结构改变的程度并不多
- 节点删除：类似的，需要解决双黑缺陷，分四种情况，参考书上的章节![[Pasted image 20241111162502.png]]
## KD树
- 背景：
	- 对一维的数据查询，蛮力搜索效率低下，有序的向量搜索可以通过先组织的方式，优化查询的复杂度
	- 缺点：复杂度与目标规模相关，是输出敏感算法，同时难以应对高维度的数据搜索
	- kd树是一种用于分割空间的一种平衡二叉树，用于实现高维的几何搜索
	- 一维数据结构用平衡二叉搜索树的查询：
		- O(nlogn)时间组织以下平衡二叉搜索树
		- 内部节点为其左子树的最大值
		- 关键码可重复，要求查找终止于叶子节点
		- 每个节点处只需做一次比较
		- 例：![[Pasted image 20241111162632.png]]![[Pasted image 20241111162646.png]]![[Pasted image 20241111162711.png]]复杂度：O(r+logn)，r为命中的数目
- 2d-树：
	- 核心思想：交替划分不同的维度，组织起不同的高维点的数据结构
	- 实现：![[Pasted image 20241111164255.png]]
	- 构造：按照横坐标与纵坐标依次分割构造平衡树![[Pasted image 20241111164141.png]]
		- 构造实现：![[Pasted image 20241111164346.png]]
	- 查询：剪枝算法
		- 算法：
			- 给定目标搜索区域R与节点矩形区域v
			- 判断R是否与节点所对应的元素形成的分割线(无限长)是否相交
			- 若不相交，则可对应减枝相应的左子树或右子树
			- 若相交，则根据相交线划分R为$R_1$和$R_2$，递归进入左右子树判断，并判断该节点元素是否在R内（若是输出）
		- 例：![[Pasted image 20241111164846.png]]
		- 实现：![[Pasted image 20241111164856.png]]
	- 最近邻查询：
		- 思想：
			1. 查询：目标Q从根结点开始，按Q与各个结点的比较结果向下访问Kd-Tree，直至叶结点。
				- 其中Q与结点的比较指的是将Q对应于结点中的k维度上的值与m进行比较，若Q(k) < m，则访问左子树，否则访问右子树
				- 达到叶子结点时，计算Q与叶子结点上保存的数据之间的距离，记录下最小距离对应的数据点，记为当前“最近邻点”$P_{min}$和最小距离$D_{min}$
			2. 回溯： 为找到离Q更近的“最近邻点”。即判断未被访问过的分支里是否还有离Q更近的点，它们之间的距离小于$D_{min}$。
				- 如果Q与其父结点下的未被访问过的分支之间的距离小于$D_{min}$，则认为该分支中存在离P更近的数据，进入该结点，进行（1）步骤一样的查找过程，如果找到更近的数据点，则更新为当前的“最近邻点”$P_{min}$，并更新$D_{min}$
				- 如果Q与其父结点下的未被访问过的分支之间的距离大于$D_{min}$ ，则说明该分支内不存在与Q更近的点。
				- 回溯的判断过程是从下往上进行的，直到回溯到根结点时已经不存在与P更近的分支为止。
				- 例1：
					- 查询：![[Pasted image 20241119191356.png]]
					- 回溯剪枝：![[Pasted image 20241119191511.png]]
				- 例2：
					- 查询：![[Pasted image 20241119191645.png]]
					- 回溯：找到更近的C节点![[Pasted image 20241119191841.png]]重复上述的步骤，剪枝![[Pasted image 20241119191901.png]]
				- 实现：![[Pasted image 20241119191944.png]]
- kd-树：多维空间的数据划分与搜索
	- 对上述2d-树作扩展，可以延伸到kd-树
	- 维度越高，剪枝算法效率降低，搜索效率越差，可以用优先级队列优化搜索的效率
---
[[L9 优先级队列]]