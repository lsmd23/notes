## 基本概念

- 树的定义：**递归定义**
	- 由n（n>=1）个有限节点组成一个具有层次关系的集合
	- 其中必有一个称为根的特定节点，它没有直接前驱，但有零个或多个直接后继
	- 除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，……Tm，其中每一个集合Ti（1<=i<=m）本身也是一棵树，被称作原树的子树。
	- ![[Pasted image 20241016113109.png]]
- 树的逻辑结构：
	- 定义：![[Pasted image 20241016113149.png]]
	- 关键数据：![[Pasted image 20241016113942.png]]
	- 性质：**height(T)≥height(v)+depth(v)**
- 二叉树：每个节点至多有两个孩子节点的树，并且区分左右孩子节点![[Pasted image 20241016114149.png]]
	- 完全二叉树：除了最后一层外，其他各层全是满的，并且最后一层的节点尽可能往左靠![[Pasted image 20241016114341.png]]
		- 二叉树的层：具有相同深度的节点所在的层相同
		- 第 i 层的最大节点数：$2^i$
	- 满二叉树：所有叶子节点都处于最底层的二叉树（树中所有层都是满的）
		- 节点总数：$2^{h+1}-1$
		- 叶子节点数：$2^h$
		- 内部节点数：$2^{h-1}$
	- 真二叉树：每个节点的孩子数目为0个或2个![[Pasted image 20241016115316.png]]
	- 平衡二叉树：树中任意节点的左右子树的高度差不超过k（通常k为1）![[Pasted image 20241016115333.png]]
		- 若算法复杂度为O(h)，为尽量保持树高较小，选择平衡二叉树
	- ==**二叉树的性质**==：
		1. 若二叉树节点的层次从 0 开始, 则在二叉树的第 i 层最多有 $2^i$ 个节点。(i≥0)
		2. 深度为 k 的二叉树最少有 k+1 个节点，最多有 $2^{k+1}-1$ 个节点。( k≥0 )
		3. 对任一棵二叉树，若度为 2 的节点有 $n_2$ 个,   则其叶节点个数 $n_0$ 满足 $n_0=n_2+1$
		4. 树的性质：树中节点数 = 总分叉数 +1$$N =1+n_1+2n_2+3n_3 +…+Kn_k$$$K$为分叉数
## 树的表示

- 节点接口：![[Pasted image 20241023095538.png]]
- 表示法：
	- 父亲表示法：![[Pasted image 20241023095707.png]]父亲表示法在查询节点孩子及兄弟时，效率不理想
	- 孩子表示法：![[Pasted image 20241023095929.png]]孩子表示法在查询节点父亲及根节点时，需遍历整个表，效率不理想
	- 父亲+孩子表示法：![[Pasted image 20241023100027.png]]每个节点所具有的孩子数量可能差异巨大，动态增加、删除、更新和维护树的拓扑时效率低
	- **长子+兄弟表示法**：![[Pasted image 20241023100152.png]]
		- 该转换保留了节点间的层级和兄弟关系，为一一映射。每个节点仅需维护最多两个邻域：孩子与下一兄弟
		- 按这样的表示法，任意有根有序的多叉树可以转化为二叉树
		- 同理，将森林的每棵树视为兄弟，森林也可转换为二叉树：![[Pasted image 20241023102134.png]]
		- 二叉树转换为多叉树：![[Pasted image 20241023100435.png]]
		- *二叉树的形态数目：n节点二叉树的形态数目即为n的卡特兰数：![[Pasted image 20241023101327.png]]*
## 二叉树的实现：

- 顺序（向量）表示：![[Pasted image 20241023101810.png]]
	- 非完全二叉树用向量表示，有比较大的空间浪费，空间利用率低
- 基于链式存储的实现：
	- 节点：![[Pasted image 20241023102600.png]]
		- 节点插入：![[Pasted image 20241023102959.png]]复杂度：$O(1)$
	- 二叉树模板类：![[Pasted image 20241023103157.png]]
		- 节点高度更新：![[Pasted image 20241023103423.png]]
		- 节点插入后，还需要做节点的高度更新：![[Pasted image 20241023104158.png]]
- ==**二叉树的遍历**==：
	- 分类：层次遍历（广度优先）；先序、中序、后序遍历（深度优先）
	- ![[Pasted image 20241023104749.png]]
	- 层次遍历：借助队列进行![[Pasted image 20241023105630.png]]
		- 代码实现：![[Pasted image 20241023105642.png]]**初始化时令根入队，随后进入循环。每一步迭代中，取出队首节点，然后其左右孩子入队。一旦试图在下一迭代前发现队列为空，遍历即告完成。复杂度$O(n)$**
	- 前序遍历：递归实现![[Pasted image 20241023110019.png]]
		- 复杂度：由于有函数的调用栈，有额外的空间开销，空间复杂度$O(h)$，时间复杂度$O(n)$
	- 中序遍历，后序遍历与之类似
	- 遍历的应用：
		- 计算子树规模：![[Pasted image 20241023110844.png]]利用树的自相似，递归编程实现。易见复杂度取决于子树的总规模，为$O(n)$
		- 计算树的高度：![[Pasted image 20241023111136.png]]同理，复杂度为$O(n)$
		- 子树与树的删除与析构：![[Pasted image 20241023111039.png]]
	- 二叉树的重构：
		- 给定遍历序，可以重构二叉树![[Pasted image 20241023111712.png]]
			- 例：![[Pasted image 20241023111949.png]]
			- 伪代码：![[Pasted image 20241023112006.png]]
			- *问题：前序序列固定，有多少种可能的中序序列？答案：卡特兰数，等效于n个节点的二叉树形态数*
- 判定树：成绩分区判定
	- ![[Pasted image 20241030095641.png]]对该图所示的树，若成绩分布如下，则比较效率低![[Pasted image 20241030095727.png]]
	- 改进树结构，可以提高效率![[Pasted image 20241030095753.png]]
- **==哈夫曼树（最优编码树）==**：
	- 叶子节点带权二叉树：![[Pasted image 20241030095904.png]]
		- 树的路径长度(PL)：所有节点从根到节点的路径长度之和
		- 节点的带权路径长度：节点路径长度与节点权重之积
		- 树的带权路径长度(WPL)：所有叶子节点的带权路径长度之和
	- **最优编码树（Huffman树）**：n个叶子节点，每个叶子带权，带权路径长度最小的二叉树为最优编码树
		- 构造方法：
			1. 给定的n个权值$\{w_1,w_2,….,w_n\}$构成森林F=$\{T_1,T_2,…,T_n\}$，其中每棵二叉树$T_i$中只有一个带权为$w_i$的根节点，左右子树均为空
			2. 在F中选取两棵根节点的权值最小的树作为左右子树构造一个新的二叉树，且置新的二叉树的根节点的权值为左右子树上根节点的权值之和
			3. 在F中删除这两棵树，同时将新得到的二叉树加入F中
			4. 重复2和3步骤，直到F中仅含一棵树为止，这棵树即为最优编码树
	- **哈夫曼编码**：提高压缩效率，要求任何码字都不是其他码字的前缀，是即时可译的（**前缀无歧义**）。要求对每个符号进行唯一的0/1编码，且平均码长最小
		- 利用前缀二叉树编码：
			- 字符为二叉树叶子节点
			- 左孩子路径标注1，右孩子路径标注0
			- 解码时逐个扫描比特沿二叉树路径到达叶子节点解码
		- 哈夫曼编码：按字符出现的概率为权值，建立哈夫曼树，以哈夫曼树为前缀二叉树进行编码 