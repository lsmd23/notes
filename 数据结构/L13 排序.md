## 基本概念

- 概述：
	- 排序：将一组杂乱无章的数据按一定规律顺次排列起来
	- 数据表(datalist)：它是待排序数据元素的有限集合
	- 排序码(key)：通常数据元素有多个属性域，即多个数据成员组成，其中有一个属性域可用来区分元素， 作为排序依据，该域即为排序码。每个数据表用哪个属性域作为排序码，要视具体的应用需要而定
	- 排序算法的稳定性：如果在元素序列中有两个元素r[i]和r[j], 它们的排序码 k[i] == k[j] , 且在排序之前, 元素r[i]排在r[j]前面。如果在排序之后, 元素r[i]仍在元素r[j]的前面,  则称这个排序方法是稳定的, 否则称这个排序方法是不稳定的![[Pasted image 20241224142448.png]]
	- 内排序与外排序：内排序是指在排序期间数据元素全部存放在内存的排序；外排序是指在排序期间全部元素个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序
	- 排序算法的效率：
		- 排序的时间开销：衡量算法好坏的最重要的标志，可用算法执行中的数据比较次数与数据移动次数来衡量
			- 算法的运行时间代价一般都按平均情况进行估算。对于那些受元素排序码序列初始排列及元素个数影响较大的，需要按最好情况和最坏情况进行估算
		- 算法还需考虑算法执行时所需的附加存储，即其空间复杂度
## 希尔排序

- 插入排序：
	- 基本思路：每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上，直到元素全部插入为止
		- ![[Pasted image 20241224142650.png]]
	- 代码实现：![[Pasted image 20241224142707.png]]
	- 性能分析：
		- 排序的比较次数和移动次数**与初始有序程度有关**
		- **最好情况下**为有序序列，每趟只需与前面有序元素序列的最后一个元素比较1次，总的排序码比较次数为n-1，元素移动次数为0，**复杂度$O(n)$**
		- **最坏情况下**，第 i 趟时第 i 个元素必须与前面 i-1 个元素都做排序码比较，每做1次比较要做1次数据移动。则总比较次数和移动次数皆**为$O(n^2)$**
		- 平均情况下排序的**时间复杂度为$O(n^2)$**
		- 插入排序为**稳定的**排序算法
- 希尔排序：
	- 特点：基于插入排序的改进，是一种非稳定的排序算法
	- 基本思路：
		- 设待排序元素序列有 n 个元素, 首先取一整数 gap < n 作为间隔，将全部元素分为 gap 组，所有距离为 gap 的元素放在同一组中，在每组中分别施行插入排序
		- 然后缩小间隔 gap,  如取 $gap = \lceil gap/2 \rceil$，重复上述的组划分和排序工作，直到最后取 gap = 1，将所有元素放在同一组中排序为止
		- 开始时 gap 值较大，组中元素较少，排序速度较快;  单次交换可减少整体的更多逆序对
		- 随着排序进展，gap 值逐渐变小，组中元素个数逐渐变多，由于前面工作的基础，大多数元素已基本有序，所以排序速度仍然很快
		- **核心思想：在粗尺度进行排序可减少更多的逆序对**
	- 代码实现：![[Pasted image 20241224144414.png]]
	- 性能分析：
		- gap序列的取法影响排序的效率，比较简单的是$gap = \lfloor n/2 \rfloor$，但并非最优。通过改变这一序列，可以将复杂度降低到$O(n^{\frac{3}{2}})$，$O(n\log^2 n)$，$O(n^{\frac{7}{6}})$等等
		- 这种多尺度分级的思想也广泛见于各类问题的处理中
## 快速排序

- 归并排序：见[[L2 向量#排序算法|向量的排序]]
	- 总结：归并排序时间复杂度低，为$O(n\log n)$，但需要额外的空间开销。归并排序是**稳定的排序**
- 冒泡排序：见[[L2 向量#排序算法|向量的排序]]
	- 第i趟对待排序元素序列$V[i-1],V[i],...,V[right]$进行排序，结果将排序码最小的元素交换到序列的首位置(i-1)
	- 最多做 n-1 趟起泡就能把所有元素排好序
	- **最好情况**：在元素的初始排列已经按排序码从小到大排好序时，此算法只执行一趟起泡，做n-1次排序码比较，不移动元素，复杂度$O(n)$
	- 算法执行n-1趟起泡,第i趟 (1≤ i<n) 做n-i次排序码比较, 执行n-i次元素交换。在**最坏情形下**总的排序码比较次数KCN和元素移动次数RMN皆**为$O(n^2)$**
	- 起泡排序是一个**稳定的排序方法**
- 快速排序：
	- 基本思想：
		- 任取待排序元素序列中的某个元素 (例如取第一个元素)作为基准，按照该元素的排序码大小，将整个元素序列划分为左右两个子序列(分治策略)
		- 左侧子序列中所有元素的排序码都小于或等于基准元素的排序码，右侧子序列中所有元素的排序码都大于基准元素的排序码，基准元素置于两个子序列中间(这也是该元素最终应安放的位置)
		- 分别对这两个子序列重复施行上述方法，直到所有的元素都排在相应位置上为止
		- 选取的该特殊元素称为轴点Pivot：以轴点为界，整个序列被分成左、右两个独立的子序列，递归的对两个子序列进行排序![[Pasted image 20241224145803.png]]
	- 算法描述（伪代码）：
		- ![[Pasted image 20241224145834.png]]
	- 代码实现：![[Pasted image 20241224145915.png]]
	- 性能分析：
		- 快速排序是一个递归算法，其递归树如图，交换的趟数取决于递归树的高度
			- ![[Pasted image 20241224145941.png]]
		- 算法partition利用序列第一个元素作为基准，将整个序列划分为左右两个子序列。只要是排序码小于基准元素排序码的元素都移到序列左侧，最后基准元素安放到位
		- 理想情况：每次划分对一个元素定位后，该元素的左侧子序列与右侧子序列的长度相同，则下一步将是对两个长度减半的子序列进行排序
		- 递归推导，可知，其**平均复杂度为$O(n \log n)$**，**空间开销**源自调用栈，**为$O( \log n)$**，**最坏情况下**复杂度**为$O(n^2)$**
		- 当 n 很小时，这种排序方法往往比其它简单排序方法还要慢
	- 改进：
		1. 在递归调用过程中，当待排序的子序列规模小于预先确定的M时，程序转而调用直接插入排序算法对该子序列进行排序，从而解决规模小的数据的排序问题
			- 代码实现：![[Pasted image 20241224150458.png]]
		2. 在划分过程中对小规模的子序列不进行排序而直接跳过，这样在划分之后得到的是一个整体上几乎已经排好序的序列。此时，插入排序效率很高
			- 代码实现：![[Pasted image 20241224150602.png]]
		3. 优化pivot的选取
			- 最坏情况是因为其选取的pivot元素不合理，因此，可以优化pivot的选取，使得每次划分所得的两个子序列中的元素个数尽可能接近，将会明显加快排序速度。
			- 取每个待排序元素序列的第一个元素、最后一个元素和位置接近正中的 元素，在这三者中取其排序码居中者作为基准元素
			- 代码实现：![[Pasted image 20241224150720.png]]
## 选择排序与堆排序

- 选择排序：见[[L2 向量#排序算法|向量的排序]]
- 堆排序：见[[L9 优先级队列#^e10732|堆排序]]
	- 复杂度：$O(n \log n)$
## 排序算法

- ![[Pasted image 20241224151155.png]]
	- 堆排序每次取一个最大值和堆底部的数据交换，重新筛选堆，把堆顶调整到位，有很大可能是依旧调整到堆的底部，然后再次和堆顶最大值交换，再调整下来。从上面看出，堆排序做了许多无用功
	- 快速排序每下一次寻址都是紧挨当前地址的，而堆排序的下一次寻址和当前地址的距离比较长
## k-选取

- 问题描述：
	- 任一组可比大小的元素中，找到其中从小到大次序为k者![[Pasted image 20241224151748.png]]
		- 特例：选取中位数
		- 蛮力算法：先排序，后选取，复杂度为$O(n \log n)$
- 基于堆的实现：
	- 构建小顶堆，后经k次删除，获次序为k的元素
		- ![[Pasted image 20241224152039.png]]
		- 适合k小的情况
	- 任选k个构成大顶堆，对剩余n-k个数个插入，每插入一个就删除堆顶，堆顶即为目标元素
		- ![[Pasted image 20241224152057.png]]
		- 适合k大的情况
	- 缺点：两种方法在k接近n/2时，复杂度仍为O(nlogn)
- 基于快速划分的实现：
	- 思路：
		- 基于快速排序思想，反复调用partition算法构建轴点，逼近秩为k元素![[Pasted image 20241224152926.png]]
		- 若选取pivot= partition()秩为k，则刚好返回，若k<pivot，则递归对L进行划分，不再考虑G，若k>pivot，则递归对G进行划分，不再考虑L
	- 代码实现：![[Pasted image 20241224152955.png]]
	- 复杂度：平均为$O(n)$，最坏$O(n^2)$