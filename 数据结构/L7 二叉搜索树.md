## 基本概念

- 对查找、插入、删除三种最常用的操作，复杂度：![[Pasted image 20241030102454.png]]对有序向量改进，实现对这三种操作的优化
- 定义：空树，或者是满足以下条件的二叉树
	- 每个节点都有一作为搜索依据的关键码(key)
	- 任意节点的左子树（若非空）的关键码都小于等于该节点关键码
	- 任意节点的右子树（若非空）的关键码都大于等于该节点关键码
	- 对这样的树作中序遍历，还原为线性结构。任意一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降
## 实现与基本接口

- ==**搜索**==：从根结点开始，逐层向下比较判断（递归或迭代均可）。若当前节点为空，返回NULL；若当前节点大于目标关键码，继续搜索右子树；若当前节点小于目标关键码，继续搜索左子树；否则表示命中，返回该节点地址
	- 实现：![[Pasted image 20241030103355.png]]
	- **时间复杂度：$O(h)$**
- **==插入==**：插入新元素前须搜索该元素是否已存在，若是则不再插入，若搜索不成功，把新节点加到搜索停止的地方
	- **新元素的插入总是作为叶子节点插入**
	- 插入总能保证二叉搜索树特性
	- 实现：![[Pasted image 20241030104229.png]]
	- **时间复杂度：$O(h)$**
	- 构建：不断调用插入函数![[Pasted image 20241030104341.png]]
		- 代码实现：![[Pasted image 20241030104424.png]]
- **==删除==**：保持二叉搜索树的特性
	- 被删节点位于叶子节点，只需将其父节点指向它的指针清零，再释放它即可
	- 被删节点左子树为空，用被删节点右子树顶替，再释放它即可![[Pasted image 20241030104920.png]]
	- 被删节点右子树为空，用被删节点左子树顶替，再释放它即可
	- 被删除节点左右子树都不为空，可进行以下处理：以在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被删节点中，再递归处理该节点的删除![[Pasted image 20241030104940.png]]
	- 代码实现：![[Pasted image 20241030105002.png]]
		- **复杂度$O(h)$**
- 实现：
	- 模板类定义：![[Pasted image 20241030105559.png]]**注意_hot的使用：命中节点的父亲**
	- 搜索：![[Pasted image 20241030105823.png]]返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL
	- 插入：![[Pasted image 20241030110004.png]]无论插入成功与否都会返回非空的节点位置，此节点所指向内容为目标关键码，复杂度O(h)
	- 删除：![[Pasted image 20241030110217.png]]
		- 复杂度O(h)
		- 单分支![[Pasted image 20241030110404.png]]双分支![[Pasted image 20241030110646.png]]
	- 节点的直接后继![[Pasted image 20241030110757.png]]
## 树高和性能

- 复杂度和树高相关，因此树高决定了树的性能
- 树的平均高度：
	- 树高与树的构建时关键码的输入次序相关：按关键码大小顺序输入构建二叉搜索树时，树高h=n；按照完全二叉树的层次遍历输入时，树高h=logn
	- 随机生成：n个节点的关键码按照不同顺序有n!种全排列，按照排列顺序输入构建二叉搜索树，假设各排列概率均等，可证明二叉搜索树平均高度Θ(logn)
	- 随机组成：n个节点的二叉搜索树形态共$\frac{(2n)!}{n!/(n+1)!}$(卡特兰数)，假设各形态概率均等，可证明二叉搜索树平均高度$Θ(n^{1/2})$
- 平衡与调整：
	- 理想平衡与适度平衡：![[Pasted image 20241030111706.png]]
	- 等价：两棵二叉搜索树的中序遍历序列相同，则称它们彼此等价
	- 局部调整：使二叉搜索树在动态增减过程中保持适度平衡（调整为等价的平衡二叉搜索树）![[Pasted image 20241030112056.png]]
- 平衡二叉搜索树：也叫平衡二叉树, 每个节点左子树和右子树高度差至多等于1
	- 平衡因子：左右子树高度差，$balFac(v)=height(lc(v))-height(rc(v))$
	- AVL树：平衡因子受限的二叉搜索树（各节点balFac绝对值不超过1）
		- 规模为n的AVL，height(AVL)=O(logn)
		- 等价于证明在高度给定下，AVL树的节点规模n不至于太少 $n = Ω(2^{height(AVL)} )$
		- 失衡与重平衡：在每插入一个节点或删除一个节点时，检查平衡性，找到插入删除导致的最小失衡子树，并进行局部调整保持平衡
- 平衡化旋转：
	- 分类：左单旋(zag旋转，逆时针旋转)；右单旋(zig旋转 ，顺时针旋转)；先左后右双旋(zagzig旋转)；先右后左双旋(zigzag旋转）
	- 从变动位置沿通向根的路径回溯，检查各结点的平衡因子，从首次发生不平衡的节点（最小失衡子树）起，沿刚才回溯的路径取直接下两层的节点分析（最小失衡节点高度必大于等于2）
	- 最小失衡子树根节点记为”g”（grandparent），其下层节点记为”p”(parent)，孙子节点记为”v”(对插入来说为插入节点)
	- 如果这三个结点处于一条直线上，则采用单旋转进行平衡化，单旋转可按其方向分为左单旋转和右单旋转；如果这三个结点处于一条折线上，则采用双旋转进行平衡化，双旋转分为先左后右和先右后左两类![[Pasted image 20241030113354.png]]
	- 调整：![[Pasted image 20241030113746.png]]![[Pasted image 20241030113803.png]]![[Pasted image 20241030113811.png]]
	- 旋转操作：![[Pasted image 20241030114054.png]]![[Pasted image 20241030114255.png]]
- 统一重平衡算法：根据g，p，v对全树的分割，直接对树的结构进行重排
	- 代码实现：![[Pasted image 20241030115029.png]]![[Pasted image 20241030115046.png]]
- 节点的删除：
	- 删除点的父节点以及更高的祖先节点都可能出现非平衡情况，需要迭代地从下往上检查该子树的祖先，如发现新的非平衡子树，则迭代调整
	- 复杂度分析 : 重平衡节点都是x的祖先，因此最多O(logn)次重平衡，总体复杂度O(logn)
- 节点的插入：
	- 新插入点x后，非平衡子树UT(x)都是x的祖先，高度不低于x的祖父
	- 从x或x的父亲回溯，到达首个非平衡节点，记为g（祖父）
	- p和v的高度必然大于等于其兄弟节点，因此可通过tallerChild找到孩子中高度大的作为p(父亲)和v
---
[[L8 高级搜索树]]