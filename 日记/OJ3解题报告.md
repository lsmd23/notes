# 第一题：无限广播
## 解题思路
这道题的核心是判断一个图是否是二分图。二分图是指可以将图的顶点集合分成两个不相交的子集，使得每条边的两个顶点分别属于不同的子集。对于这道题来说，可以将两个频段看作两个子集，如果能够将所有的镇分配到两个频段中，使得相邻的镇使用不同的频段，则满足要求。
## 算法步骤
- **图的表示**：使用邻接表表示图。顶点集合使用一个 `Vector<Vertex>` 存储，每个顶点包含一个编号和一个状态（未访问、访问过的频段1、访问过的频段2）。边集合使用一个 `Vector<Vector<int>>` 存储，每个顶点对应一个向量，存储与其相邻的顶点。
- **图的初始化**：根据输入的镇数 n 和边数 m，初始化顶点集合和边集合。对于每个输入的边，添加到邻接表中。
- **广度优先搜索（BFS）**：遍历所有顶点，从每个未访问的顶点开始一次BFS。使用一个队列 `Queue<int>` 存储待访问的顶点。对于每个顶点，将其标记为访问过的频段1或频段2，并将其相邻的未访问顶点加入队列。如果发现相邻顶点已经访问且状态相同，则返回-1，表示不能满足要求。
- **结果输出**：如果所有顶点都能成功分配频段，则返回1，表示满足要求。
## 复杂度分析
- **时间复杂度**：初始化图的时间复杂度为 $O(n + m)$，其中 n 是顶点数，m 是边数。BFS 的时间复杂度为 $O(n + m)$，因为每个顶点和每条边最多访问一次。因此，总时间复杂度为 $O(n + m)$。
- **空间复杂度**：邻接表的空间复杂度为 $O(n + m)$，队列的空间复杂度为 $O(n)$，顶点状态数组的空间复杂度为 $O(n)$。因此，总空间复杂度为 $O(n + m)$。
## 数据结构
- **Vector**：用于存储顶点集合和边集合。Vector 是一个动态数组，支持随机访问和动态扩展。
- **Queue**：用于广度优先搜索中的队列操作。Queue 是一个先进先出的数据结构，支持高效的入队和出队操作。
- **Graph**：基于邻接表储存的图，题中每个小镇就是一个节点，利用BFS解决题目要求的问题
# 第二题：旅行商
## 解题思路
这道题的核心是找到一个有向无环图（DAG）中的最长路径。由于图中没有环，因此可以使用拓扑排序来解决这个问题。可以使用广度优先搜索（BFS）来进行拓扑排序，并在排序过程中计算每个顶点的最长路径。
## 算法步骤
1. **图的表示**：使用邻接表表示图。顶点集合使用一个 `Vector<Vertex>`存储，每个顶点包含一个编号、入度、出度、状态和距离。边集合使用一个 `Vector<Vector<int>>`存储，每个顶点对应一个向量，存储与其相邻的顶点。
2. **图的初始化**：根据输入的村庄数 n 和道路数 m，初始化顶点集合和边集合。对于每个输入的边，添加到邻接表中，并更新顶点的入度和出度。
3. **广度优先搜索（BFS）**：遍历所有顶点，将所有入度为0的顶点入队，对应于要从每个入度为0的点进行BFS。对于每个顶点，将其出度为0的邻接点的距离更新为当前顶点的距离加1，并将其入度减1。如果邻接点的入度变为0，则将其入队。只有当遍历到的点是终点，也即出度为0时，比较记录最大距离。
4. **结果输出**：返回最大距离加1，表示最多经过的村庄数。
## 复杂度分析
- **时间复杂度**：初始化图的时间复杂度为 O(n + m)，其中 n 是顶点数，m 是边数。BFS 的时间复杂度为 O(n + m)，因为每个顶点和每条边最多访问一次。因此，总时间复杂度为 O(n + m)。
- **空间复杂度**：邻接表的空间复杂度为 O(n + m)，队列的空间复杂度为 O(n)，顶点状态数组的空间复杂度为 O(n)。因此，总空间复杂度为 O(n + m)。
## 数据结构
- **Vector**：用于存储顶点集合和边集合。Vector是一个动态数组，支持随机访问和动态扩展。
- **Queue**：用于广度优先搜索中的队列操作。Queue是一个先进先出的数据结构，支持高效的入队和出队操作。
- **Graph**：使用邻接表的方式存储一个有向图，基于有向图实现BFS
# 第三题：平均气温
## 解题思路
这道题的核心是高效地在二维平面上进行范围查询，以计算指定矩形区域内所有观测站的平均气温。由于观测站数量和查询次数都可能非常大，暴力算法无法满足时间要求。为了高效地进行范围查询，我们选择使用2D树。通过2D树，我们可以在 $O(\log n)$ 的时间复杂度内进行插入和查询操作。
## 算法步骤
1. **数据预处理**：
   - 读取所有观测站的数据，并存储在一个向量中。
   - 利用这个向量构建一棵二维树，将所有观测站插入到二维树中。
2. **查询处理**：
   - 对于每个查询，使用二维树进行范围查询，计算指定矩形区域内所有观测站的总气温和数量。
   - 计算平均气温，并通过接口返回结果。
## 具体实现
### 数据预处理
1. **读取观测站数据**：
   - 使用 `GetNumOfStation()` 函数获取观测站数量。
   - 使用 `GetStationInfo()` 函数获取每个观测站的坐标和温度，并存储在向量中。
2. **构建二维树**：
   - 使用递归方法构建二维树，每次选择当前维度的中位数作为根节点，并将数据划分为左右子树。
### 查询处理
1. **范围查询**：
   - 使用递归方法在二维树中进行范围查询，检查每个节点是否在查询矩形区域内。
   - 如果整个子树都在查询区域内，直接使用子树的总气温和节点数量。
   - 否则，递归查询左右子树。
2. **计算平均气温**：
   - 根据查询结果计算平均气温，并通过 `Response()` 函数返回结果。
### 复杂度分析
- **构建二维树**：构建二维树的时间复杂度为 $O(n \log n)$，其中 n 是观测站的数量。每次递归划分数据集的时间复杂度为 $O(n)$，递归深度为 $O(\log n)$。
- **范围查询**：范围查询的时间复杂度为 $O(\sqrt{n} + k)$，其中 n 是观测站的数量，k 是查询结果的数量。二维树的查询效率较高，可以在较短时间内完成查询。
- **总时间复杂度**：总时间复杂度为 $O(n \log n + m (\sqrt{n} + k))$，其中 n 是观测站的数量，m 是查询次数，k 是查询结果的数量。由于经过了优化，k远小于命中点的个数。
### 优化思路
1. **子树信息缓存**：在构建二维树时，为每个节点缓存子树的总气温和节点数量，以及节点负责的整个区域的大小（用矩形的左下，右上两个角坐标表示）。在查询时，如果整个子树都在查询区域内，直接使用缓存信息，避免重复计算。
2. **剪枝优化**：在查询过程中，利用节点的坐标范围进行剪枝，减少不必要的递归调用。
3. **快速选择算法**：在建树的查找中位数函数中，使用了快速选择的算法，使得每次选择的平均复杂度都是 $O(n)$ ，这样大大降低了建树的时间消耗，使得建树的时间消耗为 $O(n)$ 。
### 总结
通过使用2D Tree数据结构，我们可以高效地进行范围查询，计算指定矩形区域内所有观测站的平均气温。该算法的时间复杂度为 $O(n \log n + m (\sqrt{n} + k))$，能够在给定的限制内高效运行。优化思路包括子树信息缓存和剪枝优化，以进一步提高查询效率。