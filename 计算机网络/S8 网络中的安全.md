# 网络安全概述
- 核心目标：
	- 机密性（Confidentiality）：仅发送方和接收方可以理解消息内容，因此，需要发送方加密，接收方解密
	- 认证（Authentication）：发送方和接收方彼此确认对方身份
	- 消息完整性（Message Integrity）：确保消息在传输过程中未被篡改且可以被验证
	- 访问与可用性（Access and Availability）：确保合法用户能够访问网络资源，防止拒绝服务攻击等威胁
- 实例：对一个发送方，和一个接收方，入侵者可能实施的威胁行为有：
	- 窃听并拦截消息
	- 主动插入消息
	- 伪装数据包地址
	- 劫持、接管连接
	- 拒绝服务攻击
# 密码学原理
- 基本概念：
	- 定义：
		- $m$：明文消息
		- $K_A, K_B$：发送方A和接收方B的密钥
		- $K_A(m))$：使用A的密钥对消息$m$进行加密后得到的密文
		- $K_B(K_A(m))=m$：使用B的密钥对密文进行解密后得到的明文
	- 攻击方式：
		- 唯密文攻击（Ciphertext-only attack）：攻击者只能获取密文分析，需要遍历密钥破解加密算法
		- 已知明文攻击（Known-plaintext attack）：攻击者拥有一些明文和对应密文，可以利用这些信息推断密钥
		- 选择明文攻击（Chosen-plaintext attack）：攻击者可以选择明文并获取对应密文，进一步分析加密算法
## 对称密钥密码
- 特点：发送方和接收方共享同一密钥进行加密和解密，加密算法公开
	- $m\rightarrow K_S(m) \rightarrow K_S(K_S(m))$
- 分类：
	- 流密码（Stream Cipher）：逐位加密的方法
	- 块密码（Block Cipher）：将数据分成固定大小的块进行加密的方法
- 流密码：
	- 示意图：![[Pasted image 20251203163839.png]]
	- 工作机制：
		1. 密钥流生成：输入密钥，通过密钥流生成器生成伪随机的密钥流（keystream）
		2. 加密过程：将明文与密钥流逐位进行异或（$\oplus$）运算，生成密文
		3. 解密过程：利用异或运算的可逆性，将密文与相同的密钥流逐位进行异或运算，恢复明文
		4. 数学表示：
			- $m(i)$：明文的第$i$位
			- $ks(i)$：密钥流的第$i$位
			- $c(i)$：密文的第$i$位
			- 加密：$c(i) = m(i) \oplus ks(i)$
			- 解密：$m(i) = c(i) \oplus ks(i)$
	- 常用算法：RC4流密码
		- 密钥长度灵活，可以在1-256位之间选择
		- 曾用于802.11的WEP协议和SSL协议
- 块密码：
	- 工作机制：将明文按固定长度分成块，并转化成等长的密文块
		- 例：![[Pasted image 20251203164357.png]]
	- 块密码的映射：
		- 当块大小为$n$位时，有$2^n$种可能的输入块和输出块，对应的映射数量为$(2^n)!$
		- 当$n$很小时，暴力破解是可行的；但当$n$稍大时，映射数量会迅速增大，导致无法以表的形式存储，加密本身也变得复杂
	- 轮函数模拟法：解决块密码映射复杂性问题
		- 流程示意：![[Pasted image 20251203164752.png]]
			- 将输入拆分成8个8位的块
			- 每个块经过$S$盒替换
			- 替换后数据重组位64位结果，再置换到不同位置
			- 重复多轮处理，最终输出64位密文块
		- 作用：多轮的迭代和替换增加了加密的复杂性和安全性，使之可以以尽可能高的效率实现强加密
			- 轮数越多，计算成本越高，但安全性也越强
		- 问题：对同一个明文块，会输出相同的密文块，容易被攻击者利用；因此需要进行一些随机化处理，保证密文的多样性
	- 密码块链接（Cipher Block Chaining, CBC）模式：
		- 工作原理：
			- 为每个块生成一个随机数$r(i)$
			- 加密时使用前一块密文与明文块进行异或运算，再进行加密：$c(i) = K_S(m(i) \oplus c(i-1)$
			- 解密时，利用前一块密文与解密后的密文块进行异或运算恢复明文：$m(i) = K_S(c(i)) \oplus c(i-1)$
			- 初始块使用一个随机初始化向量（IV）$r(0)$代替前一块密文，无需保密
		- 效果示意：![[Pasted image 20251203165629.png]]保证相同明文不会产生相同密文
	- 常用算法：
		- DES算法（Data Encryption Standard）：
			- 特点：块大小64位，密钥长度56位，使用CBC模式
			- 在1天内被破解，现在常使用改进后的3DES算法提升安全性
			- 流程：
				- 初始置换 $\rightarrow$ 16轮迭代，每轮用密钥的48位子密钥进行加密 $\rightarrow$ 最终置换
				- 每轮将数据分为两部分，通过轮函数混淆扩散
				- 示意图：![[Pasted image 20251203165950.png]]
		- AES算法（Advanced Encryption Standard）：
			- 特点：块大小128位，密钥长度128、192或256位
			- 采用多轮替换和置换，安全性高且效率较高（几乎不可能被暴力破解）
			- 目前被广泛应用于HTTPS等安全协议中
## 公钥密码
- 特点：使用一组公钥和私钥进行加密和解密，公钥公开，私钥保密
	- 示意图：![[Pasted image 20251203171004.png]]
	- 使用公钥$K_B^+$加密消息$m$，得到密文$c$：$c = K_B^+(m)$；再使用私钥$K_B^-$解密密文$c$，恢复明文$m$：$m = K_B^-(K_B^+(m))$
	- 要求知晓公钥的人无法通过公钥推导出私钥
- RSA算法：
	- 模运算：
		- 定义：对于整数$a$和$b$，以及正整数$n$，如果存在整数$k$使得$a - b = kn$，则称$a$与$b$模$n$同余，记作$a \equiv b \mod n$
		- 性质：
			1. $[(a \mod n) \pm (b \mod n)] \mod n \equiv (a \pm b) \mod n)]$
			2. $[(a \mod n) \cdot (b \mod n)] \mod n \equiv (a \cdot b) \mod n$
			3. $(a \mod n)^d \mod n \equiv a^d \mod n$
	- 思路：每个信息可以用一个数表示，加密信息和加密一个大数是等价的
	- 步骤：
		1. 生成密钥对：
			1. 选择两个大质数$p$和$q$
			2. 计算$n = p \cdot q$，以及$z = (p-1)(q-1)$
			3. 选定一个$e$，满足$1 < e < z$且$\gcd(e, z) = 1$（也即与$z$互质）
			4. 计算$d$，满足$e \cdot d \equiv 1 \mod z$（也即$ed-1$能被$z$整除）
			5. 公钥为$(e, n)$，私钥为$(d, n)$
		2. 加密与解密：
			1. 加密：将消息$m$转化为整数$c$，满足$0 \leq m < n$，计算密文$c$：$c \equiv m^e \mod n$
			2. 解密：使用私钥$(d, n)$计算明文$m$：$m \equiv c^d \mod n$
		- 例：![[Pasted image 20251203200952.png]]
	- 原理：
		- 已知对任意的$x$和$y$，有：$$x^y \mod n = x^{(y \mod z)} \mod n$$
		- 代入可得：$$\begin{align*}  c^d \mod n &= (m^e \mod n)^d \mod n \\  &= m^{ed} \mod n \\  &= m^{ed \mod z} \mod n \\  &= m \mod n \\ &=m\end{align*}$$
	- **可置换性**：RSA算法具有可置换性，即加密和解密的顺序可以互换
		- 证明：$$\begin{align*}  (m^e \mod n)^d \mod n &= m^{ed} \mod n \\  &= m^{de} \mod n \\  &= (m^d \mod n)^e \mod n \end{align*}$$
	- 安全性依赖：大整数在分解上是困难的，也即知晓$n$后难以推导出$p$和$q$
- 会话密钥：
	- 问题：RSA依赖大整数的幂运算，计算复杂度高，效率较低
	- 流程：
		- 通信双方通过RSA算法交换一个随机生成的对称密钥$K_S$（会话密钥）
		- 后续通信使用对称密钥$K_S$加密，提高效率
		- 结合对称密钥和公钥密码的优点，既保证安全性，又提升效率
# 报文完整性
- 通信双方应当能验证收到的报文是否可信
	- 内容完整性：消息内容未被增删、修改
	- 来源真实性：消息确实来自声称的发送方而非伪装者
	- 抗重放性：消息不是被截获后重新发送的旧消息
	- 序列完整性：消息按正确顺序到达且无遗漏
- 哈希函数与报文摘要：
	- 报文摘要（Message Digest）：通过哈希函数对变长消息进行处理，生成固定长度的摘要
		- 需要哈希函数是易于计算的，同时从计算结果不能反推出原始消息
		- 哈希函数可以是多对一的，但应当难以找到两个不同消息具有相同摘要（抗碰撞性）
		- 校验和就是一个弱的哈希函数例子，其不具有很强的抗碰撞性
	- 常用哈希算法：
		- MD5算法：使用4个步骤生成128位的哈希值
		- SHA-1算法：使用5个步骤生成160位的哈希值，被美国联邦政府采用
- 消息认证码（Message Authentication Code, MAC）：
	- 定义：通过在哈希计算中引入共享密钥，解决哈希函数易被篡改的问题
	- 示意图：![[Pasted image 20251203203223.png]]
	- 流程：
		- 发送方拼接消息$m$和密钥$s$，计算哈希值$MD_m = H(s||m  )$，发送消息和哈希的二元组$(m, MD_m)$
		- 接收方收到消息后，使用相同密钥$s$计算哈希值$MD_m' = H(s||m)$，并与收到的$MD_m$进行比较
	- 扩展：HMAC标准
		- 使用双重哈希解决潜在安全缺陷
		- 流程：
			- 将共享密钥$s$拼接在$m$前，计算中间摘要$MD_{inner} = H(s||m)$
			- 再将$s$拼接在中间摘要前，计算最终摘要$MD_m = H(s||MD_{inner})$
	- 应用：[[S4 网络层#OSPF协议|OSPF协议]]
		- 在OSPF协议中，需要在链路中洪泛通告LSA消息，因此，需要使用MAC确保消息的完整性和真实性，防止伪造和篡改
		- 认证方式：
			- 无认证，完全信任网络
			- 共享密码：将共享密码明文嵌入OSPF报文头中
				- 安全性低，易被窃听
			- 加密哈希（MD5）：报文头包含32位的序列号，之后通过上述加密哈希机制进行加密认证
				- 提升安全性，防止伪造和篡改
- 数字签名：基于公钥加密的认证算法
	- 签名：也即对某个报文进行可鉴别，但不可伪造的标记，确认报文的来源和完整性
	- 流程：
		- 发送方使用一对公私钥$(K_B^+, K_B^-)$，对消息$m$，使用私钥$K_B^-$进行加密，生成签名$\text{sig} = K_B^-(m)$
		- 任何一个接收方都可以用公钥$K_B^+$解密签名，恢复消息$m' = K_B^+(\text{sig})$，从而确认消息的来源是唯一的发送方
	- 优化：由于对大消息进行加密计算是及其低效的，因此使用哈希降低计算复杂度
		- 发送方计算消息的哈希$H(m)$，然后对哈希值进行签名：$\text{sig} = K_B^-(H(m))$
		- 发送方发送消息和签名的二元组$(m, \text{sig})$
		- 接收方计算消息的哈希$H(m)$，并使用公钥解密签名，恢复哈希值$H' = K_B^+(\text{sig})$
		- 如果可以确认$H(m) = H'$，则消息来源和完整性都得到保证
		- 示意图：![[Pasted image 20251203205432.png]]
- 公钥认证：数字签名依赖公钥的真实性，也即需要确认某人的公钥一定不能被伪造 ^3d0d52
	- 解决方案：使用数字证书，由可信的第三方（证书颁发机构CA）签发数字证书，绑定用户身份和公钥
	- 流程：
		- 用户向CA提供身份证明和公钥
		- CA生成数字证书，包含用户身份、公钥及CA的签名
		- 接收方通过CA公钥解密证书，获取用户公钥，验证签名真实性
	- 示意图：![[Pasted image 20251203210130.png]]![[Pasted image 20251203210134.png]]
	- 标准：X.509数字证书标准，包括用户信息、公钥、有效期、颁发机构等内容
# 端点鉴别
- 鉴别协议（Authentication Protocols）：在通信前，确认通信双方身份的协议
	- 目标：防止伪装和重放攻击，确保通信双方身份的真实性
- ap1.0：最简单的鉴别协议
	- 直接向接收方声明自己的身份
		- 示意图：![[Pasted image 20251203211544.png]]
	- 问题：极易受伪装和重放攻击
		- 示意图：![[Pasted image 20251203211605.png]]
- ap2.0：使用IP地址辅助验证
	- 流程：
		- 声明身份同时，附加上IP地址
		- 接收方可以验证数据包的源地址，并和声明的身份地址进行比对
		- 示意图：![[Pasted image 20251203211907.png]]
	- 问题：如果入侵者能够伪造IP地址，向自己的链路层发送带有不正确源IP地址的数据报，即可实现IP哄骗
		- 示意图：![[Pasted image 20251203212001.png]]
		- 如果链路层可以拒绝转发具有错误源地址的数据报，则可以防止此类攻击，但难以实现
- ap3.0：使用明文共享密钥
	- 发送方在发送上述信息的同时，附加一个发送方和接收方的共享密钥
		- 示意图：![[Pasted image 20251203212429.png]]
	- 问题：无法抵御重放攻击
		- 攻击者可以嗅探到发送的分组，之后用原文重新发送该分组
		- 示意图：![[Pasted image 20251203212527.png]]
- ap3.1：使用密文共享密钥
	- 发送方不在使用明文的密钥，而是使用加密过的密钥
		- 示意图：![[Pasted image 20251203212626.png]]
	- 问题：仍然无法抵御重放攻击
		- 示意图：![[Pasted image 20251203212637.png]]
- ap4.0：为抵御重放攻击引入随机数
	- 流程：
		- 发送方向接收方声明身份
		- 接收方生成随机数（nonce），并发送给发送方
			- 这一随机数应当是一次性的，且不能被预测
		- 发送方使用共享密钥对随机数进行加密，并发送回接收方
		- 接收方使用共享密钥解密随机数，并验证其正确性
		- 示意图：![[Pasted image 20251203212827.png]]
	- 优势：可以抵御重放攻击
	- 问题：依赖共享密钥进行加密和解密
- ap5.0：使用公钥密码进行鉴别
	- 流程：
		- 发送方向接收方声明身份
		- 接收方生成随机数（nonce），并发送给发送方
		- 发送方使用私钥加密随机数，并发送回接收方
		- 接收方使用发送方的公钥解密随机数，并验证其正确性
		- 示意图：![[Pasted image 20251203213028.png]]
	- 问题：存在中间人攻击
		- 攻击者截获接收方发送的随机数，并伪装成发送方向接收方发送加密后的随机数，同时也伪装成接收方向发送方发送消息
		- 示意图：![[Pasted image 20251203213144.png]]
		- 难以检测到，因此需要[[S8 网络中的安全#^3d0d52|公钥认证机制]]确保公钥的可靠性和真实性
# 安全电子邮件
- 为应用层的[[S2 应用层#电子邮件|电子邮件协议]]提供安全保障
- 机密邮件：要求邮件只有发送方和接收方可以阅读
	- 发送方：
		- 发送方生成随机对称密钥$K_S$
		- 用$K_S$加密邮件内容，生成密文$c = K_S(m)$
		- 用接收方的公钥$K_B^+$加密对称密钥，生成加密后的密钥$c_K = K_B^+(K_S)$
		- 发送方发送密文-密钥二元组$(c, c_K)$
	- 接收方：
		- 使用私钥$K_B^-$解密加密后的密钥，恢复对称密钥$K_S = K_B^-(c_K)$
		- 使用对称密钥$K_S$解密密文，恢复邮件内容$m = K_S(c)$
	- 示意图：![[Pasted image 20251203213713.png]]
- 身份认证与信息完整邮件：要求邮件能够验证发送方身份，且内容未被篡改
	- 发送方：
		- 计算邮件内容的哈希值$H(m)$
		- 使用发送方的私钥$K_A^-$对哈希值进行加密，生成数字签名$\text{sig} = K_A^-(H(m))$
		- 发送方发送邮件内容和签名的二元组$(m, \text{sig})$
	- 接收方：
		- 对收到的$m$计算哈希值$H'(m)$
		- 用公钥$K_A^+$解密签名，恢复哈希值$H = K_A^+(\text{sig})$
		- 比较$H'(m)$和$H$，验证邮件的完整性和发送方身份
	- 示意图：![[Pasted image 20251203213855.png]]
- 综合邮件：同时满足机密性、身份认证和信息完整性要求
	- 发送方：
		- 计算邮件内容的哈希值$H(m)$
		- 使用发送方的私钥$K_A^-$对哈希值进行加密，生成数字签名$\text{sig} = K_A^-(H(m))$
		- 将邮件内容$m$和签名$\text{sig}$拼接，生成组合消息$m' = m || \text{sig}$
		- 生成随机对称密钥$K_S$
		- 用$K_S$加密组合消息，生成密文$c = K_S(m')$
		- 用接收方的公钥$K_B^+$加密对称密钥，生成加密后的密钥$c_K = K_B^+(K_S)$
		- 发送方发送密文-签名-密钥三元组$(c, \text{sig}, c_K)$
	- 接收方：
		- 使用私钥$K_B^-$解密加密后的密钥，恢复对称密钥$K_S = K_B^-(c_K)$
		- 使用对称密钥$K_S$解密密文，恢复组合消息$m' = K_S(c)$
		- 将组合消息拆分为邮件内容$m$和签名$\text{sig}$
		- 对收到的$m$计算哈希值$H'(m)$
		- 用公钥$K_A^+$解密签名，恢复哈希值$H = K_A^+(\text{sig})$
		- 比较$H'(m)$和$H$，验证邮件的完整性和发送方身份
	- 示意图：![[Pasted image 20251203214050.png]]接收方逆序恢复即可