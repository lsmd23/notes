# 网络安全概述
- 核心目标：
	- 机密性（Confidentiality）：仅发送方和接收方可以理解消息内容，因此，需要发送方加密，接收方解密
	- 认证（Authentication）：发送方和接收方彼此确认对方身份
	- 消息完整性（Message Integrity）：确保消息在传输过程中未被篡改且可以被验证
	- 访问与可用性（Access and Availability）：确保合法用户能够访问网络资源，防止拒绝服务攻击等威胁
- 实例：对一个发送方，和一个接收方，入侵者可能实施的威胁行为有：
	- 窃听并拦截消息
	- 主动插入消息
	- 伪装数据包地址
	- 劫持、接管连接
	- 拒绝服务攻击
# 密码学原理
- 基本概念：
	- 定义：
		- $m$：明文消息
		- $K_A, K_B$：发送方A和接收方B的密钥
		- $K_A(m))$：使用A的密钥对消息$m$进行加密后得到的密文
		- $K_B(K_A(m))=m$：使用B的密钥对密文进行解密后得到的明文
	- 攻击方式：
		- 唯密文攻击（Ciphertext-only attack）：攻击者只能获取密文分析，需要遍历密钥破解加密算法
		- 已知明文攻击（Known-plaintext attack）：攻击者拥有一些明文和对应密文，可以利用这些信息推断密钥
		- 选择明文攻击（Chosen-plaintext attack）：攻击者可以选择明文并获取对应密文，进一步分析加密算法
## 对称密钥密码
- 特点：发送方和接收方共享同一密钥进行加密和解密，加密算法公开
	- $m\rightarrow K_S(m) \rightarrow K_S(K_S(m))$
- 分类：
	- 流密码（Stream Cipher）：逐位加密的方法
	- 块密码（Block Cipher）：将数据分成固定大小的块进行加密的方法
- 流密码：
	- 示意图：![[Pasted image 20251203163839.png]]
	- 工作机制：
		1. 密钥流生成：输入密钥，通过密钥流生成器生成伪随机的密钥流（keystream）
		2. 加密过程：将明文与密钥流逐位进行异或（$\oplus$）运算，生成密文
		3. 解密过程：利用异或运算的可逆性，将密文与相同的密钥流逐位进行异或运算，恢复明文
		4. 数学表示：
			- $m(i)$：明文的第$i$位
			- $ks(i)$：密钥流的第$i$位
			- $c(i)$：密文的第$i$位
			- 加密：$c(i) = m(i) \oplus ks(i)$
			- 解密：$m(i) = c(i) \oplus ks(i)$
	- 常用算法：RC4流密码
		- 密钥长度灵活，可以在1-256位之间选择
		- 曾用于802.11的WEP协议和SSL协议
- 块密码：
	- 工作机制：将明文按固定长度分成块，并转化成等长的密文块
		- 例：![[Pasted image 20251203164357.png]]
	- 块密码的映射：
		- 当块大小为$n$位时，有$2^n$种可能的输入块和输出块，对应的映射数量为$(2^n)!$
		- 当$n$很小时，暴力破解是可行的；但当$n$稍大时，映射数量会迅速增大，导致无法以表的形式存储，加密本身也变得复杂
	- 轮函数模拟法：解决块密码映射复杂性问题
		- 流程示意：![[Pasted image 20251203164752.png]]
			- 将输入拆分成8个8位的块
			- 每个块经过$S$盒替换
			- 替换后数据重组位64位结果，再置换到不同位置
			- 重复多轮处理，最终输出64位密文块
		- 作用：多轮的迭代和替换增加了加密的复杂性和安全性，使之可以以尽可能高的效率实现强加密
			- 轮数越多，计算成本越高，但安全性也越强
		- 问题：对同一个明文块，会输出相同的密文块，容易被攻击者利用；因此需要进行一些随机化处理，保证密文的多样性
	- 密码块链接（Cipher Block Chaining, CBC）模式：
		- 工作原理：
			- 为每个块生成一个随机数$r(i)$
			- 加密时使用前一块密文与明文块进行异或运算，再进行加密：$c(i) = K_S(m(i) \oplus c(i-1)$
			- 解密时，利用前一块密文与解密后的密文块进行异或运算恢复明文：$m(i) = K_S(c(i)) \oplus c(i-1)$
			- 初始块使用一个随机初始化向量（IV）$r(0)$代替前一块密文，无需保密
		- 效果示意：
			- ![[Pasted image 20251203165629.png]]
			- 保证相同明文不会产生相同密文
	- 常用算法：
		- DES算法（Data Encryption Standard）：
			- 特点：块大小64位，密钥长度56位，使用CBC模式
			- 在1天内被破解，现在常使用改进后的3DES算法提升安全性
			- 流程：
				- 初始置换 $\rightarrow$ 16轮迭代，每轮用密钥的48位子密钥进行加密 $\rightarrow$ 最终置换
				- 每轮将数据分为两部分，通过轮函数混淆扩散
				- 示意图：![[Pasted image 20251203165950.png]]
		- AES算法（Advanced Encryption Standard）：
			- 特点：块大小128位，密钥长度128、192或256位
			- 采用多轮替换和置换，安全性高且效率较高（几乎不可能被暴力破解）
			- 目前被广泛应用于HTTPS等安全协议中
## 公钥密码
- 特点：使用一组公钥和私钥进行加密和解密，公钥公开，私钥保密
	- 示意图：![[Pasted image 20251203171004.png]]
	- 使用公钥$K_B^+$加密消息$m$，得到密文$c$：$c = K_B^+(m)$；再使用私钥$K_B^-$解密密文$c$，恢复明文$m$：$m = K_B^-(K_B^+(m))$
	- 要求知晓公钥的人无法通过公钥推导出私钥
- RSA算法：
	- 模运算：
		- 定义：对于整数$a$和$b$，以及正整数$n$，如果存在整数$k$使得$a - b = kn$，则称$a$与$b$模$n$同余，记作$a \equiv b \mod n$
		- 性质：
			1. $[(a \mod n) \pm (b \mod n)] \mod n \equiv (a \pm b) \mod n)]$
			2. $[(a \mod n) \cdot (b \mod n)] \mod n \equiv (a \cdot b) \mod n$
			3. $(a \mod n)^d \mod n \equiv a^d \mod n$
	- 思路：每个信息可以用一个数表示，加密信息和加密一个大数是等价的
	- 步骤：
		1. 生成密钥对：
			1. 选择两个大质数$p$和$q$
			2. 计算$n = p \cdot q$，以及$z = (p-1)(q-1)$
			3. 选定一个$e$，满足$1 < e < z$且$\gcd(e, z) = 1$（也即与$z$互质）
			4. 计算$d$，满足$e \cdot d \equiv 1 \mod z$（也即$ed-1$能被$z$整除）
			5. 公钥为$(e, n)$，私钥为$(d, n)$
		2. 加密与解密：
			1. 加密：将消息$m$转化为整数$c$，满足$0 \leq m < n$，计算密文$c$：$c \equiv m^e \mod n$
			2. 解密：使用私钥$(d, n)$计算明文$m$：$m \equiv c^d \mod n$
		- 例：![[Pasted image 20251203200952.png]]
	- 原理：
		- 已知对任意的$x$和$y$，有：$$x^y \mod n = x^{(y \mod z)} \mod n$$
		- 代入可得：$$\begin{align*}  c^d \mod n &= (m^e \mod n)^d \mod n \\  &= m^{ed} \mod n \\  &= m^{ed \mod z} \mod n \\  &= m \mod n \\ &=m\end{align*}$$
	- **可置换性**：RSA算法具有可置换性，即加密和解密的顺序可以互换
		- 证明：$$\begin{align*}  (m^e \mod n)^d \mod n &= m^{ed} \mod n \\  &= m^{de} \mod n \\  &= (m^d \mod n)^e \mod n \end{align*}$$
	- 安全性依赖：大整数在分解上是困难的，也即知晓$n$后难以推导出$p$和$q$
- 会话密钥：
	- 问题：RSA依赖大整数的幂运算，计算复杂度高，效率较低
	- 流程：
		- 通信双方通过RSA算法交换一个随机生成的对称密钥$K_S$（会话密钥）
		- 后续通信使用对称密钥$K_S$加密，提高效率
		- 结合对称密钥和公钥密码的优点，既保证安全性，又提升效率
# 报文完整性
- 通信双方应当能验证收到的报文是否可信
	- 内容完整性：消息内容未被增删、修改
	- 来源真实性：消息确实来自声称的发送方而非伪装者
	- 抗重放性：消息不是被截获后重新发送的旧消息
	- 序列完整性：消息按正确顺序到达且无遗漏
- 哈希函数与报文摘要：
	- 报文摘要（Message Digest）：通过哈希函数对变长消息进行处理，生成固定长度的摘要
		- 需要哈希函数是易于计算的，同时从计算结果不能反推出原始消息
		- 哈希函数可以是多对一的，但应当难以找到两个不同消息具有相同摘要（抗碰撞性）
		- 校验和就是一个弱的哈希函数例子，其不具有很强的抗碰撞性
	- 常用哈希算法：
		- MD5算法：使用4个步骤生成128位的哈希值
		- SHA-1算法：使用5个步骤生成160位的哈希值，被美国联邦政府采用
- 消息认证码（Message Authentication Code, MAC）：
	- 定义：通过在哈希计算中引入共享密钥，解决哈希函数易被篡改的问题
	- 示意图：![[Pasted image 20251203203223.png]]
	- 流程：
		- 发送方拼接消息$m$和密钥$s$，计算哈希值$MD_m = H(s||m  )$，发送消息和哈希的二元组$(m, MD_m)$
		- 接收方收到消息后，使用相同密钥$s$计算哈希值$MD_m' = H(s||m)$，并与收到的$MD_m$进行比较
	- 扩展：HMAC标准
		- 使用双重哈希解决潜在安全缺陷
		- 流程：
			- 将共享密钥$s$拼接在$m$前，计算中间摘要$MD_{inner} = H(s||m)$
			- 再将$s$拼接在中间摘要前，计算最终摘要$MD_m = H(s||MD_{inner})$
	- 应用：[[S4 网络层#OSPF协议|OSPF协议]]
		- 在OSPF协议中，需要在链路中洪泛通告LSA消息，因此，需要使用MAC确保消息的完整性和真实性，防止伪造和篡改
		- 认证方式：
			- 无认证，完全信任网络
			- 共享密码：将共享密码明文嵌入OSPF报文头中
				- 安全性低，易被窃听
			- 加密哈希（MD5）：报文头包含32位的序列号，之后通过上述加密哈希机制进行加密认证
				- 提升安全性，防止伪造和篡改
- 数字签名：基于公钥加密的认证算法
	- 签名：也即对某个报文进行可鉴别，但不可伪造的标记，确认报文的来源和完整性
	- 流程：
		- 发送方使用一对公私钥$(K_B^+, K_B^-)$，对消息$m$，使用私钥$K_B^-$进行加密，生成签名$\text{sig} = K_B^-(m)$
		- 任何一个接收方都可以用公钥$K_B^+$解密签名，恢复消息$m' = K_B^+(\text{sig})$，从而确认消息的来源是唯一的发送方
	- 优化：由于对大消息进行加密计算是及其低效的，因此使用哈希降低计算复杂度
		- 发送方计算消息的哈希$H(m)$，然后对哈希值进行签名：$\text{sig} = K_B^-(H(m))$
		- 发送方发送消息和签名的二元组$(m, \text{sig})$
		- 接收方计算消息的哈希$H(m)$，并使用公钥解密签名，恢复哈希值$H' = K_B^+(\text{sig})$
		- 如果可以确认$H(m) = H'$，则消息来源和完整性都得到保证
		- 示意图：![[Pasted image 20251203205432.png]]
- 公钥认证：数字签名依赖公钥的真实性，也即需要确认某人的公钥一定不能被伪造 ^3d0d52
	- 解决方案：使用数字证书，由可信的第三方（证书颁发机构CA）签发数字证书，绑定用户身份和公钥
	- 流程：
		- 用户向CA提供身份证明和公钥
		- CA生成数字证书，包含用户身份、公钥及CA的签名
		- 接收方通过CA公钥解密证书，获取用户公钥，验证签名真实性
	- 示意图：![[Pasted image 20251203210130.png]]![[Pasted image 20251203210134.png]]
	- 标准：X.509数字证书标准，包括用户信息、公钥、有效期、颁发机构等内容
# 端点鉴别
- 鉴别协议（Authentication Protocols）：在通信前，确认通信双方身份的协议
	- 目标：防止伪装和重放攻击，确保通信双方身份的真实性
- ap1.0：最简单的鉴别协议
	- 直接向接收方声明自己的身份
		- 示意图：![[Pasted image 20251203211544.png]]
	- 问题：极易受伪装和重放攻击
		- 示意图：![[Pasted image 20251203211605.png]]
- ap2.0：使用IP地址辅助验证
	- 流程：
		- 声明身份同时，附加上IP地址
		- 接收方可以验证数据包的源地址，并和声明的身份地址进行比对
		- 示意图：![[Pasted image 20251203211907.png]]
	- 问题：如果入侵者能够伪造IP地址，向自己的链路层发送带有不正确源IP地址的数据报，即可实现IP哄骗
		- 示意图：![[Pasted image 20251203212001.png]]
		- 如果链路层可以拒绝转发具有错误源地址的数据报，则可以防止此类攻击，但难以实现
- ap3.0：使用明文共享密钥
	- 发送方在发送上述信息的同时，附加一个发送方和接收方的共享密钥
		- 示意图：![[Pasted image 20251203212429.png]]
	- 问题：无法抵御重放攻击
		- 攻击者可以嗅探到发送的分组，之后用原文重新发送该分组
		- 示意图：![[Pasted image 20251203212527.png]]
- ap3.1：使用密文共享密钥
	- 发送方不在使用明文的密钥，而是使用加密过的密钥
		- 示意图：![[Pasted image 20251203212626.png]]
	- 问题：仍然无法抵御重放攻击
		- 示意图：![[Pasted image 20251203212637.png]]
- ap4.0：为抵御重放攻击引入随机数
	- 流程：
		- 发送方向接收方声明身份
		- 接收方生成随机数（nonce），并发送给发送方
			- 这一随机数应当是一次性的，且不能被预测
		- 发送方使用共享密钥对随机数进行加密，并发送回接收方
		- 接收方使用共享密钥解密随机数，并验证其正确性
		- 示意图：![[Pasted image 20251203212827.png]]
	- 优势：可以抵御重放攻击
	- 问题：依赖共享密钥进行加密和解密
- ap5.0：使用公钥密码进行鉴别
	- 流程：
		- 发送方向接收方声明身份
		- 接收方生成随机数（nonce），并发送给发送方
		- 发送方使用私钥加密随机数，并发送回接收方
		- 接收方使用发送方的公钥解密随机数，并验证其正确性
		- 示意图：![[Pasted image 20251203213028.png]]
	- 问题：存在中间人攻击
		- 攻击者截获接收方发送的随机数，并伪装成发送方向接收方发送加密后的随机数，同时也伪装成接收方向发送方发送消息
		- 示意图：![[Pasted image 20251203213144.png]]
		- 难以检测到，因此需要[[S8 网络中的安全#^3d0d52|公钥认证机制]]确保公钥的可靠性和真实性
# 安全电子邮件
- 为应用层的[[S2 应用层#电子邮件|电子邮件协议]]提供安全保障
- 机密邮件：要求邮件只有发送方和接收方可以阅读
	- 发送方：
		- 发送方生成随机对称密钥$K_S$
		- 用$K_S$加密邮件内容，生成密文$c = K_S(m)$
		- 用接收方的公钥$K_B^+$加密对称密钥，生成加密后的密钥$c_K = K_B^+(K_S)$
		- 发送方发送密文-密钥二元组$(c, c_K)$
	- 接收方：
		- 使用私钥$K_B^-$解密加密后的密钥，恢复对称密钥$K_S = K_B^-(c_K)$
		- 使用对称密钥$K_S$解密密文，恢复邮件内容$m = K_S(c)$
	- 示意图：![[Pasted image 20251203213713.png]]
- 身份认证与信息完整邮件：要求邮件能够验证发送方身份，且内容未被篡改
	- 发送方：
		- 计算邮件内容的哈希值$H(m)$
		- 使用发送方的私钥$K_A^-$对哈希值进行加密，生成数字签名$\text{sig} = K_A^-(H(m))$
		- 发送方发送邮件内容和签名的二元组$(m, \text{sig})$
	- 接收方：
		- 对收到的$m$计算哈希值$H'(m)$
		- 用公钥$K_A^+$解密签名，恢复哈希值$H = K_A^+(\text{sig})$
		- 比较$H'(m)$和$H$，验证邮件的完整性和发送方身份
	- 示意图：![[Pasted image 20251203213855.png]]
- 综合邮件：同时满足机密性、身份认证和信息完整性要求
	- 发送方：
		- 计算邮件内容的哈希值$H(m)$
		- 使用发送方的私钥$K_A^-$对哈希值进行加密，生成数字签名$\text{sig} = K_A^-(H(m))$
		- 将邮件内容$m$和签名$\text{sig}$拼接，生成组合消息$m' = m || \text{sig}$
		- 生成随机对称密钥$K_S$
		- 用$K_S$加密组合消息，生成密文$c = K_S(m')$
		- 用接收方的公钥$K_B^+$加密对称密钥，生成加密后的密钥$c_K = K_B^+(K_S)$
		- 发送方发送密文-签名-密钥三元组$(c, \text{sig}, c_K)$
	- 接收方：
		- 使用私钥$K_B^-$解密加密后的密钥，恢复对称密钥$K_S = K_B^-(c_K)$
		- 使用对称密钥$K_S$解密密文，恢复组合消息$m' = K_S(c)$
		- 将组合消息拆分为邮件内容$m$和签名$\text{sig}$
		- 对收到的$m$计算哈希值$H'(m)$
		- 用公钥$K_A^+$解密签名，恢复哈希值$H = K_A^+(\text{sig})$
		- 比较$H'(m)$和$H$，验证邮件的完整性和发送方身份
	- 示意图：![[Pasted image 20251203214050.png]]接收方逆序恢复即可
# 安全TCP连接：SSL
- 概述：
	- SSL（Secure Sockets Layer，安全套接字层）协议用于在TCP连接上提供安全通信
	- 经过多次迭代发展，修改后的协议称为TLS（Transport Layer Security，传输层安全性），已被标准化
		- 已有标准化的API以及标准化的库用于SSL层![[Pasted image 20251210155713.png]]
	- 目标：确保数据传输的机密性、完整性和认证
	- 网站中常有的“不安全”标识，表明该网站未使用SSL/TLS协议进行加密通信
## 简化SSL(Toy SSL)
- 分为握手阶段、密钥导出阶段、数据传输阶段和连接关闭阶段
1. 握手阶段（Handshake）：
	- 目标：协商加密算法和认证信息
	- 流程：
		1. 发送方和接收方之间先[[S3 运输层#^627550|建立TCP连接]]
		2. 发送方向接收方发送SSL的hello报文，接收方接收后，返回包含证书的响应报文
			- 由于证书都经由可信的CA签发，因此接收方可以通过证书验证发送方的身份
		3. 发送方产生一个**仅用于当前会话**的主密钥（MS），并使用**接收方的公钥**对主密钥进行加密，发送给接收方
	- 示意图：![[Pasted image 20251210160712.png]]
2. 密钥导出阶段（Key Derivation）：
	- 目标：生成安全性更好的会话密钥
	- 流程：使用MS生成4个密钥
		1. $K_c$：发送端到接收端的加密密钥
		2. $M_c$：发送端到接收端的消息认证码（MAC）密钥
		3. $K_s$：接收端到发送端的加密密钥
		4. $M_s$：接收端到发送端的消息认证码（MAC）密钥
	- 方法：通过密钥衍生函数（PDF），以主密钥+随机数据的方式生成上述4个密钥
3. 数据传输阶段（Data Transfer）：
	- 目标：使用协商好的密钥进行加密通信
	- 流式加密：在所有数据传输完成后，在数据末尾附加消息验证码MAC，验证数据完整性
		- 问题：需要等待数据传输完成后才能计算MAC，增加延迟
	- 分块传输：
		- SSL层将数据拆分为记录（Record），每个记录都是由数据长度+数据内容+MAC组成的![[Pasted image 20251210161416.png]]
		- 接收方可以在接收到一个记录后，立即验证MAC，确保数据完整性
	- 防重放/重排序攻击：
		- 由于TCP报文段的头中含有序号字段，这一字段是未被加密的，如果由攻击者截获报文段，可以通过重放或重排序攻击影响数据传输
		- 解决方案：对SSL层的记录，也添加一个SSL序号字段，并将其纳入MAC计算，确保记录的顺序和唯一性$$\text{MAC} = H_\text{MAC}(M_x ,\text{sequence}||\text{data})$$
		- 重放攻击：引入序号后难以解决重放攻击，可以使用随机数的方式
	- 防截断攻击：
		- 攻击者还可以伪造连接关闭报文，从而使得通信方误以为连接已经关闭
		- 解决方案：向记录中增加类型字段，0表示数据记录，1表示连接关闭记录，并将类型字段纳入MAC计算$$\text{MAC} = H_\text{MAC}(M_x ,\text{type}||\text{sequence}||\text{data})$$
		- 记录格式：![[Pasted image 20251210163117.png]]
- 完整流程：
	- ![[Pasted image 20251210163136.png]]
	- 问题：字段长度、加密协议等细节以及加密算法都没有说明
## 标准SSL/TLS
* 算法体系：
	* 对称加密算法：DES（早期块加密算法）、3DES、RC2、RC4（流加密算法，因安全性问题逐渐被淘汰）、AES（现行标准）
	* 公私钥算法：RSA（最常用）、Diffie-Hellman（用于密钥交换）
* 实际SSL的握手流程：
	* 目的：进行身份认证，协商加密算法、建立会话密钥
	* 流程：
		1. 客户端发送支持的算法列表和客户端随机数（nonce）
		2. 服务器返回选定的算法、服务器随机数和服务器证书
		3. 客户端验证证书真实性$\rightarrow$提取服务器公钥$\rightarrow$生成预主密钥$\rightarrow$使用服务器公钥加密预主密钥，发送给服务器
		4. 密钥生成：客户端和服务器使用相同的预主密钥和双方的随机数，独立计算双方的加密密钥和MAC密钥
		5. 客户端发送所有握手消息的MAC值，交由服务器验证
		6. 服务器发送所有握手消息的MAC值，交由客户端验证
	- 防止中间人攻击：第5、6两步防止中间人篡改握手消息中的算法选择部分，使得通信双方可以使用合适的强加密算法
	- 防止重放攻击：双方使用随机数，确保每次握手生成的密钥都是唯一的，无法重放旧记录进行攻击
	- 示意图：![[Pasted image 20251210164043.png]]
- 实际SSL的密钥导出阶段：
	- 生成主密钥：使用客户端随机数+服务器随机数+预主密钥，通过伪随机函数生成主密钥
	- 生成密钥块：使用主密钥和新的随机数，通过另一随机数生成器得到密钥块
	- 拆分密钥块得到六个密钥，包括：
		- 客户端MAC密钥$M_c$
		- 服务器MAC密钥$M_s$
		- 客户端加密密钥$K_c$
		- 服务器加密密钥$K_s$
		- 客户端初始化向量$\text{IV}_c$
		- 服务器初始化向量$\text{IV}_s$
- SSL记录协议：
	- 数据处理过程：
		1. 分片：将数据拆分成最大16KB的记录
		2. 附加MAC：计算记录的MAC，并附加在记录末尾
		3. 加密：使用协商好的对称加密算法和密钥，对记录进行加密
		4. 添加头部：在加密后的记录前添加SSL头部，包括记录类型、版本号和长度
		- 示意图：![[Pasted image 20251210164222.png]]
	- 记录格式：![[Pasted image 20251210164246.png]]
- SSL连接流程：![[Pasted image 20251210164605.png]]
	- 握手阶段：发送`ClientHello`和`ServerHello`，协商加密算法和认证信息；`ServerHelloDone`表示服务器握手结束，`ClientKeyExchange`发送预主密钥
	- `ChangeCipherSpec`表示后续消息将使用协商好的加密算法和密钥进行加密，此后信息都是强加密的消息
	- `Finished`消息之后，表示握手阶段结束，进入数据传输阶段
	- 连接关闭阶段：通过发送`CloseNotify`消息，通知对方连接即将关闭，之后使用TCP连接关闭机制断开连接
# 网络层安全性：IPsec
- 概述：
	- 网络层的安全协议（IPsec，Internet Protocol Security）用于在IP层提供安全通信
		- 保护各类加密消息（TCP/UDP段，ICMP消息等）的传输
		- 隐藏端到端的数据，防止被窥探和篡改
	- 伴随IPv6被制定，后续增加对IPv4的支持
- 应用：虚拟专用网络（Virtual Private Network, VPN）
	- 传统私网需要独立布置路由器、链路等，成本高
	- 使用VPN后，在公网上建立加密隧道，模拟私网通信，降低成本
	- 示意图：![[Pasted image 20251210170109.png]]
- IPsec服务原理：
	- 服务内容：保证网络层数据的完整性、源认证、机密性以及抗重放攻击
	- 工作模式：
		1. 传输模式（Transport Mode）：
			- 特点：IPsec数据包由终端系统（如主机）直接发送和接受
			- 作用：保护上层协议的数据
			- 场景：P2P通信且终端设备支持IPsec
			- 示意图：![[Pasted image 20251210170409.png]]
		2. 隧道模式（Tunnel Mode）：
			- 特点：IPsec数据包由网关设备（如路由器、防火墙）发送和接受
			- 作用：使用新的数据报封装数据，通过虚拟隧道传输，隐藏内部网络结构
			- 示意图：![[Pasted image 20251210170533.png]]![[Pasted image 20251210170536.png]]
	- 协议依赖：
		- AH协议（Authentication Header，头部认证协议）：提供数据完整性和源认证
		- ESP协议（Encapsulating Security Payload，封装安全载荷协议）：提供数据机密性、完整性和源认证
	- 实际应用：两种模式和两种协议可以两两组合，其中ESP协议和隧道模式的组合最为常用![[Pasted image 20251210170710.png]]
# 运行安全性：防火墙与IDS
- 防火墙（Firewall）：
	- 定义：位于内部网络和外部网络之间的安全屏障，监控和控制进出网络的数据流
		- ![[Pasted image 20251210171129.png]]
	- 功能：
		- 防止拒绝服务攻击（如SYN洪泛攻击）
		- 防止内部数据被非法修改和访问
		- 对用户进行识别，仅允许授权用户访问网络资源
	- 类型：
		- 无状态包过滤（Stateless Packet Filtering）
			- 原理：基于IP/TCP/UDP的报文头部字段（源/目的IP，端口、ICMP类型、TCP标志位等）进行过滤，阻断不符合规则的数据包
				- 例：阻断UDP/端口23的包以禁止Telnet访问
				- 例：阻断入站TCP SYN=0的包，防止外部发起的SYN洪泛攻击
				- 例：![[Pasted image 20251210171606.png]]
			- **ACL**表（Access Control List，访问控制列表）：定义允许或拒绝的数据包规则集合
				- 例：![[Pasted image 20251210171719.png]]
			- 特点：简单高效，但无法识别无意义的包
		- 有状态包过滤（Stateful Packet Filtering）
			- 原理：在无状态的基础上，跟踪TCP连接的全生命周期，超时后关闭连接状态
			- 规则增强：在ACL中增加连接状态检查，仅允许和已建立连接匹配的数据包![[Pasted image 20251210171853.png]]
			- 特点：可以识别无意义的数据包，提高安全性
		- 应用网关（Application Gateways）
			- 原理：基于应用层数据和IP/TCP/UDP头部信息进行过滤，需要为特定的应用部署专用的网关
				- 例：Telnet网关
					- 内部用户通过Telnet客户端连接到网关
					- 网关验证用户身份后，建立到外部Telnet服务器的连接
					- 路由器过滤掉所有非网关发起的Telnet连接请求
					- ![[Pasted image 20251210172046.png]]
			- 特点：可以深入检查应用层数据，提高安全性，但为每个应用部署网关是复杂且低效的
	- 局限性：
		- 无法抵御IP哄骗（无法验证数据真实的来源）
		- 应用网关需要为每个应用部署专用网关，复杂且低效
		- 客户端需要配置代理服务器，增加复杂性
		- UDP过滤策略过于宽松，难以精确控制哪些是真正需要被过滤的数据
		- 安全性和对外通信的便利性难以兼顾
- 入侵检测系统（Intrusion Detection System, IDS）：
	- 防火墙仅针对单一会话的头部信息进行过滤，无法检测复杂的攻击行为
	- 深度包检测：IDS会深入包的内容，检查是否存在攻击特征从而识别入侵行为
	- 分析数据包关联性：IDS会分析多个数据包之间的关联性，识别复杂的攻击模式（包括端口扫描攻击和DoS攻击等）
	- 部署位置：部署在公网和内部网络之间，以及隔离区和内部网络之间，监控进出网络的流量，且常常由多个组件组成，形成多层防护的体系![[Pasted image 20251210172809.png]]