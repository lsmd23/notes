# 运输层服务
 - 运输服务与协议：在不同主机的进程间提供逻辑通信
	 - 在发送端，运输层从应用层接收数据，划**分为适当大小的段**，添加运输层头部信息，并将其传递给网络层
	 - 在接收端，运输层从网络层接收段，移除运输层头部信息，并将**数据重新组装**后传递给应用层
> 不同层所用的数据的基本单位：![[Pasted image 20251016182151.png]]
- 传输层与网络层的关系：
	- 网络层：主机之间的通信
	- 运输层：主机内进程之间的通信
- 传输层协议：主要有TCP和UDP
	- **TCP**（传输控制协议）：面向连接，可靠传输，提供流量控制和拥塞控制
	- **UDP**（用户数据报协议）：无连接，不可靠传输，适用于实时应用和简单请求响应应用
# 多路复用与多路分解
- 运输层和应用层之间的接口，用于解决多个应用进程之间的数据传输问题
- 概念：
	- **多路复用**（Multiplexing）：在发送端，将来自多个应用进程的数据流合并为一个数据流，传递给运输层
	- **多路分解**（Demultiplexing）：在接收端，将运输层接收到的数据流分解为多个数据流，传递给相应的应用进程
- 工作原理：
	- 对一个套接字，无论它是UDP的还是TCP的，都由**四元组（源IP地址、源端口号、目的IP地址、目的端口号）唯一标识**
	- 运输层通过检查数据报或段的头部信息中的这些字段，确定数据应该发送到哪个应用进程
	- 同时，由于有标识的存在，即使定位到同一主机上的多个进程，运输层也能正确地将数据传递给相应的进程；即使定位到相同进程，运输层也能区分不同的连接
	1. 无连接的UDP多路分解：
		- UDP数据报包含源IP地址、源端口号、目的IP地址、目的端口号
		- 运输层根据这四个字段，将数据报直接传递给对应的应用进程 
	2. 面向连接的TCP多路分解：
		- TCP段包含源IP地址、源端口号、目的IP地址、目的端口号
		- 当TCP的欢迎套接字收到一个连接请求时，会为该连接创建一个新的TCP套接字
		- 之后，在新的TCP套接字上进行数据传输，运输层根据四元组将数据传递给对应的连接
	- Web服务器上的多路分解：多线程服务器
		- 当Web服务器收到来自不同客户端的HTTP请求时，运输层会根据四元组将请求分发给不同的**线程**进行处理，但都共用同一个进程，也即同一个**欢迎套接字**
		- 每个线程处理一个客户端的请求，并通过相应的TCP连接与客户端通信，也即构建不同的TCP套接字
# UDP协议
- UDP（用户数据报协议，User Datagram Protocol）：一种无连接、不可靠的运输层协议
	- 最为基础的协议，提供了运输层的最少的服务
	- 是无连接的，经常用于实时应用和简单请求响应应用
	- 常用的DNS协议和SMTP协议都基于UDP实现的
- UDP报文的格式：
	- 如图：![[Pasted image 20251018204451.png]]
		- 头部字段说明：
			- **源端口号**（Source Port）：16位，标识发送端应用进程的端口号
			- **目的端口号**（Destination Port）：16位，标识接收端应用进程的端口号
			- **长度**（Length）：16位，表示UDP报文的总长度，包括头部和数据部分
			- **校验和**（Checksum）：16位，用于检测报文在传输过程中是否发生错误
	- UDP校验和：
		- 用于检测UDP报文在传输过程中是否发生错误
		- 原理：将UDP报文的头部和数据部分按16位字进行**反码求和**，然后对结果取反得到校验和
		- 例：
			- 假设UDP报文的头部和数据部分按16位字表示为：`0101010101010101`、`0011001100110011`、`1111000011110000`
			- 计算反码和：
				1. 将三个16位字相加：`0101010101010101 + 0011001100110011 + 1111000011110000 = 0011100011101000`
					- 校验和对进位的做法是将进位加到结果的最低位，也即**回卷**
				2. 对结果取反得到校验和：`1100011100010111`
			- 接收端收到UDP报文后，进行相同的计算，并将结果与校验和进行比较，如果不匹配，则说明报文在传输过程中发生了错误
# 可靠数据传输(RDT)
- 运输层是建立在不可靠的网络层之上的，因此需要提供可靠的数据传输服务
	- TCP就依赖于可靠数据传输机制来实现可靠的通信
- 基础RDT：
	- `rdt_send()`接口：应用层调用该接口将数据发送给运输层
	- `rdt_rcv()`接口：运输层调用该接口从网络层接受数据
	- `udt_send()`接口：运输层调用该接口将数据发送给网络层
	- `deliver_data()`接口：运输层调用该接口将数据传递给应用层
	- 对发送方和接收方，使用**有限状态机**(FSM)来描述RDT的行为（参考[[L1 确定有限自动机(DFA)|确定有限自动机]]和[[L2 非确定有限自动机(NFA)|非确定有限自动机]]章节）
- RDT 1.0：**可靠信道**上的可靠传输
	- 假设信道是可靠的，即数据在传输过程中不会丢失、损坏或乱序
	- 发送方：直接将数据传递给网络层
	- 接收方：直接将数据传递给应用层
	- FSM模型：![[Pasted image 20251018210127.png]]
	- 问题：
		- 该版本假设信道是可靠的，实际中很少存在完全可靠的信道
		- 无法处理数据丢失、损坏或乱序等问题
- RDT 2.0：在**有比特错误的信道**上实现可靠传输
	- 假设信道可能会发生比特错误，但不会丢失数据
	- 接收方：使用答复，确认回答（ACK）和否定回答（NAK）来通知发送方数据是否正确接收
	- 发送方：根据接收方的答复，决定是否重传数据
	- FSM模型：![[Pasted image 20251018210319.png]]
	- 问题：
		- NAK可能会丢失或损坏，导致发送方无法正确判断数据是否需要重传
		- 依然无法处理数据丢失的问题
- RDT 2.1：改进的可靠传输协议
	- 解决RDT 2.0中NAK丢失或损坏的问题
	- 发送方：使用**序列号**来区分不同的数据包，当NAK或ACK损坏时，直接重传数据包
	- 接收方：使用序列号来判断数据包是否为重复数据包，丢弃重复数据包
	- FSM模型：
		- 对发送方：![[Pasted image 20251018210610.png]]
		- 对接收方：![[Pasted image 20251018210630.png]]
	- 问题：接收方无法知道自己的NAK或ACK是否被正确接收
- RDT 2.2：使用ACK确认的可靠传输协议
	- 无需使用NAK，全部使用ACK来确认数据包是否正确接收
	- 接收方：使用序列号来区分不同的数据包，在ACK中包含序列号
	- 发送方：根据接收方的ACK和对应的序列号，决定是否重传数据包
	- FSM模型：![[Pasted image 20251018210847.png]]
- RDT 3.0：在**有比特错误和数据丢失的信道**上实现可靠传输
	- 假设信道可能会发生比特错误和数据丢失
	- 发送方：使用**计时器**来检测数据包是否丢失，超时后重传数据包
	- 接收方：与RDT 2.2相同，使用ACK来确认数据包是否正确接收
	- FSM模型：发送方![[Pasted image 20251018210933.png]]
	- 运行流程：
		- 无损失丢包：![[Pasted image 20251018211019.png]]
		- 丢包：![[Pasted image 20251018211028.png]]
		- 回答损坏：![[Pasted image 20251018211048.png]]
		- 等待超时：![[Pasted image 20251018211103.png]]
- 流水线协议：
	- RDT使用**停等协议**进行工作，如果待传的数据很小而传输用时很长，则**利用率极低**，实际传输速率远低于信道容量
	- **回退N协议**（Go-Back-N, **GBN**）：一种基于滑动窗口的流水线协议
		- 使用一个长度为N的窗口，用于同时处理大量的数据包![[Pasted image 20251018212613.png]]
		- 发送方：允许发送多个数据包而无需等待ACK，但最多只能发送N个未确认的数据包
		- 接收方：只接受按顺序到达的数据包，丢弃乱序到达的数据包，在ACK中，只回复最后一个按顺序接收的数据包的序列号
		- FSM模型：扩展的状态机：![[Pasted image 20251018212459.png]]
			- 上层调用：必须确保发送窗口未满，也即`nextseqnum < sendbase + N`
			- 收到ACK：采用累积确认，收到序号为`acknum`的ACK后，证明所有序号小于等于`acknum`的数据包均已被正确接收
			- 计时器超时：当某个序号的数据包超时未收到ACK时，**重传该数据包及其之后的所有**未确认数据包
		- 工作流程：![[Pasted image 20251018212751.png]]
		- 问题：有大量的无需要的重传，浪费带宽资源
	- 选择重传协议（Selective Repeat, **SR**）：另一种基于滑动窗口的流水线协议
		- 发送方和接收方各维护各自的窗口，接收方会**缓存已接受但失序的分组**，直到可以按序交付给上层![[Pasted image 20251018213125.png]]
		- 发送方：
			1. 从上层接受数据后，检查发送窗口是否已满，若未满，则发送数据包，并启动计时器
			2. 每个分组的计时器独立运行，超时后仅重传该分组
			3. 收到ACK后，仅将对应的数据包标记为已确认。如果序号等于`sendbase`，则移动发送窗口
		-  接收方：
			1. 序号在`[rcvbase, rcvbase + N - 1`范围内的数据包被接受并缓存。如果序号等于`rcvbase`，则交付从此开始的连续数据包给上层，并移动接收窗口
			2. 序号在`[rcvbase - N, rcvbase - 1`范围内的数据包被接受，但不交付给上层，发送ACK
			3. 序号不在上述范围内的数据包被丢弃
		- 工作流程：![[Pasted image 20251018213548.png]]
		- 优点：减少了无需要的重传，提高了带宽利用率
# TCP协议
- TCP（传输控制协议，Transmission Control Protocol）：一种面向连接、可靠的运输层协议
	- **点对点**：每个TCP连接仅在两个端点之间建立
	- **可靠传输**：通过序列号、确认号、重传机制等确保数据可靠传输
	- **全双工数据**（Full-Duplex Data）：允许双方同时发送和接收数据
	- **流水线式**且拥有**拥塞控制**和**流量控制**机制
	- **握手式连接**：通过三次握手建立连接，四次挥手断开连接
## TCP报文格式
- 报文结构：![[Pasted image 20251022131215.png]]
	- 说明：
		- **源端口号**、**目的端口号**、**检验和**：与UDP类似
		- 32位的**序列号**（Sequence Number Field）字段和32位的**确认号**（Acknowledgment Number Field）字段：用于实现可靠传输
		- 16位的**接收窗口**（Window Size Field）字段：用于流量控制，表示接收方的缓冲区大小
		- 4位的**首部长度**（Header Length Field）字段：表示TCP头部的长度，以32位字为单位，是可变的
		- **选项字段**（Options Field）：用于扩展TCP功能，如时间戳、窗口扩大因子等，可选且变长
		- **标志位**（Flags Field）：包含6个控制位，分别是URG、ACK、PSH、RST、SYN和FIN，用于控制连接的建立、数据传输和连接的终止
- 序列号和确认号：
	- 序列号：用于标识发送的数据字节流中的每个字节，发送方为每个数据包分配一个序列号
	- 确认号：也即[[S3 运输层#可靠数据传输(RDT)|上一节]]中的ACK，表示接收方期望收到的下一个字节的序列号，发送方采用累积确认的方式确保数据可靠传输
- 往返时间的估计与超时：
	- 超时间隔：必须长于往返时间，以避免过早重传；但也不能过长，以免延迟过高
	- 估计往返时间（EstimatedRTT）：使用指数加权移动平均（EWMA）方法，根据最近的样本RTT计算：$$\text{EstimatedRTT} = (1 - \alpha) \times \text{EstimatedRTT} + \alpha \times \text{SampleRTT}$$推荐的$α$值为0.125，值越大表示对最新样本RTT的权重越大
		- 示意图：![[Pasted image 20251022132335.png]]
	- 往返时间偏差（DevRTT）：用于衡量SampleRTT的变化，计算公式为：$$\text{DevRTT} = (1 - \beta) \times \text{DevRTT} + \beta \times |\text{SampleRTT} - \text{EstimatedRTT}|$$推荐的$β$值为0.25，表示对最新偏差的权重
	- 一般设置超时间隔为：$$\text{TimeoutInterval} = \text{EstimatedRTT} + 4 \times \text{DevRTT}$$
## TCP可靠数据传输
- TCP建立在不可靠的网络IP之上，需要借助[[S3 运输层#可靠数据传输(RDT)|上一节]]的可靠数据传输机制来实现可靠通信
	- TCP协议会先将连续的字节流划分为适当大小的数据段，并为每个数据段分配一个序列号，也即数据包
	- 之后，利用流水线机制发送数据段，并通过确认号和重传机制确保数据可靠传输
	- 超时：TCP协议不对每个数据段维护定时器，而是使用一个**单一的定时器**来管理所有未确认的数据段，可以减少资源消耗
- 传输流程：
	- 简化的TCP发送方：![[Pasted image 20251022151555.png]]
	- 实例：![[Pasted image 20251022151952.png]]![[Pasted image 20251022151959.png]]
		- 对ACK丢包的数据，发送方会在超时后重传数据段
		- 对ACK未丢包但传输时延长于超时间隔的数据，发送方会重传没有必要的一些数据，但在接受ACK后会继续传输后续数据
		- 对传输时延短于超时间隔的数据，发送方不会重传数据，直接等待ACK
	- 快速重传机制：
		- 问题：超时触发重传机制往往受制于超时间隔的设置，可能会导致不必要的延迟；同时会有冗余ACK带来的不必要响应
		- 更合理的ACK响应方法：被应用于RFC 2581中![[Pasted image 20251022152341.png]]
		- 快速重传算法：![[Pasted image 20251022152424.png]]
			- 当发送方**连续收到3个相同的ACK时**，认为对应的数据段可能丢失，立即重传该数据段，而无需等待超时
			- 减少重传延迟，提高传输效率
## TCP流量控制
- 在TCP的接收端，存在一个缓冲区，用于存储接收到但尚未被应用层读取的数据
	- 如果发送端发送数据过快，可能会导致接收端的缓冲区溢出，进而丢失数据
	- 因此，TCP协议引入了流量控制机制，确保发送端不会超过接收端的处理能力
- 流量控制机制：
	- 接收窗口（Receiver Window, **rwnd**）：TCP头部的窗口大小字段，表示接收端的可用缓冲区大小
	- 发送方在发送数据时，会**根据接收方的rwnd值来调整发送速率**，确保不会超过接收方的处理能力
## TCP连接管理
- TCP连接的建立：**三次握手**（Three-Way Handshake）
	1. 客户端发送一个SYN报文段，表示请求建立连接，并选择初始序列号`x`
	2. 服务器收到SYN报文段后，回复一个SYN-ACK报文段，表示同意建立连接，并选择初始序列号`y`，确认号为`x+1`
	3. 客户端收到SYN-ACK报文段后，回复一个ACK报文段，确认号为`y+1`，连接建立完成
	- 示意图：![[Pasted image 20251022152914.png]]
- TCP连接的终止：**四次挥手**（Four-Way Handshake）
	1. 客户端主动关闭连接，发送一个FIN报文段，表示没有数据要发送了
	2. 服务器收到FIN报文段后，回复一个ACK报文段，确认号为`u+1`
	3. 服务器准备关闭连接，发送一个FIN报文段，表示没有数据要发送了
	4. 客户端收到FIN报文段后，回复一个ACK报文段，确认号为`v+1`，之后，进入超时等待状态，等待足够的时间以确保服务器收到ACK报文段后，关闭连接
	5. 服务器收到ACK报文段后，关闭连接
	- 示意图：![[Pasted image 20251022153207.png]]
- 周期状态图：![[Pasted image 20251022153228.png]]
# 拥塞控制原理
- 拥塞：网络中数据包的数量超过了网络的处理能力，导致网络性能下降
	- 拥塞可能导致数据包丢失、延迟增加和吞吐量降低
	- 流控制是处理传输层上应用层的接收速率和发送速率之间的关系，而拥塞控制是处理网络层中数据包的发送速率和网络容量之间的关系
		- 场景1：两个发送方共享同一无限大缓存的路由器。但输出链路的最大带宽有限，则显然最大速率只有这一最大带宽值的一半
		- 场景2：两个发送方共享同一有限大缓存的路由器。如果发送速率过高，则路由器缓存会溢出，导致数据包丢失，进一步引起的重传则会导致不必要的数据进入传输链路，从而加剧拥塞
		- 场景3：四个发送方共享多台路由器和多跳路径。复杂的路径会导致复杂的数据传输，拥塞情况更加难以处理
- 拥塞控制方法：
	- **端到端拥塞控制**：发送方根据**网络反馈信息**（如丢包、延迟等）来**调整**发送速率
	- **网络辅助拥塞控制**：**网络设备**（如路由器）提供**显式的拥塞通知**，帮助发送方调整发送速率
	- 例： ATM体系的可用比特率（Available Bit Rate, ABR）拥塞控制
		- 路由器通知其在输出链路上的最大主机发送速率
		- 发送方根据路由器的通知调整发送速率
# TCP拥塞控制
- TCP使用端到端的拥塞控制机制
- 控制方法：
	- 发送方类似流量控制的rwnd，维护一个**拥塞窗口**（Congestion Window, **cwnd**），表示发送方当前允许发送的最大数据量
	- **加性增、乘性减**（Additive Increase Multiplicative Decrease, **AIMD**）算法：当网络状况良好时，按照线性的方式增加cwnd；当发生拥塞时，按照指数的方式减少cwnd
		- 示意图：![[Pasted image 20251022155447.png]]
- TCP拥塞控制算法：
	1. **慢启动**（Slow Start）阶段：
		- 初始时，cwnd设置为一个较小的值（通常为1个MSS）
		- 每收到一个ACK，cwnd增加1个MSS，即每经过一个往返时间RTT，cwnd翻倍增长
		- 在这一阶段，cwnd为指数增长