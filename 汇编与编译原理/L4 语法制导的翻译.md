# 语义处理概述
- 语义处理在语法分析之后进行：
	- 静态语义分析：类型检查、作用域检查等
	- 中间/目标代码生成：从语义分析的结果生成中间代码或目标代码
- 语义处理技术：语法制导的语义处理，应用基本的语法制导定义
# 语法制导定义(SDD)
- **属性文法**：在上下文无关文法的基础上，为每个文法符号和产生式定义属性和语义规则
	- **属性**：刻画文法符号的某些语义信息，例如符号值、类型、存储地址等。符号$X$的属性记为$X.a$，其中$a$是属性名
	- **语义规则**：每个产生式关联的计算属性值的规则，描述如何计算当前产生式中各个符号的属性值
		- 复写规则：类似赋值，例如$X.a := Y.b$
		- 基于语义函数的规则：例如$b:=f(c_1,c_2,\cdots,c_k)$或$f(c_1,c_2,\cdots,c_k)$，其中$f$是一个函数，$b,c_1,\cdots,c_k$是属性
	- **综合属性**：对关联于产生式$A\rightarrow \alpha$的语义规则$b:=f(c_1,c_2,\cdots,c_k)$，如果$b$是$A$的属性，则称$b$为$A$的一个综合属性 ^f3086b
		- 用于自下而上地传递信息
		- 例：![[Pasted image 20251111135522.png]]![[Pasted image 20251111135938.png]] ^0cb948
	- **继承属性**：对关联于产生式$A\rightarrow \alpha$的语义规则$b:=f(c_1,c_2,\cdots,c_k)$，如果$b$是$\alpha$中某个符号的属性，则称$b$为该符号的一个继承属性
		- 用于自上而下地传递信息
		- 例：![[Pasted image 20251111140050.png]]![[Pasted image 20251111140100.png]]
# 基于SDD的语义处理
- 也即语法制导的语义处理，也称语法制导的翻译
- 基于树遍历的语义处理：
	- 步骤：
		1. 构造输入串的语法树
		2. 构造**依赖图**
		3. 若该依赖图无环，则按依赖图的一个拓扑排序顺序计算属性值；若有环，则这类SDD不是良定义的SDD
			- **良定义SDD**：对于该语义，当且仅当其规则集合能为分析树的属性集确定唯一的值
	- 依赖图的构造：
		- 算法：![[Pasted image 20251111140708.png]]
	- 例：
		- 对如下的SDD：![[Pasted image 20251111140754.png]]输入串"10.01"
		- 构造语法树：![[Pasted image 20251111140818.png]]
		- 为每个属性编号，建立为依赖图的节点：![[Pasted image 20251111141114.png]]
		- 根据依赖规则，划定依赖边，得到依赖图：![[Pasted image 20251111141131.png]]
		- 根据依赖图的拓扑排序，计算属性值：![[Pasted image 20251111141302.png]]
		- **带标注的语法树**：对各属性的计算也即对语法树的标注，例如：![[Pasted image 20251111141406.png]]
- 基于单遍历的语义处理：在语法分析同时做语义处理
	- 分为自下而上和自上而下两种方法
	- **S-属性SDD**：只含综合属性的SDD
		- 可用自下而上的方法分析时处理
		- 方法：扩充LR分析的分析栈，新增存放属性的栈，在每次规约之前计算属性值并压入栈中。计算时，新的属性由栈顶的属性值决定计算
			- 示意图：![[Pasted image 20251111152923.png]]
			- 例：对前述的[[L4 语法制导的翻译#^0cb948|综合属性SDD例]]：
				- 分析表：![[Pasted image 20251111153249.png]]
				- 语义分析：![[Pasted image 20251111153314.png]]
	- **L-属性SDD**：产生式右端文法符号的每个继承属性只能依赖于左侧的文法符号或产生式左端的文法符号的属性的SDD
		- 可用自上而下的方法在分析时处理
		- 深度优先后序遍历处理：
			- 算法描述：![[Pasted image 20251111153406.png]]
			- 基于LL(1)文法的L-属性SDD可以用上述方式进行语义处理
# 语法制导的翻译方案(SDT)
- 概念：
	- 在CFG的产生式体中，嵌入了对应的程序片段
	- 是语法制导语义处理的一种实现方式，体现一种合理调用语义规则的策略
	- 形式上与SDD类似，但语义规则集合可以出现在产生式右端的任何位置，可以显式地表达动作和属性计算的次序
	- 例：定点二进制小数转换为十进制小数的SDT![[Pasted image 20251111154049.png]] ^5f999b
- 设计约束：
	- 设计SDT时，需确保每个属性值在访问时已存在
	- 类似S-属性SDD，若仅需要综合属性，可以将语义规则集合放在产生式右端的末尾，将属性的计算规则加入其中
	- 类似L-属性SDD，若既需要综合属性又需要继承属性，则需注意：
		- 产生式右端符号的继承属性计算必须在符号之前
		- 每个规则不访问右边符号的综合属性
		- 产生式左端符号的综合属性计算必须在所使用的继承属性计算之后，通常也置于产生式右端的末尾
- SDT处理方法：
	- 基于自上而下的翻译：
		- 构造方案：
			- 对每个非终结符$A$，构造一个翻译子程序$A()$，以$A$的每个继承属性为形参，以$A$的综合属性为返回值
			- 该子程序的逻辑是：根据当前的输入符号，决定采用哪个产生式进行推导，依从左到右的次序处理产生式右端的每个符号和语义规则
				- 对终结符$x$，调用匹配终结符函数`match_token`，并继续输入
				- 对非终结符$B$，利用其继承属性值作为实参，调用翻译子程序$B()$，并接收其返回值作为$B$的综合属性值
				- 对语义规则集，直接复制每一个语义规则得到相应的代码，将对属性的访问替换为对相应变量的访问（调用实际参数或返回值）
		- 例：对前述的[[L4 语法制导的翻译#^5f999b|SDT例]]
			- 非终结符$N$构造如下的函数：![[Pasted image 20251111155014.png]]
			- 非终结符$S$构造如下的函数：![[Pasted image 20251111155026.png]]
			- 非终结符$B$构造如下的函数：!![[Pasted image 20251111155042.png]]
			- 在主程序中调用`S()`函数开始翻译即可
	- 基于自下而上的翻译：
		- 核心思路：
			- 基于S-属性SDD的分析技术，继续扩充分析栈
			- 对于约束问题，转化为L-属性SDD的自下而上处理
			- 关键动作：
				1. 去掉嵌在产生式中间的语义规则
					- 若规则集中未关联任何属性，引入非终结符$N$和产生式$N\rightarrow \epsilon$，将中间的规则替换为$N$，将语义规则集关联到该产生式后
					- 若规则集中关联属性，则引入非终结符$N$和产生式$N\rightarrow \epsilon$，将中间的规则替换为$N$将语义规则集关联到该产生式后，且需要在适当的地方增加复写规则
					- 例：![[Pasted image 20251111155633.png]]
				2. 分析栈中继承属性的访问：
					- 自下而上语义程序在产生式$A\rightarrow XY$的归约过程中，假设$X$的综合属性$X.s$已经在栈上
					- 则在继续分析的过程中，这一属性值可以通过栈访问
					- 对继承属性，可以通过综合属性复写的方式，模拟访问的过程
					- 例：![[Pasted image 20251111155940.png]]
				3. 继承属性的模拟求值：
					- 分析栈中继承属性的访问通过已有的综合属性值间接进行实现
					- 在设计SDT时，可以适度增加新的符号等，保证可以通过上述方式实现一个继承属性的求值
					- 例：![[Pasted image 20251111160136.png]]![[Pasted image 20251111160147.png]]
# 静态语义分析
- 静态语义分析：在编译时对程序进行语义检查，确保程序符合语言的语义规则
	- 类型检查：检查操作是否遵守语言的类型规则
	- 作用域检查：确保变量和函数在其定义的作用域内使用
	- 控制流分析：检查程序的控制流结构是否合理
	- 唯一性检查：确保标识符在其作用域内唯一
	- 命名相关检查：确保变量命名的依赖关系
- 实现方法：
	- 语法制导定义(SDD)：为语法符号和产生式定义属性和语义规则
	- 符号表管理：维护符号表以跟踪变量和函数的定义及其属性
	- 依赖图分析：构建依赖图以确保属性计算的正确顺序
---
[[L5 符号表与运行时存储组织]]