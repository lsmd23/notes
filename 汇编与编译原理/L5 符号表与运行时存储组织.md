# 符号表
- 作用：存放标识符的属性信息和作用域信息
	- 语义分析中，符号表登记的内容用于语义检查和产生中间代码
	- 目标代码生成中，符号表登记的内容用于分配存储单元和生成目标代码
- 属性：
	- 标识符的名字
	- 标识符的类型
	- 标识符的存储类别
	- 标识符的作用域信息
	- 标识符的其他属性（如数组维数、函数参数类型等）
- 操作：
	- 创建符号表：编译开始时创建全局符号表
	- 插入表项：在语法分析过程中，遇到新的标识符时，将其属性信息插入符号表
	- 查找表项：在语义分析过程中，根据标识符名字查找其属性信息
	- 修改表项：在获得新的语义信息时，更新标识符的属性信息
	- 删除表项：在离开作用域时，删除相应的符号表项
	- 销毁符号表：编译结束时销毁符号表，释放内存
- **实现**：
	- 数据结构：一般线性表，有序表，哈希表，二叉树等
	- 关键字域组织：关键字池（一个大字符数组存放所有关键字）解决关键字长短不一导致的空间浪费
	- 其他字域组织：另开辟链表型的复合表，存放标识符的其他属性信息
	- 实例：![[Pasted image 20251125141421.png]]
# 运行时存储组织
- 目标：为程序运行时的各种数据分配存储空间，并管理这些空间的使用
- 数据表示：源程序中数据对象的表示形式
	- 对象的属性：类型，值，存储位置等
	- 表示形式：位模式，字节序等
	- 对齐方式：数据对象在内存中的对齐方式
	- 例：![[Pasted image 20251125143024.png]]
- 程序在存储器中的布局：内存中不同的部分存放不同类型的代码（例如[[L2.4 机器指令-高级#x86内存分配|x86-64的内存组织]]）
- 存储分配策略：
	- 静态存储分配：在编译期间分配存储，要求在编译期间就能确定数据对象的大小
		- 多数语言中只有部分存储采用静态分配，有些比较老的语言只使用静态分配
	- 动态存储分配：
		- 栈式存储分配：按照栈的形式分配存储的空间
			- 有效实现栈式的调用操作，支持递归的过程调用
		- 堆式存储分配：从堆空间动态分配存储空间
			- 方式：显式分配和隐式分配
			- 特点：保存了程序的局部性，使其可以复用已分配的存储空间
			- **堆空间管理**：
				- 分配算法：最佳适应算法（选择浪费最少的空闲块），首次适应算法（选择第一个能满足要求的空闲块），循环首次适应算法（类似首次适应，但从上次分配结束的位置继续查找）
				- 碎片整理：通过移动已分配的块来合并空闲块，减少碎片，提高内存利用率
- **活动记录**：管理过程调用时的存储空间，包括参数传递，局部变量存储，返回地址等（参考[[L2.3 机器指令-过程|x86-64中的过程调用实现]]）
	- 典型的记录形式：![[Pasted image 20251125145603.png]]
	- 嵌套过程语言的栈式分配：在支持嵌套的语言中，内层过程可以访问外层的变量，需要对内存进行特殊的组织解决这一问题
		- Display 寄存器表（**显示表**）方法：
			- 思路：用一组寄存器，记录各层当前的活动记录的基地址，从而定位每一个过程的位置
			- 例：![[Pasted image 20251125152942.png]]
			- 实现：
				- 对一个有$k$个调用过程的记录，当前过程的显示表项为$D[k]$，对应的，上一层的显示表项为$D[k-1]$，依此类推，`main`过程对应的显示表项为$D[0]$
				- 在调用时，维护全局的表项，当调用时（`call`指令等），从表的顶端记录n个SP值，再加上当前的SP值，形成新的显示表项
		- **静态链**方法：使用寄存器维护是高成本的储存方式，需要进行优化
			- 思路：在每个活动记录中，增加一个静态链域，直接指向定义该过程的外过程的最新活动记录；同时，需要一个动态链域，指向调用该过程的活动记录用于恢复栈指针
				- 静态链（Static Link）：指向定义该过程的外过程的最新活动记录，解决非局部变量访问
				- 动态链（Dynamic Link）：指向调用该过程的活动记录，用于恢复栈指针
			- 例：![[Pasted image 20251125153543.png]]				
- **垃圾回收**：收回不能被引用的数据和不再被访问的数据使用的存储空间
	- 垃圾的判断：
		- 可达性：指一个存储块是否可以被程序访问到
		- **根集**（Root Set）：无需解引用就能直接访问的数据集合
			- 全局变量（`static`变量等）
			- 当前活动的局部变量
			- 处理器寄存器中的变量引用
		- 可达性规则：
			- 根集中的存储块是可达的
			- 若一个对象的指针存储于可达对象的字段或元素中，则该对象也是可达的
			- 一旦对象被标记为不可达，则不可能再变为可达（不可逆）
		- 改变可达性的操作：
			- 对象分配：返回指向新存储块的引用
			- 传参/返回：对象的引用传递给函数参数或返回值
			- 引用赋值：将一个对象的引用赋值给另一个对象的字段或元素，被赋值中的引用会丢失，可能导致不可达
			- 过程返回：局部变量出栈，根集变小，可能导致不可达
	- 垃圾回收算法：
		- **基于引用计数的垃圾回收**：
			- 思路：为每个对象维护一个存放引用计数的字段，记录指向对象的引用数量；当引用计数归零时，该对象即为垃圾，可以被回收
			- 维护规则：
				- 对象分配：引用计数初始化为1
				- 参数传递：引用计数加1
				- 引用赋值：赋值对象的引用计数加1，被赋值对象的原引用对象的引用计数减1
				- 过程返回：局部变量的引用计数减1
			- 回收逻辑：当引用计数即将归零时，此对象中各个指针所指对象的引用计数也相应减1，递归进行，直至没有更多对象需要处理
			- 优点：实时回收，没有停顿
			- 问题：
				- 开销较大：每次引用变化都需要更新计数
				- 无法处理循环引用：循环引用的对象即使不可达，其引用计数也不会归零，导致内存泄漏
		- **基于跟踪的垃圾回收**：不实时回收垃圾，周期性运行跟踪标记并回收的流程
			1. 标记-清扫（Mark-and-Sweep）算法：先确定可达对象，再回收不可达对象
				- 算法流程：
					- 标记阶段：从根集开始，通过图遍历标记所有的可达对象
					- 清扫阶段：扫描堆中的所有对象，回收未被标记的对象
					- 示意：![[Pasted image 20251125155138.png]]
				- 例：![[Pasted image 20251125155103.png]]
				- 特点：实现简单，能处理循环，但是是异步进行的，可能导致**程序停顿**和内存碎片的产生
			2. 标记-压缩（Mark-and-Compact）算法：在标记阶段后，将所有可达对象移动到堆的一端，回收不可达对象
				- 算法流程：
					- 标记阶段：与标记-清扫相同
					- 压缩阶段：从堆的低端开始遍历，计算每个可达对象的新位置
					- 移动更新：将可达对象移动到新位置，并更新所有引用该对象的指针
					- 示意：![[Pasted image 20251125155309.png]]
				- 优点：减少内存碎片，提高内存利用率，但移动对象需要更新引用，开销更大
			3. 拷贝回收算法：
				- 将堆划分为两个半空间（Semispace）——`From`空间（用于对象分配）和`To`空间（初始为空）
				- 当`From`空间满时，进行垃圾回收：
					- 从根集开始，遍历所有可达对象，将它们复制到`To`空间，并更新所有引用
					- 交换`From`和`To`空间的角色
				- 优点：分配速度快，减少碎片
				- 缺点：需要双倍的内存空间，不适合大对象
			- 对比开销：
				- 标记-清扫式回收与堆中存储块数目成正比
				- 标记-压缩式回收与堆中存储块数目和可达对象总大小成正比
				- 拷贝回收与可达对象总大小成正比
			- 短停顿垃圾回收：
				- 分代垃圾回收：
					- 原理：多数对象的生命周期较短，通过将对象按年龄划分为不同代，可以更频繁地回收年轻代的对象，减少整体的垃圾回收开销
					- Eden 代（新生代）：存放新分配的对象，垃圾回收频率高
					- S0 代：存放从 Eden 代晋升的对象（回收后存活的对象）
					- S1 代：存放从 S0 代晋升的对象（回收后存活的对象）
					- 示意图：![[Pasted image 20251202140844.png]]
---
[[L6 中间代码生成]]