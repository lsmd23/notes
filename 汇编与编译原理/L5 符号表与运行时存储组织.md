# 符号表
- 作用：存放标识符的属性信息和作用域信息
	- 语义分析中，符号表登记的内容用于语义检查和产生中间代码
	- 目标代码生成中，符号表登记的内容用于分配存储单元和生成目标代码
- 属性：
	- 标识符的名字
	- 标识符的类型
	- 标识符的存储类别
	- 标识符的作用域信息
	- 标识符的其他属性（如数组维数、函数参数类型等）
- 操作：
	- 创建符号表：编译开始时创建全局符号表
	- 插入表项：在语法分析过程中，遇到新的标识符时，将其属性信息插入符号表
	- 查找表项：在语义分析过程中，根据标识符名字查找其属性信息
	- 修改表项：在获得新的语义信息时，更新标识符的属性信息
	- 删除表项：在离开作用域时，删除相应的符号表项
	- 销毁符号表：编译结束时销毁符号表，释放内存
- **实现**：
	- 数据结构：一般线性表，有序表，哈希表，二叉树等
	- 关键字域组织：关键字池（一个大字符数组存放所有关键字）解决关键字长短不一导致的空间浪费
	- 其他字域组织：另开辟链表型的复合表，存放标识符的其他属性信息
	- 实例：![[Pasted image 20251125141421.png]]
# 运行时存储组织
- 目标：为程序运行时的各种数据分配存储空间，并管理这些空间的使用
- 数据表示：源程序中数据对象的表示形式
	- 对象的属性：类型，值，存储位置等
	- 表示形式：位模式，字节序等
	- 对齐方式：数据对象在内存中的对齐方式
	- 例：![[Pasted image 20251125143024.png]]
- 程序在存储器中的布局：内存中不同的部分存放不同类型的代码（例如[[L2.4 机器指令-高级#x86内存分配|x86-64的内存组织]]）
- 存储分配策略：
	- 静态存储分配：在编译期间分配存储，要求在编译期间就能确定数据对象的大小
		- 多数语言中只有部分存储采用静态分配，有些比较老的语言只使用静态分配
	- 动态存储分配：
		- 栈式存储分配：按照栈的形式分配存储的空间
			- 有效实现栈式的调用操作，支持递归的过程调用
		- 堆式存储分配：从堆空间动态分配存储空间
			- 方式：显式分配和隐式分配
			- 特点：保存了程序的局部性，使其可以复用已分配的存储空间
			- **堆空间管理**：
				- 分配算法：最佳适应算法（选择浪费最少的空闲块），首次适应算法（选择第一个能满足要求的空闲块），循环首次适应算法（类似首次适应，但从上次分配结束的位置继续查找）
				- 碎片整理：通过移动已分配的块来合并空闲块，减少碎片，提高内存利用率
- **活动记录**：管理过程调用时的存储空间，包括参数传递，局部变量存储，返回地址等（参考[[L2.3 机器指令-过程|x86-64中的过程调用实现]]）
	- 典型的记录形式：![[Pasted image 20251125145603.png]]
	- 嵌套过程语言的栈式分配：
- **垃圾回收**：