# 基本概念
- 汇编语言是连接硬件与高级编程语言的桥梁
	- 由指令、伪指令等构成
	- 需通过特定方法进行程序设计
	- 在实际场景中，汇编语言常用于底层编程、嵌入式系统开发等领域
- 虚拟机理论：
	- 每一台计算机直接执行的语言称为机器语言（L0语言），其是人类难以理解和使用的二进制代码
	- 在机器语言之上，可以设计一种更接近人类思维的低级语言，称为汇编语言（L1语言）
	- L1语言通过解释（逐条执行）或翻译（转换为机器语言后执行）的方式在机器上运行，二者之间是几乎一一对应的关系
- 数的表示和运算：参见[[L1.1 信息-整数的表示|计算机组成原理——整数的表示]]以及[[L1.2 信息-浮点数的表示|计算机组成原理——浮点数的表示]]
# x86处理器架构
- 基础处理器设计：参见计算机组成原理
	- [[L3.1 指令集架构|指令集架构]]
	- [[L3.2 电路逻辑设计|电路逻辑设计]]
	- [[L3.3 SEQ处理器设计|单周期顺序处理器设计]]
	- [[L3.4 流水线处理器设计|流水线处理器设计]]
- 32位x86处理器：
	- 操作模式：
		- 保护模式（Protected Mode）：为程序分配独立的地址空间，支持多任务和内存保护，是现代操作系统的基础
		- 实地址模式（Real-address Mode）：仅支持单任务可以访问全部内存的模式，用于早期操作系统
		- 系统管理模式（System Management Mode）：用于处理系统级任务，如电源管理和硬件控制
		- 虚拟8086模式（Virtual 8086 Mode）：在保护模式下模拟8086处理器的运行环境，允许运行16位实模式程序
	- 基本执行环境：
		- 内存寻址：保护模式下使用32位地址，支持4GB地址空间；实地址模式和虚拟8086模式下使用20位地址，支持1MB地址空间
		- 通用寄存器：
			- 32位通用寄存器：参见[[L2.1 机器指令-基础#^a82ee7|计算机组成原理——通用寄存器]]
			- 16位段寄存器：`CS`（代码段寄存器）、`DS`（数据段寄存器）、`SS`（堆栈段寄存器）、`ES`（附加段寄存器）、`FS`、`GS`，另有`EFLAGS`（标志寄存器）用于存储条件码和控制位，`EIP`（指令指针寄存器）用于存储下一条要执行的指令地址
			- 寄存器也可以用不同的标志进行部分访问，如`AX`表示`EAX`的低16位，`AL`表示`EAX`的低8位，`AH`表示`EAX`的高8位
		- 索引与基址寄存器：仅下半部分有部分访问
			- `SI`（源变址寄存器）：用于字符串和数组操作，指向源数据地址，为`ESI`的低16位
			- `DI`（目的变址寄存器）：用于字符串和数组操作，指向目的数据地址，为`EDI`的低16位
			- `BP`（基指针寄存器）：指向当前栈帧的基地址，为`EBP`的低16位
			- `SP`（堆栈指针寄存器）：指向当前栈顶，为`ESP`的低16位
		- 状态位：
			- 进位标志（Carry）：无符号算术运算超出范围时置位
			- 溢出标志（Overflow）：有符号算术运算超出范围时置位
			- 符号标志（Sign）：运算结果为负数时置位
			- 零标志（Zero）：运算结果为零时置位
			- 辅助进位标志（Auxiliary Carry）：从第 3 位向第 4 位有进位时置位
			- 奇偶标志（Parity）：运算结果中 1 的个数为偶数时置位
		- **浮点、MMX、XMM 寄存器**：
		    - 8 个 80 位浮点数据寄存器：ST (0)~ST (7)，按栈结构排列，用于所有浮点算术运算
		    - 8 个 64 位 MMX 寄存器
		    - 8 个 128 位 XMM 寄存器，用于单指令多数据（SIMD）操作
	- 寻址模式：
		- 实地址模式：20位地址，无限制，仅支持单任务
			- 段地址计算：物理地址 = 段寄存器值 × 16 + 偏移地址
		- 保护模式：32位地址，支持多任务和内存保护
			- 线性地址计算：线性地址 = 段选择子 × 4 + 偏移地址
			- 物理地址计算：通过分页机制将线性地址映射到物理地址
- 64位x86处理器（x86-64）：
	- 扩展的寄存器集：
		- 16 个 64 位通用寄存器：`RAX`、`RBX`、`RCX`、`RDX`、`RSI`、`RDI`、`RBP`、`RSP`、`R8`~`R15`
		- 每个寄存器都可以按不同大小访问，如 `EAX`（低 32 位）、`AX`（低 16 位）、`AL`（低 8 位）、`AH`（高 8 位）
	- 扩展的寻址模式：
		- 支持 64 位地址空间，允许直接访问更大的内存
		- 引入了 RIP 相对寻址模式，使得代码位置无关
	- 新增的指令集扩展：
		- SSE、AVX 等 SIMD 指令集扩展，用于加速多媒体和科学计算
		- 支持更高效的浮点运算和并行处理
# 汇编语言基础
- 标准程序模板：
```asm
; Program Template (Template.asm) 
.386 ; 指定使用80386处理器指令集 
.model flat,stdcall ; 定义内存模型为flat，调用约定为stdcall 
.stack 4096 ; 分配4096字节的栈空间 ExitProcess PROTO, dwExitCode:DWORD ; 声明ExitProcess函数原型 

.data ; 数据段，用于声明变量 
; declare variables here 

.code ; 代码段，用于编写程序指令 
main PROC ; 主过程开始 
; write your code here 
INVOKE ExitProcess,0 ; 调用ExitProcess函数，结束程序 
main ENDP ; 主过程结束 
; (insert additional procedures here) 
END main ; 指定程序入口为main过程
```
- 基本元素：
	- 整数：
		- 可带有前导的+或-号
		- 支持不同进制，16进制以`h`结尾（以字母开头需加前导0，如`0Ah`），10进制无后缀，8进制以`o`结尾，2进制以`b`结尾
	- 整数表达式：运算遵循对应的优先级规则
	- 字符与字符串：
		- 字符用单引号或双引号括起，占1字节
		- 字符串也用单引号或双引号括起，每个字符占1字节
		- 可以嵌入引号
	- 保留字与标识符：
		- 保留字：汇编语言中具有特殊含义的词汇（如指令、伪指令等），不能用作变量名或过程名
		- 标识符：用于命名变量、过程等，自定义名称，以字母、下划线、@、或\$开头，后续字符可以是字母、数字、下划线、@、\$，不区分大小写
	- 伪指令：
		- 用于指导汇编器如何处理代码和数据，不生成机器代码
		- 例子：`.data`、`.code`、`.model`、`.stack`等
	- 指令：
		- 汇编语言的核心，用于执行具体操作
		- 包括数据传输指令、算术运算指令、逻辑运算指令、控制转移指令等
		- 结构：\[标签:\] 操作码 操作数(s) ; 注释\]
	- 标签：
		- 用于标识代码或数据的位置
		- 以冒号结尾，可作为跳转目标或数据引用
	- 助记符和操作数：
		- 指令助记符：指令的名称，如`MOV`、`ADD`、`JMP`等
		- 操作数：指令作用的对象，可以是寄存器、内存地址、立即数等
	- 注释：
		- 用于解释代码，增强可读性
		- 以分号（`;`）开头，直到行尾
		- 多行注释以`COMMENT`和用户选择的字符为开头和结尾
- 示例代码：
```asm
TITLE Add and Subtract (AddSubAlt.asm) 
; This program adds and subtracts 32-bit integers. 
.386 
.MODEL flat,stdcall 
.STACK 4096 
ExitProcess PROTO, dwExitCode:DWORD 
DumpRegs PROTO 

.code 
main PROC 
mov eax,10000h ; EAX = 10000h（将10000h送入EAX寄存器） 
add eax,40000h ; EAX = 50000h（EAX寄存器值加40000h） 
sub eax,20000h ; EAX = 30000h（EAX寄存器值减20000h） 
call DumpRegs ; 调用DumpRegs函数显示寄存器状态 
INVOKE ExitProcess,0 ; 调用ExitProcess函数结束程序 
main ENDP 
END main
```