# 概述
- 代码生成依赖中间代码生成实际可执行的汇编代码
	- 汇编代码：参考[[L2.1 机器指令-基础|机器指令基础]]、[[L2.2 机器指令-控制|控制流机器指令]]、[[L2.3 机器指令-过程|过程调用机器指令]]
- 代码生成器的任务：
	- 指令选择：选择适当的机器指令来实现中间代码的操作
	- 寄存器分配：将变量分配到有限的寄存器中，以提高执行效率
	- 指令调度：重新安排指令顺序以减少流水线停顿和提高并行性
- 问题：若不加任何优化的直接由三地址码生成对应的目标代码，效率是及其低下的
	- 例：![[Pasted image 20251210191540.png]]
# 目标机模型
- 在确定代码生成策略前，需要定义目标机器的模型以便于代码生成器进行相应的优化
- 三地址机器模型：
	- 假定目标机器支持无限数量的寄存器，且支持所有三地址指令
	- 指令类型：
		- 变量加载：`LD dst, addr`，将内存地址`addr`处的值加载到寄存器`dst`
		- 变量保存：`ST x, reg`，将寄存器`reg`的值存储到内存地址`x`
		- 计算：`<OP> dst, src1, src2`，将`src1`和`src2`进行操作`OP`，结果存储到`dst`
		- 无条件跳转：`BR L`，跳转到标签`L`
		- 条件跳转：`Bcond reg, L`，根据寄存器`reg`的值进行条件跳转到标签`L` 
	- 寻址模式：
		- 常数：`#c`，表示常数`c`
		- 变量`x`：指向分配给`x`的内存地址（也即`x`的左值）
		- `*r`：表示寄存器`r`中存储的地址处的值
		- `const(r)`：表示地址`const + r`处的值
		- `a(r)`：表示地址`a + r`处的值
		- `*const(r)`：表示地址`const + r`处存储的地址指向的值
	- 目标代码示例：
		- 例1：![[Pasted image 20251210192350.png]]
		- 例2：![[Pasted image 20251210192357.png]]
	- 程序指令代价：
		- 包含最短编译时间、运行时间、目标程序大小和能耗等的指标
		- 代价计算假设：假设不同的指令有不同的代价，且每条指令的代价是独立的，计算为1加上运算分量寻址模式的代价
			- `LD R0, R1`的代价为1
			- `LD R0, M`的代价为2
			- `LD R0, *100(R1)`的代价为2
# 目标代码中的地址
- 在生成目标代码的过程中，需要合理的确定各个变量、指令等存储的地址，并对其进行管理
- 活动记录分配：
	- 静态分配：
		- 特点：为每个过程都静态地分配一个属于该过程的数据区域，每个过程的开始位置用属性`staticArea`表示
		- 调用返回实现：
			- 调用`callee`时，执行指令`ST callee.staticArea, #here + 20`（用于存放返回地址，+20表示下下一条指令的地址），再执行`BR callee.codeArea`进入`callee`的代码区域执行
			- 返回时，执行`BR *callee.staticArea`跳转回调用者的返回地址继续执行
			- 例：![[Pasted image 20251210193524.png]]调用过程在120处开始，先将140（也即下下一条指令地址）存入一个活动记录区，在被调用过程结束后，从这个活动区域取出返回地址继续执行
	- 栈式分配：
		- 特点：使用一个栈和对应的栈顶寄存器`SP`来动态地分配和释放活动记录
		- 调用返回实现：
			- `main`过程初始化栈区
			- 调用序列：
				1. `ADD SP, #caller.recordSize`：为调用者分配活动记录空间
				2. `ST 0(SP), #here + 16`：将返回地址存入栈顶
				3. `BR callee.codeArea`：跳转到被调用过程的代码区域
			- 返回序列：
				1. `BR *0(SP)`：从栈顶取出返回地址并跳转回调用者
				2. `SUB SP, #caller.recordSize`：释放调用者的活动记录空间
			- 例：![[Pasted image 20251210194410.png]]
- 运行时刻地址：使用符号表确定变量名和对应地址的位置
	- 静态区域分配：变量实际地址为静态区地址起始位置和变量相对地址位置之和
	- 栈区分配：变量实际地址为栈顶寄存器`SP`和变量相对地址位置之和
# 基本块和流图
- 基本块（Basic Block）：
	- 概念：一组顺序执行的指令序列，只有一个入口和一个出口
	- 划分算法：针对三地址码的划分算法
		1. 标记基本块的开始指令（leader）：
			- 程序的第一条指令是一个基本块的开始指令
			- 任何跳转目标指令都是一个基本块的开始指令
			- 紧跟在跳转指令后的指令是一个基本块的开始指令
		2. 每个开始指令到下一个开始指令前的所有指令组成一个基本块
		- 例：![[Pasted image 20251210195311.png]]
- 流图：
	- 概念：以基本块集为节点，以基本块之间的控制流为边的有向图
		- 存在从基本块$i$到基本块$j$的边，当且仅当基本块$i$的最后一条指令可以转移控制到基本块$j$的第一条指令（$j$紧跟在$i$之后，或者$i$以跳转指令结束且跳转目标为$j$）
		- 例：![[Pasted image 20251210195657.png]]
	- 作用：
		- 识别循环：循环是指一个节点集合，存在唯一的循环入口节点，且其余节点存在到达入口节点的路径
			- 例：![[Pasted image 20251210200829.png]]
			- 程序的大量时间都花费在循环中，因此循环是程序重点优化的目标
		- 确定活跃性：
			- 概念：若三地址语句$i$给变量`x`赋值，且另一个三地址语句$j$的运算分量为`x`，且从$i$有一条到$j$的路径上没有其他对`x`赋值的语句，则$j$使用的是$i$处计算得到的`x`值，此时称`x`在语句$i$后的程序点上**活跃**
				- 活跃指这条语句计算得到的值在后续的某条语句中被使用
				- 不活跃且占用寄存器的变量可以被回收以供其他变量使用
			- 确定方法：
				1. 输入基本块B，其中所有非临时变量都是活跃的
				2. 从基本块B的最后一条语句开始，向前扫描每条语句：
					- 对于每条语句$i$：`x = y OP z`：
						- 关联语句`i`与当前的变量
						- 标记`y`和`z`为活跃变量，指明下一次使用为语句`i`
						- 标记`x`为非活跃变量与无后续使用
				3. 输出基本块B中每条语句关联的变量活跃性信息 
				- 例：![[Pasted image 20251210201554.png]]
# 基本块优化
- 针对基本块，可以进行一些局部优化以提高代码效率
- DAG图：
	- 概念：有向无环图（Directed Acyclic Graph），用于反映变量及其值和其他变量之间的依赖关系
	- 构造：
		1. 为基本块中出现的每个变量建立节点（表示初始值），各个变量关联到相应的节点
		2. 顺序扫描三地址指令，进行如下处理：
			- 指令：`x = y op z`：
				- 建立节点`N`，标号为`op`，关联`x`与`N`
				- `N`的子节点为`y`和`z`目前关联的节点
			- 指令：`x = y`：
				- 关联`x`与`y`目前关联的节点
		3. 扫描结束后，对所有在出口处活跃的变量，将其关联节点标记为输出节点
		- 例：![[Pasted image 20251210203946.png]]
	- 作用：描述了基本块运行时各个变量的值和初始值之间的关系，为优化提供依据
- 优化手段：
	- **局部公共子表达式消除**： ^498c21
		- 建立某个节点`M`之前，检查是否存在另一个节点`N`和`M`具有相同的运算符和子节点
		- 若存在，则不建立节点`M`，而是将变量关联到节点`N`
		- 例：![[Pasted image 20251210205005.png]]
	- **死代码消除**：
		- 在DAG图上消除没有附加活跃变量的根节点，也即消除死代码
		- 例：![[Pasted image 20251210205158.png]]
	- **基于代数恒等式的优化**：
		- 恒等式：
			- `x + 0 = 0 +  x = x`
			- `x - 0 = x`
			- `x * 1 = 1 * x = x`
			- `x / 1 = x`
			- `x * 0 = 0`
			- `0 / x = 0 (x ≠ 0)`
		- 强度消减：将高代价运算替换为低代价运算，例如：
			- `x ^ 2 = x * x`
			- `2 * x = x + x`
			- `x / 2 = x >> 1`（右移一位）
		- 常量合并/折叠：对常量进行计算并替换为结果，例如：
			- `x = 3 + 5`替换为`x = 8`
		- 通用代数转换：利用运算律，调整运算顺序并优化
			- `x * y = y * x`
		- 只需在DAG图上找特定的模式，即可发现这些优化点
	- **数组引用**：
		- 数组元素的状态改变会使整个数组的状态改变，因此需要对对应的节点做特殊处理
		- 处理方式：
			- 建立`=[]`节点，表示从数组取值的运算。节点的子节点为数组初始值`a0`以及下标`i`
				- 对于运算`x = a[i]`，变量`x`是节点的标号
			- 建立`[]=`节点，表示向数组赋值的运算。节点的子节点为数组初始值`a0`、下标`j`和新值`v`
				- 对于运算`a[i] = v`，将数组初始值`a0`关联到该节点
				- 运算表达式关联后，还应杀死所有依赖于`a0`的变量
		- 例：![[Pasted image 20251211195137.png]]
	- **指针赋值/过程调用**：
		- 指针取值语句`x = *p`中，`x`使用了任意变量，因此无法消除死代码（无法判断该操作是否冗余）
		- 指针赋值语句`*p = y`中，`y`可能影响任意变量，因此杀死全部已存在的中间节点（可能的原变量值均被改变）
		- 需要通过指针分析技术来确定指针的可能取值范围，以便于进行更精确的优化
- 从DAG重组为基本块
	- 方法：
		- 为每个节点构造一个三地址语句，计算对应的值
		- 结果尽可能赋予一个活跃的变量
		- 若节点关联多个变量，使用复制语句进行赋值
	- 例：![[Pasted image 20251211200106.png]]
	- 重组规则：
		- 指令顺序需遵循DAG中节点的顺序
		- 数组操作顺序：
			- 数组赋值需要在之前数组的赋值/求值之后进行
			- 数组求值需要在之前数组的赋值指令之后进行
		- 过程/指针操作顺序：
			- 变量使用需要跟在所有原本在它之前的过程调用和指针间接赋值之后
			- 过程调用/指针间接赋值必须1跟在原来在它之前的变量求值之后
		- 原则：两原本互相影响的指令顺序不应改变
# 代码生成器实例
- 思路：
	- 以基本块为单位，为基本块产生代码
	- 三地址语句的运算符和目标机的运算符一一对应
	- 计算结果应尽可能存留在寄存器中以提高效率
- 寄存器与地址描述：
	- 原则：尽可能让以后还会使用的变量存留在寄存器中
		- 例：![[Pasted image 20251211201010.png]]
	- 寄存器描述：
		- 记录每个寄存器当前存储的变量
		- 在任何一个状态，每个寄存器保存若干个名字的值
	- 地址描述：
		- 记录运行时每个名字的值存储位置
		- 一般与符号表关联，存储地址可以是寄存器或内存地址
- 代码生成算法：依照核心子函数`getReg(I)`，逐行处理三地址指令生成目标代码
	- 函数`getReg(I)`：为三地址指令`I`的运算分量获取寄存器
	- 流程：
		1. 利用函数`getReg(I)`为每条指令获取对应的寄存器，并根据情况生成不同的目标代码
			- 运算语句`x = y + z`：
				- 选择寄存器`Rx, Ry, Rz`分别存储`x, y, z`，
				- 检查`y`和`z`是否在寄存器中，若不在则生成指令`LD Ry, y`或`LD Rz, z`将其加载到寄存器中
				- 生成指令`ADD Rx, Ry, Rz`
			- 赋值语句`x = y`：
				- `getReg(x = y)`返回二者使用的同一个寄存器
				- 若`y`不在寄存器中，则生成指令`LD Ry, y`将其加载到寄存器中
				- 生成指令`MOV Rx, Ry`
			- 基本块末尾，若`x`活跃但不在内存中，则生成指令`ST x, Rx`将其存回内存
		2. 逐行处理生成的代码，更新寄存器描述和地址描述
			- 指令`LD R, x`：
				- 更新寄存器描述，使`R`只包含`x`
				- 更新地址描述，在`x`的地址中包含`R`，并删除其他地址描述中的`R`
			- 指令`ST x, R`：
				- 更新地址描述，在`x`的地址中包含`R`、
			- 指令`ADD Rx, Ry, Rz`：
				- 更新寄存器描述，使`Rx`只包含`x`
				- 更新地址描述，在`x`的地址中只包含`Rx`，并删除其他地址描述中的`Rx`
		- 例：![[Pasted image 20251211201939.png]]![[Pasted image 20251211201949.png]]
- 寄存器策略：
	- 局部寄存器选择：
		- 目的：减少`LD`和`ST`指令的数量
		- 任务：为运算分量和结果选择寄存器
		- 策略：以运算语句`x = y OP z`为例
			- 为运算分量`y`选择寄存器
				- 若`y`已经在某个寄存器中，选择该寄存器作为`Ry`
				- 若`y`不在寄存器中，且存在空闲寄存器，选择一个空闲寄存器作为`Ry`
				- 若`y`不在寄存器中，且没有空闲寄存器，选择一个寄存器`Rk`（描述符为`v`）回收
					- 若`v`的地址描述符中有其他位置，则可以顺利回收
					- 若`v`就是结果，且`x`和`z`不同，则可以顺利回收
					- 若`v`不活跃，则可以顺利回收
					- 某则，则要生成指令`ST v, Rk`将`v`存回内存后再回收
			- 为结果`x`选择寄存器：基本相似的流程，但仅存储`x`的寄存器也是可接受的
	- 全局寄存器指派：
		- 确定各个点上每个值应存在哪个寄存器中
		- 策略：
			- 为特定类型的值分配特定的寄存器（如`%rsp`用于栈指针，`%rax`用于返回值等）
			- 循环中频繁使用的变量优先分配寄存器
			- 通过计数变量在基本块中被使用的次数，优先为使用次数多的变量分配寄存器
- 指令选择：
	- 指令和三地址代码往往不是一一对应的，一个三地址码有多种指令实现形式
	- 因此，需要选择特定的指令来实现三地址码
	- 方法：**树重写**
		- 概念：将三地址指令表示为一棵树，然后通过模式匹配选择合适的指令
		- 树重写规则：
			- 形式：`replacement <- template {action}`，表示用代码表示为`action`的树`template`替换掉原有的树`replacement`
			- 例：![[Pasted image 20251211203327.png]]
			- 一些目标机树重写规则：![[Pasted image 20251211203402.png]]
		- 例：一棵中间代码树![[Pasted image 20251211203114.png]]
---
[[L8 代码优化]]