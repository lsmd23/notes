# 概述
- 代码生成依赖中间代码生成实际可执行的汇编代码
	- 汇编代码：参考[[L2.1 机器指令-基础|机器指令基础]]、[[L2.2 机器指令-控制|控制流机器指令]]、[[L2.3 机器指令-过程|过程调用机器指令]]
- 代码生成器的任务：
	- 指令选择：选择适当的机器指令来实现中间代码的操作
	- 寄存器分配：将变量分配到有限的寄存器中，以提高执行效率
	- 指令调度：重新安排指令顺序以减少流水线停顿和提高并行性
- 问题：若不加任何优化的直接由三地址码生成对应的目标代码，效率是及其低下的
	- 例：![[Pasted image 20251210191540.png]]
# 目标机模型
- 在确定代码生成策略前，需要定义目标机器的模型以便于代码生成器进行相应的优化
- 三地址机器模型：
	- 假定目标机器支持无限数量的寄存器，且支持所有三地址指令
	- 指令类型：
		- 变量加载：`LD dst, addr`，将内存地址`addr`处的值加载到寄存器`dst`
		- 变量保存：`ST x, reg`，将寄存器`reg`的值存储到内存地址`x`
		- 计算：`<OP> dst, src1, src2`，将`src1`和`src2`进行操作`OP`，结果存储到`dst`
		- 无条件跳转：`BR L`，跳转到标签`L`
		- 条件跳转：`Bcond reg, L`，根据寄存器`reg`的值进行条件跳转到标签`L` 
	- 寻址模式：
		- 常数：`#c`，表示常数`c`
		- 变量`x`：指向分配给`x`的内存地址（也即`x`的左值）
		- `*r`：表示寄存器`r`中存储的地址处的值
		- `const(r)`：表示地址`const + r`处的值
		- `a(r)`：表示地址`a + r`处的值
		- `*const(r)`：表示地址`const + r`处存储的地址指向的值
	- 目标代码示例：
		- 例1：![[Pasted image 20251210192350.png]]
		- 例2：![[Pasted image 20251210192357.png]]
	- 程序指令代价：
		- 包含最短编译时间、运行时间、目标程序大小和能耗等的指标
		- 代价计算假设：假设不同的指令有不同的代价，且每条指令的代价是独立的，计算为1加上运算分量寻址模式的代价
			- `LD R0, R1`的代价为1
			- `LD R0, M`的代价为2
			- `LD R0, *100(R1)`的代价为2
# 目标代码中的地址
- 在生成目标代码的过程中，需要合理的确定各个变量、指令等存储的地址，并对其进行管理
- 活动记录分配：
	- 静态分配：
		- 特点：为每个过程都静态地分配一个属于该过程的数据区域，每个过程的开始位置用属性`staticArea`表示
		- 调用返回实现：
			- 调用`callee`时，执行指令`ST callee.staticArea, #here + 20`（用于存放返回地址，+20表示下下一条指令的地址），再执行`BR callee.codeArea`进入`callee`的代码区域执行
			- 返回时，执行`BR *callee.staticArea`跳转回调用者的返回地址继续执行
			- 例：![[Pasted image 20251210193524.png]]调用过程在120处开始，先将140（也即下下一条指令地址）存入一个活动记录区，在被调用过程结束后，从这个活动区域取出返回地址继续执行
	- 栈式分配：
		- 特点：使用一个栈和对应的栈顶寄存器`SP`来动态地分配和释放活动记录
		- 调用返回实现：
			- `main`过程初始化栈区
			- 调用序列：
				1. `ADD SP, SP, #caller.recordSize`：为调用者分配活动记录空间
				2. `ST 0(SP), #here + 16`：将返回地址存入栈顶
				3. `BR callee.codeArea`：跳转到被调用过程的代码区域
			- 返回序列：
				1. `BR *0(SP)`：从栈顶取出返回地址并跳转回调用者
				2. `SUB SP, SP, #caller.recordSize`：释放调用者的活动记录空间
			- 例：![[Pasted image 20251210194410.png]]
- 运行时刻地址：使用符号表确定变量名和对应地址的位置
	- 静态区域分配：变量实际地址为静态区地址起始位置和变量相对地址位置之和
	- 栈区分配：变量实际地址为栈顶寄存器`SP`和变量相对地址位置之和
# 基本块和流图
- 基本块（Basic Block）：
	- 概念：一组顺序执行的指令序列，只有一个入口和一个出口
	- 划分算法：针对三地址码的划分算法
		1. 标记基本块的开始指令（leader）：
			- 程序的第一条指令是一个基本块的开始指令
			- 任何跳转目标指令都是一个基本块的开始指令
			- 紧跟在跳转指令后的指令是一个基本块的开始指令
		2. 每个开始指令到下一个开始指令前的所有指令组成一个基本块
		- 例：![[Pasted image 20251210195311.png]]
- 流图：
	- 概念：以基本块集为节点，以基本块之间的控制流为边的有向图
		- 存在从基本块$i$到基本块$j$的边，当且仅当基本块$i$的最后一条指令可以转移控制到基本块$j$的第一条指令（$j$紧跟在$i$之后，或者$i$以跳转指令结束且跳转目标为$j$）
		- 例：![[Pasted image 20251210195657.png]]
	- 作用：
		- 识别循环：循环是指一个节点集合，存在唯一的循环入口节点，且其余节点存在到达入口节点的路径
			- 例：![[Pasted image 20251210200829.png]]
			- 程序的大量时间都花费在循环中，因此循环是程序重点优化的目标
		- 确定活跃性：
			- 概念：若三地址语句$i$给变量`x`赋值，且另一个三地址语句$j$的运算分量为`x`，且从$i$有一条到$j$的路径上没有其他对`x`赋值的语句，则$j$使用的是$i$处计算得到的`x`值，此时称`x`在语句$i$后的程序点上**活跃**
				- 活跃指这条语句计算得到的值在后续的某条语句中被使用
				- 不活跃且占用寄存器的变量可以被回收以供其他变量使用
			- 确定方法：
				1. 输入基本块B，其中所有非临时变量都是活跃的
				2. 从基本块B的最后一条语句开始，向前扫描每条语句：
					- 对于每条语句$i$：`x = y OP z`：
						- 关联语句`i`与当前的变量
						- 标记`y`和`z`为活跃变量，指明下一次使用为语句`i`
						- 标记`x`为非活跃变量与无后续使用
				3. 输出基本块B中每条语句关联的变量活跃性信息 
				- 例：![[Pasted image 20251210201554.png]]
# 基本块优化
- 针对基本块，可以进行一些局部优化以提高代码效率
- DAG图：
	- 概念：有向无环图（Directed Acyclic Graph），用于反映变量及其值和其他变量之间的依赖关系
	- 构造：
		1. 为基本块中出现的每个变量建立节点（表示初始值），各个变量关联到相应的节点
		2. 顺序扫描三地址指令，进行如下处理：
			- 指令：`x = y op z`：
				- 建立节点`N`，标号为`op`，关联`x`与`N`
				- `N`的子节点为`y`和`z`目前关联的节点
			- 指令：`x = y`：
				- 关联`x`与`y`目前关联的节点
		3. 扫描结束后，对所有在出口处活跃的变量，将其关联节点标记为输出节点
		- 例：![[Pasted image 20251210203946.png]]
	- 作用：描述了基本块运行时各个变量的值和初始值之间的关系，为优化提供依据
- 