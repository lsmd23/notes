# 概述
- 代码生成依赖中间代码生成实际可执行的汇编代码
	- 汇编代码：参考[[L2.1 机器指令-基础|机器指令基础]]、[[L2.2 机器指令-控制|控制流机器指令]]、[[L2.3 机器指令-过程|过程调用机器指令]]
- 代码生成器的任务：
	- 指令选择：选择适当的机器指令来实现中间代码的操作
	- 寄存器分配：将变量分配到有限的寄存器中，以提高执行效率
	- 指令调度：重新安排指令顺序以减少流水线停顿和提高并行性
- 问题：若不加任何优化的直接由三地址码生成对应的目标代码，效率是及其低下的
	- 例：![[Pasted image 20251210191540.png]]
# 目标机模型
- 在确定代码生成策略前，需要定义目标机器的模型以便于代码生成器进行相应的优化
- 三地址机器模型：
	- 假定目标机器支持无限数量的寄存器，且支持所有三地址指令
	- 指令类型：
		- 变量加载：`LD dst, addr`，将内存地址`addr`处的值加载到寄存器`dst`
		- 变量保存：`ST x, reg`，将寄存器`reg`的值存储到内存地址`x`
		- 计算：`<OP> dst, src1, src2`，将`src1`和`src2`进行操作`OP`，结果存储到`dst`
		- 无条件跳转：`BR L`，跳转到标签`L`
		- 条件跳转：`Bcond reg, L`，根据寄存器`reg`的值进行条件跳转到标签`L` 
	- 寻址模式：
		- 常数：`#c`，表示常数`c`
		- 变量`x`：指向分配给`x`的内存地址（也即`x`的左值）
		- `*r`：表示寄存器`r`中存储的地址处的值
		- `const(r)`：表示地址`const + r`处的值
		- `a(r)`：表示地址`a + r`处的值
		- `*const(r)`：表示地址`const + r`处存储的地址指向的值
	- 目标代码示例：
		- 例1：![[Pasted image 20251210192350.png]]
		- 例2：![[Pasted image 20251210192357.png]]
	- 程序指令代价：
		- 包含最短编译时间、运行时间、目标程序大小和能耗等的指标
		- 代价计算假设：假设不同的指令有不同的代价，且每条指令的代价是独立的，计算为1加上运算分量寻址模式的代价
			- `LD R0, R1`的代价为1
			- `LD R0, M`的代价为2
			- `LD R0, *100(R1)`的代价为2
# 目标代码中的地址
- 在生成目标代码的过程中，需要合理的确定各个变量、指令等存储的地址，并对其进行管理
- 活动记录分配：
	- 静态分配：
		- 特点：为每个过程都静态地分配一个属于该过程的数据区域，每个过程的开始位置用属性`staticArea`表示
		- 调用返回实现：
			- 调用`callee`时，执行指令`ST callee.staticArea, #here + 20`（用于存放返回地址，+20表示下下一条指令的地址），再执行`BR callee.codeArea`进入`callee`的代码区域执行
			- 返回时，执行`BR *callee.staticArea`跳转回调用者的返回地址继续执行
			- 例：![[Pasted image 20251210193524.png]]调用过程在120处开始，先将140（也即下下一条指令地址）存入一个活动记录区，在被调用过程结束后，从这个活动区域取出返回地址继续执行
	- 栈式分配：
		- 特点：使用一个栈和对应的栈顶寄存器`SP`来动态地分配和释放活动记录
		- 调用返回实现：
			- `main`过程初始化栈区
			- 调用序列：
				1. `ADD SP, SP, #caller.recordSize`：为调用者分配活动记录空间
				2. `ST 0(SP), #here + 16`：将返回地址存入栈顶
				3. `