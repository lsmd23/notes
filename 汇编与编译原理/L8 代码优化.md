# 引言
- 代码优化：在目标代码中消除不必要指令，并将原有指令替换成相同功能但效率更高的指令的过程
	- 依赖**数据流分析技术**和收集程序运行时信息
	- 来源：源程序的冗余运算或高级程序语言的特性
	- 语义不变的优化：优化前后程序的语义保持不变，例如：
		- 公共子表达式消除
		- 复制传播
		- 死代码消除
		- 常量折叠
- 优化的类型：
	- 按照范围划分
		- 窥孔优化：在几条指令范围内进行的优化
		- 局部优化：在基本块范围内进行的优化
		- 全局优化：在整个控制流图范围内进行的优化
		- 过程间优化：在整个程序范围内进行的优化
	- 按照对象划分
		- 目标代码优化
		- 中间代码优化
		- 源代码优化
	- 按优化侧面划分
		- 指令调度
		- 寄存器分配
		- 存储层次优化
		- 循环优化
		- 控制流优化
		- 过程优化
		- ……
# 窥孔优化
- 工作方式：在目标程序上滑动一个固定大小的窗口，对窗口内的指令按照某种优化策略进行优化
	- 可以适用于目标代码和中间代码
	- 主要优化举例：
		- **删除冗余加载和保存**：
			- 优化前：
				```
				ST a, R0
				LD R0, a
				```
			- 优化后：
				```
				ST a, R0
				```
		- **合并已知量**：
			- 优化前：`r2 = 3 * 2`
			- 优化后：`r2 = 6`
		- **常量传播**：
			- 优化前：
				```
				r1 = 5
				r3 = r1 + r2
				```
			- 优化后：
				```
				r1 = 5
				r3 = 5 + r2
				```
				如果已知`r1`不活跃，则可以删除`r1 = 5`这一指令
		- **代数简化**：
			- 优化前：`r1 = r2 * 1`
			- 优化后：`r1 = r2`
		- **控制流简化**：
			- 优化前：
				```
				goto L1
				L1: goto L2
				```
			- 优化后：
				```
				goto L2
				L1: goto L2
				```
		- **死代码消除**：
			- 优化前：
				```
				debug = false
				if (debug) print...
				```
			- 优化后：
				```
				debug = false
				```
		- **强度削减**：
			- 优化前：`r1 = r2 * 8`
			- 优化后：`r1 = r2 << 3`
		- **使用目标机惯用指令**：
			- 优化前：`r1 = r2 + r2 + r2 + r2`
			- 优化后（假设目标机有`MULI`指令）：`r1 = MULI r2, 4`
# 基本块优化
- 参见[[L7 代码生成#基本块优化|基本块优化]]
# 全局优化
- 针对流图的数据流分析进行的优化技术
	- 以快速排序算法为例：
		- 源代码：![[Pasted image 20251214205108.png]]
		- 三地址码：![[Pasted image 20251214205121.png]]
		- 流图：![[Pasted image 20251214205135.png]]
	- **全局公共子表达式**：
		- 定义：如果某个表达式在出现前被计算过，且其运算分量没有改变，则称该表达式为公共子表达式
		- 全局公共子表达式可以用单个变量替换，从而减少重复计算
		- 例：![[Pasted image 20251214205643.png]]![[Pasted image 20251214205653.png]]
	- **复制传播**：
		- 定义：对形如`u = v`的复制语句，在后面的程序点上，可以保证`u = v`成立，从而消除对`u`的使用
		- 例：![[Pasted image 20251214205753.png]]
	- **死代码消除**：
		- 定义：如果某个变量的值在程序中没有被使用，则该变量的赋值语句为死代码，可以被消除
		- 死代码可能由于前面的优化产生
		- 例：![[Pasted image 20251214205821.png]]
	- **代码移动**：
		- 循环不变表达式：在一个循环的多次迭代中不变的表达式
		- 可以将循环不变表达式移出循环体，从而减少循环内的计算量
		- 例：![[Pasted image 20251214205915.png]]
	- **归纳变量**：
		- 定义：在循环中以固定步长变化的变量
		- 可以通过等效的替换，减少循环内的计算强度
		- 例：![[Pasted image 20251214210050.png]]
# 数据流分析技术
- 获取程序数据沿执行路径的流动信息，以实现全局优化
	- **核心目的**：收集程序运行时的各类性质，判断优化是否安全
	- **应用场景**：公共子表达式消除、活跃变量分析（用于死代码消除和寄存器分配）等
- 基础概念：数据流分析通过对程序点进行抽象和约束求解来获得信息
	- **程序点（Program Point）**：指三地址语句之前或之后的位置
	- **执行路径（Execution Path）**：**执行路径 (Execution Path)**：程序点 $p_1$​ 到 $p_n$​ 的序列，表示程序可能的执行轨迹
	- **数据流值 (Data-flow Value)**：与程序点关联的性质集合，表示在该点必然满足的条件（安全性要求）
	- **域 (Domain)**：数据流值所有可能取值的集合。例如“到达定值分析”的域是程序中所有定值的集合
	- 例：![[Pasted image 20251228164933.png]]
- 约束求解模式：数据流值所受的约束
	1. 基于语句语义的约束（传递函数）：**单个语句或基本块**会改变数据流的状态，称为**传递函数$f$**（适用于基本块内的分析）
		- 正向流：$$\text{OUT}(s) = f_s(\text{IN}(s))$$信息由输入流向输出
		- 逆向流：$$\text{IN}(s) = f_s(\text{OUT}(s))$$信息由输出流向输入
			- 例：![[Pasted image 20251228165733.png]]
		- 生成-杀死形式：$f_B​(x)=gen_B​∪(x−kill_B​)$。其中 $gen_B$​ 是基本块内生成的性质，$kill_B$​ 是被块内语句杀死的性质
	2. 基于控制流的约束（交汇运算）：在**基本块的交汇处**，需要通过**交汇运算 (∧)** 合并来自不同路径的信息（适用于基本块间的分析）
		- **前向问题**：基本块 $B$ 的输入由其所有前驱基本块 $P$ 的输出决定$$\text{IN}(B) = \bigwedge_{P \in \text{pred}(B)} \text{OUT}(P)$$
		- **逆向问题**：基本块 $B$ 的输出由其所有后继基本块 $S$ 的输入决定$$\text{OUT}(B) = \bigwedge_{S \in \text{succ}(B)} \text{IN}(S)$$
			- 例：![[Pasted image 20251228165933.png]]
- 数据流分析模式：
	1. 到达定值（Reaching Definitions）：
		- 定义：称定值$d$到达程序点$p$，如果存在一条从$d$所在语句到$p$的执行路径，且在该路径上$d$未被覆盖
			- 例：![[Pasted image 20251228170501.png]]
		- 方向：正向
		- 交汇运算：并集$\cup$
		- 目的：追踪定值来源辅助常量替换
		- 初始化：$OUT[B] = ∅$