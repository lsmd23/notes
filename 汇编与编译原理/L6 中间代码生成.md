# 中间代码概述
- 定义：中间代码是源程序的内部表示形式，介于源代码和目标代码之间
- 作用：
	- 避免源语言和目标语言的语义跨度，简化编译器设计
	- 便于编译程序重定向
	- 利于与目标机无关的优化
- 形式：
	- AST（Abstract Syntax Tree，抽象语法树）
	- DAG（Directed Acyclic Graph，有向无环图）
	- Postfix（后缀式，逆波兰表示法）
	- **TAC**（Three Address Code，**三地址码**）
		- 顺序的语句示例，格式为`X := Y op Z`，其中`op`为操作码，`Y`和`Z`为操作数，`X`为结果存储位置
		- 例：![[Pasted image 20251202141400.png]]
	- P-code（Pascal语言）
# 声明语句
- 目标：为声明语句建立符号表条目，分配存储单元并记录类型、地址等信息
- 途径：利用[[L4 语法制导的翻译|语法制导翻译]]，添加对应语义规则以生成中间代码
- 语义属性：
	-  `id.lexeme`：词法名（符号表内的标识符）
	- `T.type`：类型属性
	- `T.width`：数据宽度（字节数）
	- `offset`：相对基地址的下一个可用相对偏移地址（参考[[L5 符号表与运行时存储组织#运行时存储组织|运行时存储组织]]）
- 语义函数：
	- `put(id.lexeme, T.type, offset)`：将符号表中`id.lexeme`的类型设为`T.type`，地址设为当前`offset`
- 翻译方案：
	- `T → char`：`T.type = CHAR; T.width = 1`
	- `T → integer`：`T.type := integer; T.width := 4`
	- `T → real`：`T.type := real; T.width := 8`
	- `T → array [num] of T1`：`T.type := array(num.val, T1.type)`；` T.width := num.val × T1.width`（数组类型，宽度为元素个数 × 单个元素宽度）
	- `T → ↑T1`：`T.type := pointer(T1.type); T.width := 4`（指针类型，宽度固定为 4 字节）
	- `D → D1 ; D2`：先处理`D1`，再处理`D2`，共享`offset`变量更新存储偏移
	- `D → id: T`：`put(id.lexeme, T.type, offset); offset := offset + T.width`（为标识符分配地址并更新偏移）
# 赋值语句
- 语义属性：
	- `id.lexeme`：标识符的词法名
	- `E.code`：表达式`E`的TAC语句序列
	- `E.place`：存放表达式`E`结果的临时变量
- 语义函数：
	- `get(id.lexeme)`：从符号表中查找标识符`id.lexeme`，返回存放相应值的指针（无则返回NULL）
	- `gen(...)`：生成一条TAC语句
	- `newtemp()`：生成一个新的临时变量名并返回
- 翻译方案：
	- `S → id := E`：
# 布尔表达式


# 控制流语句

# 拉链与代码回填

