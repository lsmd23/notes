# 中间代码概述
- 定义：中间代码是源程序的内部表示形式，介于源代码和目标代码之间
- 作用：
	- 避免源语言和目标语言的语义跨度，简化编译器设计
	- 便于编译程序重定向
	- 利于与目标机无关的优化
- 形式：
	- AST（Abstract Syntax Tree，抽象语法树）
	- DAG（Directed Acyclic Graph，有向无环图）
	- Postfix（后缀式，逆波兰表示法）
	- **TAC**（Three Address Code，**三地址码**）
		- 顺序的语句示例，格式为`X := Y op Z`，其中`op`为操作码，`Y`和`Z`为操作数，`X`为结果存储位置
		- 例：![[Pasted image 20251202141400.png]]
	- P-code（Pascal语言）
# 声明语句
- 目标：为声明语句建立符号表条目，分配存储单元并记录类型、地址等信息
- 途径：利用[[L4 语法制导的翻译|语法制导翻译]]，添加对应语义规则以生成中间代码
- 语义属性：
	-  `id.lexeme`：词法名（符号表内的标识符）
	- `T.type`：类型属性
	- `T.width`：数据宽度（字节数）
	- `offset`：相对基地址的下一个可用相对偏移地址（参考[[L5 符号表与运行时存储组织#运行时存储组织|运行时存储组织]]）
- 语义函数：
	- `put(id.lexeme, T.type, offset)`：将符号表中`id.lexeme`的类型设为`T.type`，地址设为当前`offset`
- 翻译方案：
	- `T → char`：`T.type = CHAR; T.width = 1`
	- `T → integer`：`T.type := integer; T.width := 4`
	- `T → real`：`T.type := real; T.width := 8`
	- `T → array [num] of T1`：`T.type := array(num.val, T1.type)`；` T.width := num.val × T1.width`（数组类型，宽度为元素个数 × 单个元素宽度）
	- `T → ↑T1`：`T.type := pointer(T1.type); T.width := 4`（指针类型，宽度固定为 4 字节）
	- `D → D1 ; D2`：先处理`D1`，再处理`D2`，共享`offset`变量更新存储偏移
	- `D → id: T`：`put(id.lexeme, T.type, offset); offset := offset + T.width`（为标识符分配地址并更新偏移）
# 赋值语句
- 语义属性：
	- `id.lexeme`：标识符的词法名
	- `E.code`：表达式`E`的TAC语句序列
	- `E.place`：存放表达式`E`结果的临时变量
- 语义函数：
	- `get(id.lexeme)`：从符号表中查找标识符`id.lexeme`，返回存放相应值的指针（无则返回NULL）
	- `gen(...)`：生成一条TAC语句
	- `newtemp()`：生成一个新的临时变量名并返回
- 翻译方案：
	- `E → (E1)`：
		- 语义规则：
		  ```
		  E.place = E1.place;
		  E.code = E1.code;
		  ```
		- 括号表达式，传递子表达式的结果和代码
	- `E → E1 op E2`： 
		- 语义规则：
			```
			E.place = newtemp();
			E.code = E1.code || E2.code ||
			            gen(E.place := E1.place op E2.place)
			```
		- 二元运算表达式，生成计算代码并存放结果
	- `E → op E1`：
		- 语义规则：
		  ```
		  E.place = newtemp();
		  E.code = E1.code ||
		              gen(E.place := op E1.place)
		  ```
		  - 一元运算表达式，生成计算代码并存放结果
	- `E → id`：
		- 语义规则：
		  ```
		  ptr = get(id.lexeme);
		  if ptr == NULL then error("undeclared variable");
		  E.place = ptr;
		  E.code = "";
		  ```
		- 标识符表达式，获取变量地址`
	- `S → id := E`：
		- 语义规则：
		  ```
		  ptr = get(id.lexeme);
		  if ptr == NULL then error("undeclared variable");
		  S.code = E.code ||
		              gen(ptr := E.place)
		  ```
		- 赋值语句，生成赋值操作的TAC代码
- 数组元素的地址计算：
	- 一维数组：首地址为`base`，下界为`low`，元素宽度为`w`，访问元素`A[i]`的地址计算为`addr = base + (i - low) * w`（常优化为`addr = i * w + (base - low * w)`，括号内可以在编译时计算）
	- 二维数组：`A[i][j]`
		- 列优先存储：
			- 按照`A[1,1], A[2,1], ..., A[m,1], A[1,2], A[2,2], ..., A[m,n]`顺序存储
			- 地址公式：`addr = base + ((j - low2) * row_size + (i - low1)) * w`，其中`row_size`为每行元素个数
		- 行优先存储：
			- 按照`A[1,1], A[1,2], ..., A[1,n], A[2,1], A[2,2], ..., A[m,n]`顺序存储
			- 地址公式：`addr = base + ((i - low1) * col_size + (j - low2)) * w`，其中`col_size`为每列元素个数
	- 多维数组：`A[i1][i2]...[ik]`
		- 地址公式为：`((...((i1 × n2 + i2) × n3 + i3)...) × nk + ik) × w + base - ((...((low1 × n2 + low2) × n3 + low3)...) × nk + lowk) × w`（其中`ni`为第`i`维的大小，`lowi`为第`i`维的下界）
	- 数组的内情向量（dope vector）：
		- 处理数组时，常将有关信息记录在某些单元中，称之为内情向量
			- 静态数组存放在符号表中
			- 动态数组在运行时建立内情向量
		- 例：对于数组`A[l1:u1,l2:u2,...,ln,un]`，内情向量包含：
			- 每维的下界`li`和上界`ui`
			- `type`：元素类型
			- `base`：数组首地址
			- `n`：数组维数
			- `C`：编译期常量，用于地址计算优化
		- 地址计算：对于上述的静态数组，元素`A[i1,i2,...,in]`的地址计算为：$$\begin{align*} D = & \text{base} + (i_1-l_1)(u_2-l_2+1)(u_3-l_3+1)\cdots(u_n-l_n+1)  \\ & + (i_2-l_2)(u_3-l_3+1)(u_4-l_4+1)\cdots(u_n-l_n+1) \\ & + \cdots \\ & + (i_{n-1}-l_{n-1})(u_n-l_n+1) \\ & + (i_n - l_n)  \end{align*}$$也即$D = \text{base}-C+V$，其中：$$C = ( \dots ( ( ( l_1 (u_2 - l_2 + 1) + l_2 ) (u_3 - l_3 + 1) + l_3 ) (u_4 - l_4 + 1) + \dots + l_{n-1} ) (u_n - l_n + 1) + l_n$$是静态可计算的，$$ V = ( \dots ( ( ( i_1 (u_2 - l_2 + 1) + i_2 ) (u_3 - l_3 + 1) + i_3 ) (u_4 - l_4 + 1) + \dots + i_{n-2} ) (u_n - l_n + 1) + i_n $$
- 类型转换：当翻译到赋值或运算语句时，涉及类型转换时，需插入相应的转换代码
	- 例：对语句`x_real := y_real + i_int * j_int`，应当生成如下中间TAC代码：
		```
		t1 := i_int int* j_int
		t2 := int_to_real(t1)
		t3 := y_real real+ t2
		x_real := t3
		```
		对应的翻译规则代码应类似：
		```
		# E → E1 + E2
		E.place = newtemp();
		if E1.type = int and E2.type = int then {
			emit(E.place,":=",E1.place,"int+",E2.place);
			E.type = int;
		}
		else if E1.type = int and E2.type = real then {
			t = newtemp();
			emit(t,":= int_to_real(",E1.place,")");
			emit(E.place,":=",t,"real+",E2.place);
			E.type = real;
		}
		...		    
		```
# 布尔表达式
-  直接求值：用数值表示布尔值，并用类似赋值语句的方式生成代码，例如表达式`a < b`的翻译：
	```text
	100: if a < b goto 103 
	101: t := 0 
	102: goto 104 
	103: t := 1 
	104: ... 
	```
	对语义规则，只需要在对应的最终产生式后，添加对应的赋值为0或1的语句即可
- 控制流翻译：
	- 利用跳转语句实现布尔表达式的控制流，支持短路求值（避免不必要的计算）
		- 例：`E = a < b or c < d and e < f`的翻译
			```text
			(1) if a < b goto E.true 
			(2) goto (3) 
			(3) if c < d goto (5) 
			(4) goto E.false 
			(5) if e < f goto E.true 
			(6) goto E.false
			```
	- 语义属性：
		- `E.true`：表达式`E`为真的跳转目标标签
		- `E.false`：表达式`E`为假的跳转目标标签
		- `nextstat`：下一条TAC语句的标签
	- 翻译方案：
		- `E → true/false`：
			- 语义规则：
			  ```
			  E.code = gen('goto' E.true/false);
			  ```
		- `E → E1 or E2`：
			- 语义规则：
			  ```
			  E1.true = E.true;
			  E1.false = newlabel();
			  E2.true = E.true;
			  E2.false = E.false;
			  E.code = E1.code ||
			              label(E1.false) ||
			              E2.code;
			  ```
		- `E → E1 and E2`：
			- 语义规则：
			  ```
			  E1.true = newlabel();
			  E1.false = E.false;
			  E2.true = E.true;
			  E2.false = E.false;
			  E.code = E1.code ||
			              label(E1.true) ||
			              E2.code;
			  ```
		- `E → not E1`：
			- 语义规则：
			  ```
			  E1.true = E.false;
			  E1.false = E.true;
			  E.code = E1.code;
			  ```
		- `E → E1 relop E2`：
			- 语义规则：
			  ```
			  E.code = E1.code ||
			              E2.code ||
			              gen('if' E1.place relop E2.place 'goto' E.true) ||
			              gen('goto' E.false);
			  ```
			- 解释：`relop`为关系运算符，如`<, <=, >, >=, ==, !=`，如果`E1 relop E2`为真，跳转到`E.true`，否则跳转到`E.false` 
# 控制流语句
* 控制语句的类型：
	* `if-else`语句
	- `if-then-else`语句
	- `while-do`语句
	- `switch-case`语句
	- 顺序语句
- 语义属性：`S.next`执行完成后跳转的目标编号
- 翻译方案：
	- `if-then`语句：
		- 结构示意图：![[Pasted image 20251203151909.png]]
		- SDD：`S → if E then S1`：
		  ```
		  E.true = newlabel();
		  E.false = S.next;
		  S1.next = S.next;
		  S.code = E.code ||
		              label(E.true) ||
		              S1.code;
		  ```
	- `if-then-else`语句：
		- 结构示意图：![[Pasted image 20251203152254.png]]
		- SDD：`S → if E then S1 else S2`：
		  ```
		  E.true = newlabel();
		  E.false = newlabel();
		  S1.next = S.next;
		  S2.next = S.next;
		  S.code = E.code ||
		              gen(E.true ':') ||
		              S1.code ||
		              gen('goto' S.next) ||
		              gen(E.false ':') ||
		              S2.code;
		  ```
	- `while`语句：
		- 结构示意图：![[Pasted image 20251203152428.png]]
		- SDD：`S → while E do S1`：
		  ```
		  S.begin = newlabel();
		  E.true = newlabel();
		  E.false = S.next;
		  S1.next = S.begin;
		  S.code = gen(S.begin ':') ||
		              E.code ||
		              gen(E.true ':') ||
		              S1.code ||
		              gen('goto' begin);
		  ```
	- 顺序语句：
		- 结构示意图：![[Pasted image 20251203152517.png]]
		- SDD：`S → S1 ; S2`：
		  ```
		  S1.next = newlabel();
		  S2.next = S.next;
		  S.code = S1.code ||
		              gen(S1.next ':') ||
		              S2.code;
		  ```
	- `switch-case`语句：
		- 语句：`switch (E) case V1: S1; case V2: S2; ... ; case Vn-1: Sn-1; default: Sn;`
		- 分支数较少时，翻译成如下形式代码：
		  ```
			  t := E.code
			  if t != V1 goto L1
			  S1.code
			  goto next
		  L1: if t != V2 goto L2
			  S2.code
			  goto next
		  L2: ...
		  Ln-2: if t != Vn-1 goto Ln-1
			  Sn-1.code
			  goto next
		  Ln-1: Sn.code
			  next:
		  ```
		- 分支数较多时，将分支测试代码集中：
			```
				t := E.code
				goto test
			L1: S1.code
				goto next
			L2: S2.code
				goto next
			...
			Ln-1: Sn-1.code
				goto next
			Ln: Sn.code
				goto next
			test:
				if t == V1 goto L1
				if t == V2 goto L2
				...
				if t == Vn-1 goto Ln-1
				goto Ln
			next:
			```
	- 过程调用语句：
		- 语法形式：
			 ```
			 S → call id ( EList )
			 EList → EList , E
			 EList → E
			 ```
		- 翻译逻辑：
			- 计算每个参数的TAC，存入临时变量
			- 按参数顺序生成参数，传递参数地址
			- 生成call语句
		- SDD：
		  ```
		  # S → call id ( EList )
		  for each E in EList(length = n) do
		      emit('param' E.place);
		      emit('call' id.place, n);
		  
		  # EList → EList , E
		  push E.place to the end of queue
		  
		  # EList → E
		  initialize an empty queue
		  push E.place to the end of queue
		  ```
		- 例：![[Pasted image 20251203153448.png]]
# 拉链与代码回填
- 在前述的控制流SDD中，一系列语句标号的属性值计算，需要多遍扫描分析树。因此，需要定义
- 语义属性：
	- `E.truelist`：真链，链表中的元素表示一系列跳转语句的目标地址，体现布尔表达式`E`为真的跳转位置
	- `E.falselist`：假链，链表中的元素表示一系列跳转语句的目标地址，体现布尔表达式`E`为假的跳转位置
	- `S.nextlist`：下一链，链表中的元素表示一系列跳转语句的目标地址，体现语句`S`执行完成后下一条TAC语句的位置
- 语义函数：
	- `makelist(i)`：创建一个只有一个结点`i`的表，对应存放目标TAC语句数组的一个下标
	- `merge(list1, list2)`：合并两个链表，返回合并后的链表头指针
	- `backpatch(list, target)`：将链表`list`中的每个结点所指向的TAC语句的目标地址填充为`target`
	- `nextstm`：返回下一条TAC语句的地址
	- `emit(...)`：生成一条TAC语句，并使得`nextstm`的值加1
- 修正后的翻译方案：
	- `E → E1 or M E2`：
		- 语义规则：
		  ```
		  backpatch(E1.falselist, M.gotostm);
		  E.truelist := merge(E1.truelist, E2.truelist);
		  E.falselist := E2.falselist;
		  ```
	- `E → E1 and M E2`：
		- 语义规则：
		  ```
		  backpatch(E1.truelist, M.gotostm);
		  E.truelist := E2.truelist;
		  E.falselist := merge(E1.falselist, E2.falselist);
		  ```
	- `E → not E1`：
		- 语义规则：
		  ```
		  E.truelist := E1.falselist;
		  E.falselist := E1.truelist;
		  ```
	- `E → (E1)`：
		- 语义规则：
		  ```
		  E.truelist := E1.truelist;
		  E.falselist := E1.falselist;
		  ```
	- `E → id1 relop id2`：
		- 语义规则：
		  ```
		  E.truelist := makelist(nextstm);
		  E.falselist := makelist(nextstm + 1);
		  emit('if' id1.place relop.op id2.place 'goto' _);
		  emit('goto' _);
		  ```
	- `E → true`：
		- 语义规则：
		  ```
		  E.truelist := makelist(nextstm);
		  emit('goto' _);
		  ```
	- `E → false`：
		- 语义规则：
		  ```
		  E.falselist := makelist(nextstm);
		  emit('goto' _);
		  ```
	- `M → epsilon`：
		- 语义规则：
		  ```
		  M.gotostm := nextstm;
		  ```
- 示例：![[Pasted image 20251203155933.png]]
