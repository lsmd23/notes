# 中间代码概述
- 定义：中间代码是源程序的内部表示形式，介于源代码和目标代码之间
- 作用：
	- 避免源语言和目标语言的语义跨度，简化编译器设计
	- 便于编译程序重定向
	- 利于与目标机无关的优化
- 形式：
	- AST（Abstract Syntax Tree，抽象语法树）
	- DAG（Directed Acyclic Graph，有向无环图）
	- Postfix（后缀式，逆波兰表示法）
	- **TAC**（Three Address Code，**三地址码**）
		- 顺序的语句示例，格式为`X := Y op Z`，其中`op`为操作码，`Y`和`Z`为操作数，`X`为结果存储位置
		- 例：![[Pasted image 20251202141400.png]]
	- P-code（Pascal语言）
# 声明语句
- 目标：为声明语句建立符号表条目，分配存储单元并记录类型、地址等信息
- 途径：利用[[L4 语法制导的翻译|语法制导翻译]]，添加对应语义规则以生成中间代码
- 语义属性：
	-  `id.lexeme`：词法名（符号表内的标识符）
	- `T.type`：类型属性
	- `T.width`：数据宽度（字节数）
	- `offset`：相对基地址的下一个可用相对偏移地址（参考[[L5 符号表与运行时存储组织#运行时存储组织|运行时存储组织]]）
- 语义函数：
	- `put(id.lexeme, T.type, offset)`：将符号表中`id.lexeme`的类型设为`T.type`，地址设为当前`offset`
- 翻译方案：
	- `T → char`：`T.type = CHAR; T.width = 1`
	- `T → integer`：`T.type := integer; T.width := 4`
	- `T → real`：`T.type := real; T.width := 8`
	- `T → array [num] of T1`：`T.type := array(num.val, T1.type)`；` T.width := num.val × T1.width`（数组类型，宽度为元素个数 × 单个元素宽度）
	- `T → ↑T1`：`T.type := pointer(T1.type); T.width := 4`（指针类型，宽度固定为 4 字节）
	- `D → D1 ; D2`：先处理`D1`，再处理`D2`，共享`offset`变量更新存储偏移
	- `D → id: T`：`put(id.lexeme, T.type, offset); offset := offset + T.width`（为标识符分配地址并更新偏移）
# 赋值语句
- 语义属性：
	- `id.lexeme`：标识符的词法名
	- `E.code`：表达式`E`的TAC语句序列
	- `E.place`：存放表达式`E`结果的临时变量
- 语义函数：
	- `get(id.lexeme)`：从符号表中查找标识符`id.lexeme`，返回存放相应值的指针（无则返回NULL）
	- `gen(...)`：生成一条TAC语句
	- `newtemp()`：生成一个新的临时变量名并返回
- 翻译方案：
	- `E → (E1)`：
		- 语义规则：
		  ```
		  E.place = E1.place;
		  E.code = E1.code;
		  ```
		- 括号表达式，传递子表达式的结果和代码
	- `E → E1 op E2`： 
		- 语义规则：
			```
			E.place = newtemp();
			E.code = E1.code || E2.code ||
			            gen(E.place := E1.place op E2.place)
			```
		- 二元运算表达式，生成计算代码并存放结果
	- `E → op E1`：
		- 语义规则：
		  ```
		  E.place = newtemp();
		  E.code = E1.code ||
		              gen(E.place := op E1.place)
		  ```
		  - 一元运算表达式，生成计算代码并存放结果
	- `E → id`：
		- 语义规则：
		  ```
		  ptr = get(id.lexeme);
		  if ptr == NULL then error("undeclared variable");
		  E.place = ptr;
		  E.code = "";
		  ```
		- 标识符表达式，获取变量地址`
	- `S → id := E`：
		- 语义规则：
		  ```
		  ptr = get(id.lexeme);
		  if ptr == NULL then error("undeclared variable");
		  S.code = E.code ||
		              gen(ptr := E.place)
		  ```
		- 赋值语句，生成赋值操作的TAC代码
- 数组元素的地址计算：
	- 一维数组：首地址为`base`，下界为`low`，元素宽度为`w`，访问元素`A[i]`的地址计算为`addr = base + (i - low) * w`（常优化为`addr = i * w + (base - low * w)`，括号内可以在编译时计算）
	- 二维数组：`A[i][j]`
		- 列优先存储：
			- 按照`A[1,1], A[2,1], ..., A[m,1], A[1,2], A[2,2], ..., A[m,n]`顺序存储
			- 地址公式：`addr = base + ((j - low2) * row_size + (i - low1)) * w`，其中`row_size`为每行元素个数
		- 行优先存储：
			- 按照`A[1,1], A[1,2], ..., A[1,n], A[2,1], A[2,2], ..., A[m,n]`顺序存储
			- 地址公式：`addr = base + ((i - low1) * col_size + (j - low2)) * w`，其中`col_size`为每列元素个数
	- 多维数组：`A[i1][i2]...[ik]`
		- 地址公式为：`((...((i1 × n2 + i2) × n3 + i3)...) × nk + ik) × w + base - ((...((low1 × n2 + low2) × n3 + low3)...) × nk + lowk) × w`（其中`ni`为第`i`维的大小，`lowi`为第`i`维的下界）
	- 数组的内情向量（dope vector）：
		- 处理数组时，常将有关信息记录在某些单元中，称之为内情向量
			- 静态数组存放在符号表中
			- 动态数组在运行时建立内情向量
		- 例：对于数组`A[l1:u1,l2:u2,...,ln,un]`，内情向量包含：
			- 每维的下界`li`和上界`ui`
			- `type`：元素类型
			- `base`：数组首地址
			- `n`：数组维数
			- `C`：编译期常量，用于地址计算优化
		- 地址计算：对于上述的静态数组，元素`A[i1,i2,...,in]`的地址计算为：$$\begin{align*} D = & \text{base} + (i_1-l_1)(u_2-l_2+1)(u_3-l_3+1)\cdots(u_n-l_n+1)  \\ & + (i_2-l_2)(u_3-l_3+1)(u_4-l_4+1)\cdots(u_n-l_n+1) \\ & + \cdots \\ & + (i_{n-1}-l_{n-1})(u_n-l_n+1) \\ & + (i_n - l_n)  \end{align*}$$也即$D = \text{base}-C+V$，其中：$$C = ( \dots ( ( ( l_1 (u_2 - l_2 + 1) + l_2 ) (u_3 - l_3 + 1) + l_3 ) (u_4 - l_4 + 1) + \dots + l_{n-1} ) (u_n - l_n + 1) + l_n$$是静态可计算的，$$ V = ( \dots ( ( ( i_1 (u_2 - l_2 + 1) + i_2 ) (u_3 - l_3 + 1) + i_3 ) (u_4 - l_4 + 1) + \dots + i_{n-2} ) (u_n - l_n + 1) + i_n $$
- 类型转换：
# 布尔表达式


# 控制流语句

# 拉链与代码回填

