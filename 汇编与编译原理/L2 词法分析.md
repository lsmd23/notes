- 词法分析器：在编译器中负责将源代码转换为标记（tokens）的组件
	- 负责处理一个输入的字符流，并将其分解为有意义的符号，并构建一个符号表
# 词法分析的作用
- 词法分析中的概念：
	- **词法单元(token)**：由词法单元名称和属性值组成的对
		- 词法单元是编程语言中的最小有意义单位，通常包括关键字、标识符、常量、运算符和分隔符等
	- **词素**：词法单元的实例
		- 词素是源代码中的实际字符序列，对应于特定的词法单元
	- **模式**：描述词素结构的规则
		- 模式通常使用**正则表达式**来定义，用于匹配源代码中的词素
		- 例：
			- 关键字if的模式是"if"
			- 标识符的模式是字母后跟零个或多个字母或数字，也即正则表达式`[a-zA-Z][a-zA-Z0-9]*`
			- 整数常量的模式是一个或多个数字
	- 例：![[Pasted image 20250930102702.png]]
- 词法错误：
	- 词法错误是指在源代码中出现了不符合语言词法规则的字符序列
	- 例：标识符不能以数字开头，如果出现这样的情况，就会被识别为词法错误
	- 一般而言，词法错误是比较少的，在词法分析的阶段，很难发现一些很明显的语法错误
		- 例：`fi(a==f(x))`中，很难确认`fi`是关键字`if`的拼写错误，还是一个新的标识符
# 词法单元的归约
- [[形式语言与自动机/L0 绪论#形式语言基础|串]]和[[形式语言与自动机/L0 绪论#语言运算|语言及其运算]]
- [[L3 正则语言与正则表示#正则表示|正则表达式]]
- 正则定义：具有如下形式的定义序列
	- $d_1\rightarrow r_1$
	- $d_2\rightarrow r_2$
	- ...
	- $d_n\rightarrow r_n$
	- 其中，$d_i$是一个新的名字，称为定义名，$r_i$是一个正则表达式
	- 例：$$\begin{align}\text{digit}\rightarrow 0|1|2|3|4|5|6|7|8|9\\ \text{id}\rightarrow \text{letter}(\text{letter}|\text{digit})^*\\\text{letter}\rightarrow a|b|...|z|A|B|...|Z \end{align}$$
# 词法单元的识别
- 词法单元的识别是将输入的字符流转换为词法单元序列的过程
- **状态转换图**：一个自动机，表示词法识别的过程
	- 以每个词素为输入，通过状态转换图，最终到达一个终态，输出对应的词法单元
	- 例：
		- relop词法单元的状态转换图：![[Pasted image 20250930141542.png]]
		- digit词法单元的状态转换图：![[Pasted image 20250930141805.png]]
- 有限自动机：
	- [[L1 确定有限自动机(DFA)|确定有限自动机]]
	- [[L2 非确定有限自动机(NFA)|非确定有限自动机]]
# 从正则表达式到自动机
- 通用方法：正则表示 $\rightarrow$ NFA $\rightarrow$ DFA
- 基于DFA的优化：从正则表达式可以直接构建DFA：
	- 正则表达式的抽象语法树：
		- 通过递归下降的方式，从正则表达式构建其抽象语法树
		- 扩展的正则表达式：如上，在正则表达式的最后加上一个特殊符号`#`，表示字符串的结束，用新的正则表达式构建对一个的抽象语法树
		- 节点的编号：对叶节点，从左到右依次编号，代表节点的位置
		- 例：![[Pasted image 20250930145507.png]]
	- 计算每个节点的属性：
		- `nullable(n)`：表示节点`n`是否可以生成空串
			- 计算方式：
				1. 对叶子节点：若为$\epsilon$则为`true`，否则`false`
				2. 对`|`节点：若任一子节点为`true`，则为`true`，否则为`false`
				3. 对`.`节点：若所有子节点均为`true`，则为`true`，否则为`false`
				4. 对`*`节点：恒为`true`
		- `firstpos(n)`：节点`n`可以生成的字符串的第一个位置集合
			- 计算方式：
				1. 对叶子节点：位置`p`的`firstpos`为`{p}`，$\epsilon$的`firstpos`为空集
				2. 对`|`节点：`firstpos`为所有子节点的`firstpos`的并集
				3. 对`.`节点：若左子节点可生成空串，则`firstpos`为左子节点和右子节点的`firstpos`的并集，否则为左子节点的`firstpos`
				4. 对`*`节点：`firstpos`为子节点的`firstpos`
		- `lastpos(n)`：节点`n`可以生成的字符串的最后一个位置集合
			- 计算方式：
				1. 对叶子节点：位置`p`的`lastpos`为`{p}`，$\epsilon$的`lastpos`为空集
				2. 对`|`节点：`lastpos`为所有子节点的`lastpos`的并集
				3. 对`.`节点：若右子节点可生成空串，则`lastpos`为左子节点和右子节点的`lastpos`的并集，否则为右子节点的`lastpos`
				4. 对`*`节点：`lastpos`为子节点的`lastpos`
		- 例：![[Pasted image 20251003181026.png]]
		- `followpos(p)`：位置`p`后面可能跟随的位置集合
			- 计算方式：
				1. 对`.`节点：对左子节点的每个位置`i`，将右子节点的`firstpos`加入`followpos(i)`中
				2. 对`*`节点：对子节点的每个位置`i`，将子节点的`firstpos`加入`followpos(i)`中
				3. 对其他节点：不做处理
				- 例：打表计算![[Pasted image 20251003181110.png]]
	- 构建DFA：
		- 状态：DFA的每个状态对应一个位置集合
		- 初态：抽象语法树根节点的`firstpos`
		- 终态：包含特殊位置`#`的状态
		- 转移：对每个状态`S`，对于每个输入符号`a`，计算所有位置`p`，其中`p`属于`S`且符号为`a`，将这些位置的`followpos(p)`的并集作为新的状态
		- 例：![[Pasted image 20251003181215.png]]
- 对DFA的优化：参考[[L5 正则语言的判定性质与DFA的优化#DFA的优化|形式语言与自动机——DFA的优化]]
# 词法分析的工具
- Lex工具：
	- Lex是一种用于生成词法分析器的工具
	- 通过定义词法单元的模式和相应的动作，Lex可以自动生成一个C语言的词法分析器
		- 例：![[Pasted image 20251003181751.png]]
- ANTLR工具：
	- ANTLR（Another Tool for Language Recognition）是一种强大的语法分析器生成工具
	- 它不仅可以生成词法分析器，还可以生成语法分析器，支持多种编程语言