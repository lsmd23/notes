# 语法分析的基本思想
- 语法分析程序：分析词法分析器生成的记号流，判断其是否符合语言的语法规则，并构建相应的语法树或抽象语法树（AST）
- 语法规则的描述：通常使用上下文无关文法（CFG）来描述语言的语法规则
- 语法分析：也即句型分析，对上下文无关文法作[[L6 上下文无关文法(CFG)#归约与推导|推导]]
	- 通用分析：Cocke-Younger-Kasami (CYK)算法
	- [[L3 语法分析#自顶向下的分析|自顶向下分析]]
	- [[L3 语法分析#自底向上的分析|自底向上分析]]
# 自顶向下的分析
- 思想：从开始符合推导，最终产生符合期望的句子。若无法得到期望的句子，则分析失败，表明存在语法错误
	- 例：![[Pasted image 20251014133444.png]]
	- 一般的方法有较高的复杂度，每一步需要选择产生式和推导的终结符
- 最左推导：每一步都选择最左边的非终结符进行推导，解决推导终结符的不确定性问题
	- 结合回溯，可以完成推导的过程
	- 例：![[Pasted image 20251014133642.png]]
## 预测分析
- 通过“预测”，也即向前查看确定数目的单词，得到唯一的最左推导
- 问题：对某些序列，向前查看的单词数目是不确定的
	- 例：需要向前查看2个单词![[Pasted image 20251014133845.png]]需要向前查看$n+1$个单词![[Pasted image 20251014134129.png]]
- 如果想确定这个问题，需要文法满足固定的条件，常用的是LL(1)文法（不含左递归且左因子化）
## LL(1)文法
- LL(1)文法：一种特殊的上下文无关文法，适合使用预测分析法进行语法分析
	- 第一个L：表示从左到右扫描输入符号
	- 第二个L：表示采用最左推导
	- 1：表示在预测时只需要查看一个输入符号
- **First集合**：
	- 定义：设上下文无关文法$G=(V_T,V_N,S,P)$，对于任何符号串$\alpha\in (V_T\cup V_N)^*$，其First集合定义为：$$\text{First}(\alpha) = \{a | \alpha \Rightarrow^* a\beta, a \in V_T, \beta \in (V_T \cup V_N)^*\}$$此外，若$\alpha \Rightarrow^* \epsilon$，则$\epsilon \in \text{First}(\alpha)$
		- 非形式化地，First集合表示符号串$\alpha$可以推导出的所有可能的第一个终结符
	- 计算方法：
		- 设$\alpha=X\in (V_T\cup V_N)$，则：
			1. 若$X\in V_T$，则$\text{First}(X)=\{X\}$
			2. 若有产生式$X\rightarrow \epsilon$，则$\epsilon \in \text{First}(X)$
			3. 若$X\in V_N$，且有产生式$X\rightarrow a\cdots,a\in V_T$，则$a\in \text{First}(X)$
			4. 若$X\in V_N$，且有产生式$X\rightarrow Y_1Y_2\cdots Y_k,Y_i\in (V_T\cup V_N)$
				1. 对任何的$j:1\leq j\leq i-1,1\leq i\leq k$，若$\epsilon \in \text{First}(Y_j)$，但$\text{First}(Y_i)$不含有$\epsilon$，则将$\text{First}(Y_j)$中的所有非$\epsilon$元素和$\text{First}(Y_i)$中所有元素加入$\text{First}(X)$中
				2. 若对所有的$j:1\leq j\leq k$，$\epsilon \in \text{First}(Y_j)$，则除$\text{First}(Y_j)$中的所有非元素外，将$\epsilon$加入$\text{First}(X)$中
		- 设$\alpha=X_1X_2\cdots X_k,X_i\in (V_T\cup V_N)$，则：
			1. 若对任何的$j:1\leq j\leq i-1<k$，有$\epsilon \in \text{First}(X_j)\wedge \epsilon\notin\text{First}(X_i)$，则$\text{First}(\alpha)=\bigcup_{j=1}^i\text{First}(X_j)-\{\epsilon\}$
			2. 若对所有的$j:1\leq j\leq k$，$\epsilon \in \text{First}(X_j)$，则$\text{First}(\alpha)=\bigcup_{j=1}^k\text{First}(X_j)$
- **Follow集合**：
	- 定义：设上下文无关文法$G=(V_T,V_N,S,P)$，对于任何非终结符$A\in V_N$，其Follow集合定义为：$$\text{Follow}(A) = \{a | S \Rightarrow^* \alpha A \beta, a \in \text{First}(\beta), \alpha\in (V_T \cup V_N)^*, \beta \in (V_T \cup V_N)^+\}$$此外，若$S \Rightarrow^* \alpha A\beta$，且$\beta \Rightarrow^*\epsilon$则规定$\#\in\text{Follow}(A)$，其中$\#$表示输入的结束符
		- 非形式化地，Follow集合表示非终结符$A$后面可能跟随的所有终结符
	- 计算方法：
		1. 将$\#$加入$\text{Follow}(S)$中，其中$S$为开始符号
		2. 对每个产生式$A\rightarrow \alpha B\beta$，将$\text{First}(\beta)-\{\epsilon\}$中的所有元素加入$\text{Follow}(B)$中
		3. 对每个产生式$A\rightarrow \alpha B$或$A\rightarrow \alpha B\beta(\beta\Rightarrow^*\epsilon)$（也即$\epsilon \in \text{First}(\beta)$），则将$\text{Follow}(A)$中的所有元素加入$\text{Follow}(B)$中
- **定义**：文法G是LL(1)文法当且仅当
	1. 对任何两个产生式$A\rightarrow \alpha | \beta$，有$\text{First}(\alpha)\cap \text{First}(\beta)=\emptyset$，也即$\alpha$和$\beta$不能同时推导出以同一个终结符开头的字符串，也不能同时推导出$\epsilon$
	2. 若$\beta\Rightarrow^*\epsilon$，则$\text{First}(\alpha)\cap \text{Follow}(A)=\emptyset$，即$\alpha$所能推出的串的首符号不能出现在$A$的Follow集合中
- 性质：
	- LL(1)文法**不含有左递归**
	- LL(1)文法是**无左公因子**的
	- LL(1)文法是**无二义性**的
### 递归下降LL(1)分析
- 原理：每个非终结符对应一段子程序
	- 每遇到一个终结符，判断当前输入符号是否匹配，若匹配则继续，否则报错
	- 每遇到一个非终结符，调用对应的子程序
	- 例：![[Pasted image 20251014141239.png]]![[Pasted image 20251014141315.png]]
	- 一般结构：对产生式：$A\rightarrow u_1|u_2|\cdots$，则子程序结构为：
```
void ParseA()
{
	switch (lookahead) {
		case First(u1):
			/* code to recognize u1 */
			break;
		case First(u2):
			/* code to recognize u2 */
			break;
	...
		case Follow(A): /* when A can derive ε */
			/* usually do nothing here */
			break;
		default:
			printf("syntax error \n");
			exit(0);
	}
}
```
- *示例文法分析程序*：
	- 文法：$$\begin{align}S&\rightarrow AaS|BbS|d \\ A&\rightarrow a\\ B&\rightarrow \epsilon |c\end{align}$$ ^7e4ac2
	- First和Follow集合：
		- $\text{First}(S)=\{a,b,c,d\}$
		- $\text{First}(A)=\{a\}$
		- $\text{First}(B)=\{\epsilon,c\}$
		- $\text{Follow}(S)=\{\#\}$
		- $\text{Follow}(A)=\{a\}$
		- $\text{Follow}(B)=\{b\}$
	- 文法判断：
		- $\text{First}(AaS)=\{a\}$, $\text{First}(BbS)=\{b,c\}$, $\text{First}(d)=\{d\}$，互不相交
		- $\text{Follow}(B)=\{b\}$, $\text{First}(c)=\{c\}$, 互不相交
		- 因此是LL(1)文法
	- 分析程序：
```
void ParseS( )
{
	switch (lookahead) {
		case a:
			ParseA( );
			MatchToken(a);
			ParseS( );
			break;
		case b,c:
			ParseB( );
			MatchToken(b);
			ParseS( );
			break;
		case d:
			MatchToken(d);
			break;
		default:
			printf("syntax error \n")
			exit(0);
	}
}

void ParseA( )
{
	if (lookahead == a) {
		MatchToken(a);
	} else {
		printf("syntax error \n");
		exit(0);
	}
}

void ParseB()
{
	if (lookahead==c) {
		MatchToken(c);
	}
	else if (lookahead==b) {
		/* do nothing, B -> ε */
	}
	else {
		printf("syntax error \n");
		exit(0);
	}
}
```
### 表驱动LL(1)分析
- 原理：利用预测分析表和一个下推栈实现
	1. 初始化，将符号$\#$压入栈中
	2. 将开始符号压入栈中
	3. 若栈顶为终结符，则判断读入的单词是否匹配
		1. 若匹配，读入下一个单词
		2. 若不匹配，报错
	4. 若栈顶为非终结符$A$，则查预测分析表$M[A,a]$，其中$a$为当前读入的单词
		1. 若$M[A,a]$为空，报错
		2. 若对应的表项中有唯一的产生式，则将$A$弹出栈，并将产生式右部的符号串逆序压入栈中
	5. 重复3-4，直到栈顶为$\#$且输入符号也为$\#$时，分析成功
	* 分析算法：![[Pasted image 20251014145242.png]]
- 预测分析表：一个二维的表$M$
	- 表每一行对应一个非终结符
	- 表每一列对应一个终结符（包括结束符$\#$）
	- 表项$M[A,a]$表示栈顶为非终结符$A$且当前输入符号为$a$时所使用的产生式，表项为空表示出错
	- 对LL(1)文法，预测分析表每个表项最多只有一个产生式
- 预测分析表的构造算法：
	- 产生式$A\rightarrow \alpha$，执行下列步骤：
		1. 对每个$a\in \text{First}(\alpha)$，将产生式$A\rightarrow \alpha$加入$M[A,a]$
		2. 若$\epsilon \in \text{First}(\alpha)$，则对每个$b\in \text{Follow}(A)$，将产生式$A\rightarrow \alpha$加入$M[A,b]$
	- 对空余的表项，填入错误标记
	- 对LL(1)文法，预测分析表每个表项最多只有一个产生式
- 例：对上述[[L3 语法分析#^7e4ac2|文法]]
	- 构造预测分析表
		- ![[Pasted image 20251014145150.png]]
	- 分析过程：格式——（栈，剩余字符串），左侧为栈顶：以输入串aabd为例$$\begin{align}(S\#,aabd\#) &\rightarrow (AaS\#,aabd\#) \\ &\rightarrow (aaS\#,aabd\#) \\&\rightarrow (aS\#,abd\#)\\&\rightarrow (S\#,bd\#)\\&\rightarrow (BbS\#,bd\#)\\&\rightarrow(bS\#,bd\#)\\&\rightarrow(S\#,d\#)\\&\rightarrow(d\#,d\#)\\&\rightarrow(\#,\#)\end{align}$$
## 文法变换
- 将其他类型的文法转换为LL(1)文法
	- 文法在消除左递归，提取左公因子后，有可能转化为LL(1)文法
	- 并非所有文法都能转化为LL(1)文法
- 消除左递归：
	- 直接左递归：
		1. 形如$A\rightarrow A\alpha|\beta$的产生式，其中$\alpha$非$\epsilon$且不以$P$开头，可以改写为：$$\begin{align}A&\rightarrow \beta A' \\ A'&\rightarrow \alpha A'|\epsilon\end{align}$$
		2. 更一般地，形如$A\rightarrow A\alpha_1|A\alpha_2|\cdots|A\alpha_m|\beta_1|\beta_2|\cdots|\beta_n$的产生式，其中$\alpha_i(i=1,2,\cdots,m)$非$\epsilon$且不以$A$开头，$\beta_j(j=1,2,\cdots,n)$非$\epsilon$且不以$A$开头，可以改写为：$$\begin{align}A&\rightarrow \beta_1 A'|\beta_2 A'|\cdots|\beta_n A' \\ A'&\rightarrow \alpha_1 A'|\alpha_2 A'|\cdots|\alpha_m A'|\epsilon\end{align}$$
	- 一般左递归：对无回路（$A\Rightarrow^+A$），且没有$\epsilon$产生式的文法，可以通过下列步骤消除一般的左递归
		1. 将所有非终结符排序为$A_1,A_2,\cdots,A_n$
		2. 对$i$从1到$n$，执行下列步骤：
			1. 对$j$从1到$i-1$，将所有形如$A_i\rightarrow A_j\gamma$的产生式替换为$A_i\rightarrow \delta_1\gamma|\delta_2\gamma|\cdots|\delta_k\gamma$，其中$A_j\rightarrow \delta_1|\delta_2|\cdots|\delta_k$是文法中所有以$A_j$为左部的产生式
			2. 消除所有形如$A_i\rightarrow A_i\alpha|\beta$的直接左递归
		3. 对得到的文法进行化简
- 提取左公因子：
	- 对形如$P\rightarrow \alpha\beta|\alpha\gamma$的一对产生式，可以改写为：$$\begin{align}P&\rightarrow \alpha P' \\ P'&\rightarrow \beta|\gamma\end{align}$$
	- 更一般地，对形如$P\rightarrow \alpha\beta_1|\alpha\beta_2|\cdots|\alpha\beta_n|\gamma_1|\gamma_2|\cdots|\gamma_m$的一组产生式，其中$\beta_i(i=1,2,\cdots,n)$非$\epsilon$且不以$\alpha$开头，$\gamma_j(j=1,2,\cdots,m)$非$\epsilon$且不以$\alpha$开头，可以改写为：$$\begin{align}P&\rightarrow \alpha P'|\gamma_1|\gamma_2|\cdots|\gamma_m \\ P'&\rightarrow \beta_1|\beta_2|\cdots|\beta_n\end{align}$$
	- 例：![[Pasted image 20251014164425.png]]
## 预测分析中的错误处理
- 表驱动分析的错误报告：
	- 当栈顶为终结符且与当前输入符号不匹配时，报告错误
	- 当栈顶为非终结符$A$且预测分析表$M[A,a]$为空时，报告错误
- 错误恢复策略：
	- 简单的应急恢复（panic-mode error recovery）：跳过输入串中的一些符号直至遇到同步符号（synchronizing token）为止
	- 同步符号的选择：
		- 把$\text{Follow}(A)$中的所有符号作为A的同步符号, 跳过输入串中的一些符号直至遇到这些“同步符号”，把A从栈中弹出，可使分析继续
		- 把$\text{First}(A)$中的符号加到A的同步符号集，当$\text{First}(A)$中的符号在输入中出现时，可根据A恢复分析
# 自底向上的分析
- 一般过程：
	- 从终结符串开始归约
	- 每步归约，找到对应的某子串，然后将子串替换为对应的非终结符；若无法找到对应的子串，则回溯重试
	- 最终归约为开始符号，分析成功；否则分析失败
- 自底向上分析的问题：
	- 每一步归约时，可能存在多个子串可供选择，也有多个产生式可供选择
	- 解决：使用最左归约，并采用移进-归约分析法等方法
	- **句柄**：对文法$G=(V_T,V_N,S,P)$，以及$\alpha,\gamma\in (V_T\cup V_N)^*$，$\beta\in V_T^*$，若$S\Rightarrow^* \alpha A \gamma$且$A\rightarrow \gamma$，则称$\gamma$为右句型$\alpha \gamma\beta$的相对于非终结符$A$的一个句柄
		- 非形式化地，句柄是当前字符串中可以被归约的子串
		- 例：![[Pasted image 20251021134123.png]]
		- 句柄不一定是唯一的，对二义性文法，同一句型可能有多个句柄
- 实现技术：移进-归约分析
	- LR分析
	- 算符优先分析
- 特点：
	- 功能强大，在处理时关注整体的句型结构
	- 构造复杂，需要借助自动机等工具
## 移进-归约分析
- 基本原理：
	- 使用最左归约进行自底向上的分析
	- 借助一个确定的[[L7 下推自动机(PDA)|下推自动机]]实现，包括一个下退栈（分析栈）和一个有限状态控制器
	- 工作流程：
		- Reduce：依确定的产生式序列对栈顶进行归约
		- Shift：将下一个输入符号移入栈中
		- Accept：分析成功
		- Error：发现错误，进行错误处理/恢复
	- 例：![[Pasted image 20251021134640.png]]成功分析的结果对应一个最右推导，每次推导都是对一个句柄进行替换
- 问题：两类冲突
	- 移进-归约冲突（shift-reduce conflict）：在某状态下，既可以进行移进操作，也可以进行归约操作
		- 例：对文法$S\rightarrow \text{if}\ E\ \text{then}\ S|\text{if}\ E\ \text{then}\ S\ \text{else}\ S$，分析输入串$\text{if}\ E\ \text{then}\ \text{if}\ E\ \text{then}\ S\ \text{else}\ S$时，在分析到第一个else前，既可以进行移进操作，也可以进行归约操作
	- 归约-归约冲突（reduce-reduce conflict）：在某状态下，可以对栈顶进行多种不同的归约操作
		- 例：对文法$S\rightarrow aA|aaA$，对栈顶$aaA$进行分析时，可以有两种归约方式
	- 解决：使用表驱动的方法构造分析引擎
### LR分析
- 含义：
	- L：**从左到右扫描输入**符号
	- R：采用**最右推导**的逆序进行归约
- 表驱动的移进-归约分析：![[Pasted image 20251021140214.png]]
- 技术：
	- LR(0)分析：适用于所有的LR(0)文法
	- SLR(1)分析：适用于所有的SLR(1)文法
	- LR(1)分析：适用于所有的LR(1)文法
	- LALR(1)分析：适用于所有的LALR(1)文法
- 分析表：
	- 动作表（Action Table）：在栈顶状态为k，输入符号为a时，表的动作，表示为：$\text{ACTION}[k,a]=...$
	- 转移表（Goto Table）：依产生式$A\rightarrow \beta$归约后，栈顶状态为$i$时的动作，表示为：$\text{GOTO}[i,A]=...$
	- 例：![[Pasted image 20251021140503.png]]
#### LR(0)自动机
- **LR(0)项目**：对文法$G=(V_T,V_N,S,P)$，LR(0)项目是形如$A\rightarrow \alpha . \beta$的产生式，其中$A\rightarrow \alpha \beta \in P$，$\alpha,\beta\in (V_T\cup V_N)^*$
	- “圆点”表示分析器在该产生式中的位置，点左侧的符号已经被分析，点右侧的符号尚未被分析
	- **内核项**：圆点不在最左端的项目
	- **非内核项**：圆点在最左端的项目
- 拓广文法：对文法$G=(V_T,V_N,S,P)$，其拓广文法为$G'=(V_T,V_N\cup \{S'\},S',P\cup \{S'\rightarrow S\})$，其中$S'$为新的开始符号
	- 拓广文法和原文法完全等价
	- 拓广文法的开始符不会出现在任何产生式的右部
	- **$S'\rightarrow .S$是内核项**
	- 由拓广文法可以构造出LR(0)自动机
- LR(0)自动机：
	- 概念：
		- 每个上下文无关文法都可以构造出一个LR(0)自动机
		- 文法$G=(V_T,V_N,S,P)$的LR(0)自动机是一个字母表为$V_T\cup V_N$的确定有限自动机，该自动机的语言为$G$的所有活前缀的集合
	- 构造：
		- 状态：LR(0)项目集的闭包
			- 计算算法：![[Pasted image 20251021141454.png]]

#### SLR(1)分析


#### LR(1)分析


#### LALR(1)分析

