# 语法分析的基本思想
- 语法分析程序：分析词法分析器生成的记号流，判断其是否符合语言的语法规则，并构建相应的语法树或抽象语法树（AST）
- 语法规则的描述：通常使用上下文无关文法（CFG）来描述语言的语法规则
- 语法分析：也即句型分析，对上下文无关文法作[[L6 上下文无关文法(CFG)#归约与推导|推导]]
	- 通用分析：Cocke-Younger-Kasami (CYK)算法
	- [[L3 语法分析#自顶向下的分析|自顶向下分析]]
	- 自底向上分析
# 自顶向下的分析
- 思想：从开始符合推导，最终产生符合期望的句子。若无法得到期望的句子，则分析失败，表明存在语法错误
	- 例：![[Pasted image 20251014133444.png]]
	- 一般的方法有较高的复杂度，每一步需要选择产生式和推导的终结符
- 最左推导：每一步都选择最左边的非终结符进行推导，解决推导终结符的不确定性问题
	- 结合回溯，可以完成推导的过程
	- 例：![[Pasted image 20251014133642.png]]
# 预测分析
- 通过“预测”，也即向前查看确定数目的单词，得到唯一的最左推导
- 问题：对某些序列，向前查看的单词数目是不确定的
	- 例：需要向前查看2个单词![[Pasted image 20251014133845.png]]需要向前查看$n+1$个单词![[Pasted image 20251014134129.png]]
- 如果想确定这个问题，需要文法满足固定的条件，常用的是LL(1)文法（不含左递归且左因子化）
# LL(1)文法
- LL(1)文法：一种特殊的上下文无关文法，适合使用预测分析法进行语法分析
	- 第一个L：表示从左到右扫描输入符号
	- 第二个L：表示采用最左推导
	- 1：表示在预测时只需要查看一个输入符号
- **First集合**：
	- 定义：设上下文无关文法$G=(V_T,V_N,S,P)$，对于任何符号串$\alpha\in (V_T\cup V_N)^*$，其First集合定义为：$$\text{First}(\alpha) = \{a | \alpha \Rightarrow^* a\beta, a \in V_T, \beta \in (V_T \cup V_N)^*\}$$此外，若$\alpha \Rightarrow^* \epsilon$，则$\epsilon \in \text{First}(\alpha)$
		- 非形式化地，First集合表示符号串$\alpha$可以推导出的所有可能的第一个终结符
	- 计算方法：
		- 设$\alpha=X\in (V_T\cup V_N)$，则：
			1. 若$X\in V_T$，则$\text{First}(X)=\{X\}$
			2. 若有产生式$X\rightarrow \epsilon$，则$\epsilon \in \text{First}(X)$
			3. 若$X\in V_N$，且有产生式$X\rightarrow a\cdots,a\in V_T$，则$a\in \text{First}(X)$
			4. 若$X\in V_N$，且有产生式$X\rightarrow Y_1Y_2\cdots Y_k,Y_i\in (V_T\cup V_N)$
				1. 对任何的$j:1\leq j\leq i-1,1\leq i\leq k$，若$\epsilon \in \text{First}(Y_j)$，但$\text{First}(Y_i)$不含有$\epsilon$，则将$\text{First}(Y_j)$中的所有非$\epsilon$元素和$\text{First}(Y_i)$中所有元素加入$\text{First}(X)$中
				2. 若对所有的$j:1\leq j\leq k$，$\epsilon \in \text{First}(Y_j)$，则除$\text{First}(Y_j)$中的所有非元素外，将$\epsilon$加入$\text{First}(X)$中
		- 设$\alpha=X_1X_2\cdots X_k,X_i\in (V_T\cup V_N)$，则：
			1. 若对任何的$j:1\leq j\leq i-1<k$，有$\epsilon \in \text{First}(X_j)\wedge \epsilon\notin\text{First}(X_i)$，则$\text{First}(\alpha)=\bigcup_{j=1}^i\text{First}(X_j)-\{\epsilon\}$
			2. 若对所有的$j:1\leq j\leq k$，$\epsilon \in \text{First}(X_j)$，则$\text{First}(\alpha)=\bigcup_{j=1}^k\text{First}(X_j)$
- **Follow集合**：
	- 定义：设上下文无关文法$G=(V_T,V_N,S,P)$，对于任何非终结符$A\in V_N$，其Follow集合定义为：$$\text{Follow}(A) = \{a | S \Rightarrow^* \alpha A \beta, a \in \text{First}(\beta), \alpha\in (V_T \cup V_N)^*, \beta \in (V_T \cup V_N)^+\}$$此外，若$S \Rightarrow^* \alpha A\beta$，且$\beta \Rightarrow^*\epsilon$则规定$\#\in\text{Follow}(A)$，其中$\#$表示输入的结束符
		- 非形式化地，Follow集合表示非终结符$A$后面可能跟随的所有终结符
	- 计算方法：
		1. 将$\#$加入$\text{Follow}(S)$中，其中$S$为开始符号
		2. 对每个产生式$A\rightarrow \alpha B\beta$，将$\text{First}(\beta)-\{\epsilon\}$中的所有元素加入$\text{Follow}(B)$中
		3. 对每个产生式$A\rightarrow \alpha B$或$A\rightarrow \alpha B\beta(\beta\Rightarrow^*\epsilon)$（也即$\epsilon \in \text{First}(\beta)$），则将$\text{Follow}(A)$中的所有元素加入$\text{Follow}(B)$中
- **定义**：文法G是LL(1)文法当且仅当
	1. 对任何两个产生式$A\rightarrow \alpha | \beta$，有$\text{First}(\alpha)\cap \text{First}(\beta)=\emptyset$，也即$\alpha$和$\beta$不能同时推导出以同一个终结符开头的字符串，也不能同时推导出$\epsilon$
	2. 若$\beta\Rightarrow^*\epsilon$，则$\text{First}(\alpha)\cap \text{Follow}(A)=\emptyset$，即$\alpha$所能推出的串的首符号不能出现在$A$的Follow集合中
- 性质：
	- LL(1)文法**不含有左递归**
	- LL(1)文法是**无左公因子**的
	- LL(1)文法是**无二义性**的
## 递归下降LL(1)分析
- 原理：每个非终结符对应一段子程序
	- 每遇到一个终结符，判断当前输入符号是否匹配，若匹配则继续，否则报错
	- 每遇到一个非终结符，调用对应的子程序
	- 例：![[Pasted image 20251014141239.png]]![[Pasted image 20251014141315.png]]
	- 一般结构：对产生式：$A\rightarrow u_1|u_2|\cdots$，则子程序结构为：
```
void ParseA()
{
	switch (lookahead) {
		case First(u1):
			/* code to recognize u1 */
			break;
		case First(u2):
			/* code to recognize u2 */
			break;
	...
		case Follow(A): /* when A can derive ε */
			/* usually do nothing here */
			break;
		default:
			printf("syntax error \n");
			exit(0);
	}
}
```
- *示例文法分析程序*：
	- 文法：$$\begin{align}S&\rightarrow AaS|BbS|d \\ A&\rightarrow a\\ B&\rightarrow \epsilon |c\end{align}$$
	- First和Follow集合：
		- $\text{First}(S)=\{a,b,c,d\}$
		- $\text{First}(A)=\{a\}$
		- $\text{First}(B)=\{\epsilon,c\}$
		- $\text{Follow}(S)=\{\#\}$
		- $\text{Follow}(A)=\{a\}$
		- $\text{Follow}(B)=\{b\}$
		- 
## 表驱动LL(1)分析