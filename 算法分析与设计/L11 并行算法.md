# 分支-合并并行算法
- 要点：
	- 派生：允许程序在允许时进行“fork”，也即在运行时创建并行的子程序
	- 并行循环：允许循环并行执行
- 并行斐波那契数列算法：
	- 串行递归算法：![[Pasted image 20250603083124.png]]复杂度$\Theta(\phi^n)$
	- 并行算法：![[Pasted image 20250603083233.png]]
		- 图模型：分别标记派生、计算与返回的节点，构成一个有向无环图，为Pert图![[Pasted image 20250603083820.png]]在图上运行关键路径算法，即可得到程序运行的时间（在可以无限并行的理想情况下）
	- 记$T_n$为$n$个并行线程下算法的时间，则有：
		- $T_p\leq \frac{T_1}{P}$
		- $T_p\geq T_\infty$
		- 算法的加速比为$\frac{T_1}{T_p}$，当$\frac{T_1}{T_p}=\Theta(P)$时，称为线性加速，线性系数为1时即为完美线性加速
		- 松弛度：$\frac{T_1}{T_\infty P}$，松弛度递增时，算法趋近于完美线性加速算法，因此，设计算法时需要尽可能减小$T_\infty$
- 并行算法的调度：
	- 调度器应当知晓目前计算机中所有的资源的使用情况，并给出合适的调度方案
	- 贪心调度：调度器总是使每一时刻时有尽可能多的资源处于工作状态
		- 可以证明，在贪心调度下，有：$T_p\leq \frac{T_1}{P}+T_\infty$
		- 推论：贪心调度时，实际运行时间$T_p$总是小于最优运行时间$T_p^*$的2倍
		- 当核数有限时，$P<< \frac{T_1}{T_\infty}$，有$T_p\approx \frac{T_1}{P}$
