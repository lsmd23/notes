# 定义
以其在较小输入上的值为基础的函数式，即为递归式
# 求解复杂度
- **代入法求解复杂度**：
	- 先猜测其取值
	- 再用数学归纳法证明
	- 例：
		- 对该问题，先猜测$n^3$的上界![[Pasted image 20250225082007.png]]
		- 可证明上界$n^3$：![[Pasted image 20250225082058.png]]
		- 猜测$n^2$为其紧界，证明：![[Pasted image 20250225082245.png]]
- **递归树法求解复杂度**：
	- 递归树的每个节点表示一个子问题所需的时间，可以帮助猜测算法的复杂度
	- 按此规律，拆解算法复杂度直至递归的边界条件，再求和以求得复杂度
	- 例：![[Pasted image 20250225082344.png]]
- ==**主定理法求解复杂度**==：
	- 对形如$T(n)=aT(\frac{n}{b}) + f (n)$的递归式，其中：$a\geq 1,b>1$
	- 将$f (n)$同$n^{\log_b{a}}$相比较：
		1. $f(n)=O(n^{\log_b{a-\epsilon}})$，其中$\epsilon$是任意大于0的常数，则$T(n)=\Theta(n^{\log_b{a}})$
		2. $f(n)=\Theta(n^{\log_b{a}})$，则$T(n)=\Theta(n^{\log_b{a}}\lg n)$
		3. $f(n)=\Omega(n^{\log_b{a+\epsilon}})$，其中$\epsilon$是任意大于0的常数，且对所有充分大的$n$，存在$c<1$，满足$af (\frac{n}{b}) ≤ cf (n)$（正则化条件），则$T(n)=\Theta(f(n))$
	- 例：![[Pasted image 20250225084058.png]]![[Pasted image 20250225084105.png]]
	- 问题：主定理的1和3情况，只适用于比$O(n^{\log_b{a}})$小（大）至少多项式复杂度的情况，对其他情况不适用
	- 主定理的扩展：
	- 说明：
		- 递归树：![[Pasted image 20250225084844.png]]$n^{\log_b{a}}$即为叶子节点的个数
		- 情况1：叶子节点占主导，只加叶子节点的时间即为$\Theta(n^{\log_b{a}})$
		- 情况2：二者相差无几，则每一层都相差无几，乘上层数即为$\Theta(n^{\log_b{a}}\lg n)$
		- 情况3：根子节点占主导，只加根子节点即为$\Theta(f(n))$
	- 证明：
		- 将递归树加和：