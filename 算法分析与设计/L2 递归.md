# 定义
以其在较小输入上的值为基础的函数式，即为递归式
# 求解复杂度
- **代入法求解复杂度**：
	- 先猜测其取值
	- 再用数学归纳法证明
	- 例：
		- 对该问题，先猜测$n^3$的上界![[Pasted image 20250225082007.png]]
		- 可证明上界$n^3$：![[Pasted image 20250225082058.png]]
		- 猜测$n^2$为其紧界，证明：![[Pasted image 20250225082245.png]]
- **递归树法求解复杂度**：
	- 递归树的每个节点表示一个子问题所需的时间，可以帮助猜测算法的复杂度
	- 按此规律，拆解算法复杂度直至递归的边界条件，再求和以求得复杂度
	- 例：![[Pasted image 20250225082344.png]]
- ==**主定理法求解复杂度**==：
	- 对形如$T(n)=aT(\frac{n}{b}) + f (n)$的递归式，其中：$a\geq 1,b>1$
	- 将$f (n)$同$n^{\log_b{a}}$相比较：
		1. $f(n)=O(n^{\log_b{a-\epsilon}})$，其中$\epsilon$是任意大于0的常数，则$T(n)=\Theta(n^{\log_b{a}})$
		2. $f(n)=\Theta(n^{\log_b{a}})$，则$T(n)=\Theta(n^{\log_b{a}}\lg n)$
		3. $f(n)=\Omega(n^{\log_b{a+\epsilon}})$，其中$\epsilon$是任意大于0的常数，且对所有充分大的$n$，存在$c<1$，满足$af (\frac{n}{b}) ≤ cf (n)$（正则化条件），则$T(n)=\Theta(f(n))$
	- 例：![[Pasted image 20250225084058.png]]![[Pasted image 20250225084105.png]]
	- 问题：主定理的1和3情况，只适用于比$O(n^{\log_b{a}})$小（大）至少多项式复杂度的情况，对其他情况不适用
	- 主定理的扩展：
	- 说明：
		- 递归树：![[Pasted image 20250225084844.png]]$n^{\log_b{a}}$即为叶子节点的个数
		- 情况1：叶子节点占主导，只加叶子节点的时间即为$\Theta(n^{\log_b{a}})$
		- 情况2：二者相差无几，则每一层都相差无几，乘上层数即为$\Theta(n^{\log_b{a}}\lg n)$
		- 情况3：根子节点占主导，只加根子节点即为$\Theta(f(n))$
	- 证明：
		- 将递归树加和，推导加和式即可
	- 主定理的应用：
		- 对于替换过变量的情况（如开根号），采用代换法使其转换为主定理的形式求解
			- 例：![[Pasted image 20250225091142.png]]
# 分治法
- 将原始问题分割成数个规模较小的子问题的方法，即将一个问题按分——治——和的方法求解
## 归并排序
- 算法：![[Pasted image 20250225091818.png]]
- 复杂度分析：![[Pasted image 20250225092039.png]]
## 二分查找
- 算法：![[Pasted image 20250225092539.png]]
- 复杂度分析：![[Pasted image 20250225092626.png]]
## 斐波那契数列
- 算法：![[Pasted image 20250225092646.png]]
- 复杂度分析：由数学推导可得![[Pasted image 20250225092824.png]]是指数的复杂度
- 优化算法：
	1. 可以用分治法求解$\phi^n$：将其分治为一半，可以将复杂度降低到$\Theta(\lg n)$
		- 问题：由于浮点数的不精确性，其无法精确得出结论
	2. 利用循环，可以从下向上动态规划的求解：复杂度为循环复杂度$\Theta(n)$
## 大整数乘法
- 简单的分治将大整数乘法划分成四个子问题，根据主定理，并不能降低算法的复杂度
- 缩减问题规模：![[Pasted image 20250304081357.png]]
- 复杂度分析：![[Pasted image 20250304081525.png]]
## 矩阵乘法
- 暴力相乘法：$\Theta(n^3)$的复杂度
- 分治法：
	- 将每个矩阵都分割为四个分块矩阵，一共划分为八个子问题，$T(n)=8T(n/2)+\Theta(n^2)$，根据主定理，依然是$\Theta(n^3)$的复杂度
	- Strassen算法：
		- 划分为七个子问题：![[Pasted image 20250304082411.png]]
		- 复杂度分析：![[Pasted image 20250304082434.png]]
## 寻找最近的点对
- 问题：对一组点集，寻找一对欧氏距离最小的点对，暴力求解需要$\Theta(n^2)$的复杂度
- 分治法：
	- 选择一个维度上的中位数，将其分成两部分
	- 递归地解决一侧
	- 在合并时，需要考虑两部分之间的点对的情况；设递归解决的两侧点对的最小值是$d$，在线两侧画一个宽为$2d$的矩形区域，对一侧的某个点，可能距离更小的点一定在另一侧一个**宽为$d$，长为$2d$的矩形区域**![[Pasted image 20250304085056.png]]
		- 可以证明，这个区域内**不超过6个点**，假设可以查找，则可以降低到常数复杂度
	- 复杂度分析：![[Pasted image 20250304085337.png]]
	- 查找分析：对任意的点，查找这个矩形内的点并非是常数的复杂度。但对有序的一组点（假设y有序），按有序的序列，从低到高，每个点至多只可能和序列中右侧的常数个点产生更小的距离，从而将查找降低到常数复杂度
# 随机算法
- *引入——雇佣问题：有一批人前来应聘，每雇佣一个人需要花费一些钱，每次应聘结束后应立即决定是否雇佣，现在希望能用尽量少的钱，雇佣到最好的人*
- 基础知识：
	- 随机变量分布的均值和方差
	- 条件概率公式
	- 指标随机变量：给定样本空间S和事件A，指标随机变量I{A}被定义为：$$
		I\{A\}=\begin{cases}
		1,&\text{if A occurs,
		}\\0,&\text{if A does not occur,
		}
		\end{cases}$$指标随机变量的均值即为事件发生的概率
- 分析：
	- 概率分析：定义指标随机变量$X_i=I\{\text{candidate i is hired}\}$，作概率分析即可得到X的均值是$\ln n$
	- 引理：如果**候选人随机到来，则雇人问题的花费的期望为$O(c_h\ln n)$**
- 随机算法：
	- 排序随机算法：
		- 算法描述：![[Pasted image 20250304204210.png]]
		- 性质：当生成的随机数种子（即算法中的P数组）**互不相同**时，其可以给出**排列随机的结果**（即各个排列出现的概率均等）
	- 交换随机算法：
		- 算法描述：![[Pasted image 20250304204333.png]]
		- 同样，给出排列随机的结果
- 最优停止问题：
	- 算法描述：![[Pasted image 20250304204431.png]]
	- 概率论分析：
		- 能选到最好的人，要求最好的人出现在位置i处（记为事件$B_i$），同时，要求不能选择从$k+1$到$i-1$这一部分的人（记为事件$O_i$）。
		- $P=\sum_{i=k+1}^n\frac{k}{n(i-1)}$，进而：$\frac{k}{n}(\ln n-\ln k)\leq P\leq \frac{k}{n}(\ln (n-1)-\ln (k-1))$
		- 使最小值最大化，求得$k=1/e$，也即在大约三分之一处停止，有最大的概率找到最好的人