# 串匹配问题
- 问题描述与基本概念：
	- 在文本T[1..n]中找到模式P[1..m]的所有出现。如果$0 ≤ s ≤ n − m$且T[s + 1:s + m] = P[1:m]，则称模式P在文本T中以s位移出现
	- 定义字母表$\Sigma$与前后缀标记$⊏,⊐$：见[[形式语言与自动机/L0 绪论#形式语言基础|形式语言与自动机——形式语言基础]]
- 后缀重叠引理：对均为字符串$z$后缀的两字符串$x,y$，若$|x|\leq|y|$，则$x⊐y$；若$|x|\geq|y|$，则$y⊐x$；若$|x|=|y|$，则$x=y$
# 串匹配算法
## 暴力算法
- 实现：![[Pasted image 20250506083030.png]]
- 复杂度：$\Theta((n-m+1)m)$
## Rabin-Karp算法
- 思路：假定串定义在字母表$\Sigma = \{0,1,\cdots,9\}$上
	- 模式串P[1..m]对应一个十进制整数$p$，文本串的子串T[s+1..s+m]也对应一个十进制整数$t_s$，二者匹配的充要条件是$p=t_s$
	- 利用递归算法，可以在$\Theta(m)$时间内计算出$p$：$$p=P[m]+10(P[m-1]+10(P[m-2]+\cdots+10(P[2]+10P[1])\cdots))$$
	- 可以迭代的在$\Theta(n-m+1)$时间内计算出$t_s$：$$t_{s+1}=10(t_s+10^{m-1}T[s+1])+T[s+m+1]$$
- 改进：采用哈希的思路，应对比较大的数据（最简单的除q余哈希函数）：$$t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\mod q$$
	- 实现：![[Pasted image 20250507194612.png]]![[Pasted image 20250507194617.png]]
	- 复杂度：
		- 最坏情况下，每次都可以匹配（$P=a^m,T=a^n$），则需要$\Theta((n-m+1)m)$
		- 应用中，虚假命中的期望值为$O(n/q)$，因此期望的运行时间为：$$O(n)+O(m(v+n/q))$$其中$v$为有效命中的次数
		- 当$v$为确定的常数，且选择$q\geq m$时，期望的匹配时间为$O(n)$
## 自动机串匹配
- 有限自动机：
	- [[L1 确定有限自动机(DFA)#DFA的定义|确定有限自动机]]
	- [[L2 非确定有限自动机(NFA)#NFA的定义|非确定有限自动机]]
- 串匹配自动机：
	- 定义一个自动机，其状态集合取决于模式串的长度：$Q=\{0,1,\cdots,m\}$，初态为$0$，唯一接受终态为$m$
	- 定义模式串P的**后缀函数**：$\sigma(x)=\max\{k:P[:k]⊐x\}$，即P中完全作为x的后缀的最大位置
		- 例：$P = ab, σ(ε) = 0, σ(ccaca) = 1, σ(ccab) = 2$
		- $\sigma(x)=m\Leftrightarrow P⊐x$
	- 定义转移函数：$\delta(q,a)=\sigma(P[:q]a)$
		- 例：![[Pasted image 20250506085613.png]]![[Pasted image 20250506085622.png]]
- 串匹配自动机算法：
	- 实现：对每个位置运行自动机即可![[Pasted image 20250506085917.png]]
	- 正确性证明：
		- 引理：（后缀函数不等式）对任意串$x$与字符$a$，有$\sigma(xa)\leq\sigma(x)+1$
		- 引理：（后缀函数递归引理）对任意串$x$与字符$a$，若$q=\sigma(x)$，则$\sigma(xa)=\sigma(P[:q]a)$
		- 定理：对输入串T[1..n]与给定模式串P构造的有限自动机，扩展转移函数$\delta^*(T[:i])=\sigma(T[:i])$
			- 证明：$$\begin{align}\delta^*(T[:i+1])&=\delta^*(T[:i]a)\\ &=\delta(\delta^*(T[:i]),a)\\ &=\delta(q,a)\\ &=\sigma(P[:q]a)\\ &=\sigma(T[:i]a)\\ &=\sigma(T[:i+1])\\\end{align}$$
	- 转移函数的计算：![[Pasted image 20250507195810.png]]
## KMP算法
- [[L12 串#串匹配|数据结构——串匹配]]
- 前缀函数：模式串的前缀性质反映了匹配过程中的一些已匹配的信息，避免移动匹配时的冗余匹配或自动机中明显无法达到终态的转移函数的计算
	- 定义：对给定的模式串P[1:m]，前缀函数定义为$\pi:\{1,2,\cdots,m\}\rightarrow \{0,1,\cdots,m-1\}$使得$\pi[q]=\max\{k:k<q\wedge P[:k]⊐ P[:q]\}$
	- 例：![[Pasted image 20250507200434.png]]
- KMP算法：
	- 前缀函数的计算：![[Pasted image 20250507200658.png]]
		- 复杂度：聚合法对k进行摊还分析，复杂度为$\Theta(m)$
		- 正确性：
			- 定义：迭代计算的$\pi$函数列：$\pi^{(0)}=q,\pi^{(i)}[q]=\pi[\pi^{(i-1)}[q]]$，可以证明，迭代计算得到的函数列和前缀函数是相等的：$\pi^*[q]=\{\pi[q],\pi^{(2)}[q],\cdots,\pi^{(t)}[q]\}$（注：该序列在任意$\pi^{(i)}[q]=0$时终止）
				- 证明：![[Pasted image 20250507202142.png]]![[Pasted image 20250507202149.png]]
			- 引理：对长为m的模式串P，$\pi$为前缀函数，若$\pi[q]>0$，则$\pi[q]-1\in\pi^*[q-1]$
				- 证明：![[Pasted image 20250507202322.png]]
			- 结论：对前缀函数：$$\pi[q]=\begin{cases}0 &\text{if }E_{q-1}=\emptyset\\ 1+\max E_{q-1}&\text{if }E_{q-1}\neq\emptyset\\\end{cases}$$其中$E_{q-1}$为$\pi^*[q-1]$的子集
	- 实现：![[Pasted image 20250507200639.png]]
		- 复杂度：对q进行聚合分析，复杂度为$\Theta(n)$
		- 正确性：
## Boyer-Moore算法
- 在匹配时，从右侧匹配比从左侧匹配效率更高
	- 若某文本串字符没有出现在模式串中，直接滑动到该字符之后
	- 若某文本串字符出现的最右侧的位置为$\delta_1$，则可以直接将其滑动$\delta_1$距离到该字符对齐
	- 若从右侧匹配$\delta_2$后发生失配，则滑动到另一个位置使得子串$P[m-\delta_2]\cdots P[m]$适配文本串
	- 例：
		- ![[Pasted image 20250507210723.png]]
		- ![[Pasted image 20250507210729.png]]
		- ![[Pasted image 20250507210739.png]]
- 坏字符位移：
	- 对每个匹配的字符，应当有一个存储位移的表，称为bmBc表
	- 对所有的$c\in\Sigma$，有：$$bmBc[c]=\begin{cases}\min\{i:1\leq i\leq m-1\wedge P[m-i]=c\}&若c出现在P中\\ m &若c未出现在P中\\\end{cases}$$对应的位移为：$bmBc[c]+j-m$
- 好后缀位移：
	- 对已匹配的后缀：
		- 要么，原字符串中重复出现了已匹配的后缀。则有一个向后的位移，使得其失配位置的字符改变，已匹配位置的后缀重复出现且恰好对齐，重新从右侧开始匹配即可![[Pasted image 20250508141400.png]]
		- 要么，模式串的某前缀和原适配的后缀有重叠，也即原匹配的后缀的某后缀是模式串的前缀，这时可以右移使得该前缀对齐该后缀![[Pasted image 20250508141516.png]]
	- 定义好后缀位移表bmGs：
		- 定义：$Cs(i,s)$：对 $i<k≤m$，有 $P[k−s]=P[k]$或$s≥k$，表示从$i$位置开始的后缀在模式串中重复出现，重复出现的位置在$i$前数$s$的位置
		- 定义：$Co(i,s)$：若 $s<i$，则 $P[i−s]≠P[i]$，表示对$i$位置，向前数$s$个字符，可以使得该位置发生改变
		- 则：$bmGs[i]=\min\{s>0:Cs(i,s)\wedge Co(i,s)成立\}$，为对应的后移使得已匹配后缀匹配，且失配字符改变的最小位移
- 算法：
	- 伪代码实现：![[Pasted image 20250507212016.png]]
	- 计算坏字符位移：![[Pasted image 20250507212021.png]]
		- 例：![[Pasted image 20250507212115.png]]
	- 计算好后缀位移：
		- 重叠后缀函数：$Osuff[i]=\max\{k:P[i-k+1:i]=P[m-k+1:m]\}$，也即对$i$位置开始向前数，最多有长为k的子串为当前串的后缀