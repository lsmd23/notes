# 动态表
- 问题：实际问题中对连续的内存空间构成的表（向量、哈希表等），往往不希望过大的进行静态的内存分配（可能引起空间的浪费），但也不希望内存分配过小（引起溢出）
	- 解决：STL中`vector`类的动态内存调整是一种解决方式（在线的进行内存的控制）
- 向量的复杂度分析：
	- 插入的实现：![[Pasted image 20250415081425.png]]由于存在内存搬移的过程，一次操作的复杂度为$\Theta(n)$
	- 对连续的$n$次调用，总复杂度：
		- 记c_i为第i次插入花费的时间：$$c_i=\begin{cases}i &\text{if } i-1=2^m,m=0,1,2,\cdots\\1&\text{otherwise}\\\end{cases}$$
		- 总时间花费：$$\text{total cost}=\sum_{i=1}^nc_i\leq n+\sum_{j=0}^{\lfloor\lg n\rfloor}2^j<3n=\Theta(n)$$
		- 故平均单次插入的复杂度为$\Theta(1)$
- 类似上述的分析方法即为均摊分析法：对算法，分析一系列操作的平均花费，而不是简单的将单次操作花费的时间求和
	- 分析最坏情况下单次效率的平均时间
	- 方法：聚集法、核算法、
# 聚集法
- 思路：计算代码运行$n$次后，各个操作花费时间的总和，在均摊到$n$次内即可
- 递增二进制计数器：
	- 实现：从低位到高位遍历![[Pasted image 20250415082946.png]]单次复杂度$\Theta(k)$
	- 总复杂度：
		- 对第$i$位$(i<\lfloor\lg n\rfloor)$，其一共会转变$\lfloor\frac{n}{2^i}\rfloor$次
		- 总复杂度：$$\sum_{i=0}^{\lfloor\lg n\rfloor}\lfloor\frac{n}{2^i}\rfloor<n\sum_{i=0}^{\infty}\frac{1}{2^i}=2n$$
		- 故总复杂度为$O(n)$，均摊复杂度为$O(1)$
# 核算法
- 思路：
	- 取一个每次操作的平均估计值$\hat{c_i}$
	- 对每次操作，花销时间比估计值小，则将少开销的时间存入一个“银行”中；反之则从银行中取出
	- 条件：$\sum_{i=1}^n\hat{c_i}\geq\sum_{i=1}^nc_i$
- 向量插入：
	- 对每次插入操作分配3的花费，插入花费1，搬移花费1
	- 例：![[Pasted image 20250415085701.png]]![[Pasted image 20250415085709.png]]
	- ![[Pasted image 20250415085750.png]]
- 二进制计数器：
	- 对每次递增操作分配2的花费，插入花费1，搬移花费1
