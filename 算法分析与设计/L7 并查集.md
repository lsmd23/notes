# 并查集的操作
- 并查集：
	- 一个不相交的动态集合$S = \{S_1, S_2, . . . , S_k\}$
	- 每个集合，选择某个成员作为代表元素。**若两次请求动态集合的代表元素而在请求之间没有修改该集合，则两次得到的答案一定是相同的**
- 操作接口
	- 创建单元素集合：给定不在任何一个集合中的元素，创建只含有$x$的单元素集合
	- 并：合并两个集合$S_x,S_y$
	- 查找：对某元素$x$，返回包含元素$x$的集合
- 应用：判断一个无向图的连通分量数
	- 实现：![[Pasted image 20250422080858.png]]![[Pasted image 20250422080909.png]]
- 应用：Kruskal算法
	- 描述：[[Chapter 3 树#^6a4dd6|图论与代数结构——最小支撑树]]
	- 判断回路，加入边的操作均可以使用并查集高效完成
# 并查集的链表实现
- 实现：如图![[Pasted image 20250422082255.png]]
	- 合并操作分析：采用聚合法分析创建n个元素的并查集的过程![[Pasted image 20250422082532.png]]总复杂度：$\sum_{i=1}^{n-1}i=\Theta(n^2)$，摊还复杂度$\Theta(n)$，是不可接受的
- 优化：
	- 带权并查集：在并查集中额外维护一个数值，表示集合的长度
	- 每次合并时，选取长度更短的集合，遍历节点调整指针的指向
	- 复杂度分析：可以证明，对规模为n的并查集，只考虑合并和创建操作，复杂度上界$O(n\lg n)$
		- 证明：
			- 最终合并到同一个集合，一共进行了$n-1$次合并操作
			- 考虑某一特定元素$x$，每当$x$的指针被更新时，$x$元素一定处于这次合并时相对更小的链表中
# 并查集的森林实现
- 实现：
	- 将每个集合表示为一个树，根节点代表整个集合
	- 每个节点指向父节点，根节点指向自己
	- 示意图：![[Pasted image 20250422083343.png]]
	- 操作接口：
		- 创建单元素集合：创建单节点树
		- 并：合并两棵树，调整根节点指针
		- 查找：对确定的某元素，依指针上溯找到对应树的根节点
	- 优化：
		- 按秩合并：每个根节点同时维护一个秩，表示树的高度上界，合并时总是将秩小的树合并到秩大的树
		- 路径压缩：每次查找操作时，将查找路径上的每个节点直接与树根相连，以压缩树的实际高度
	- 伪码实现：
		- 创建与合并：![[Pasted image 20250422084406.png]]![[Pasted image 20250422084413.png]]
		- 查找：递归函数![[Pasted image 20250422084437.png]]
- 定理：关于复杂度
	- 
# 复杂度分析
- 阿克曼函数：定义在整数$j$上，以$k$为参数（阶次）的函数：$$A_k(j)=\begin{cases}j+1&\\A_{k-1}^{(j+1)}(j)\end{cases}$$其中，$A_{k-1}^{(j+1)}(j)$表示一个迭代函数（具体定义见[[L1 基础知识#^cbcb00|迭代定义的函数]]）