# 并查集的操作
- 并查集：
	- 一个不相交的动态集合$S = \{S_1, S_2, . . . , S_k\}$
	- 每个集合，选择某个成员作为代表元素。**若两次请求动态集合的代表元素而在请求之间没有修改该集合，则两次得到的答案一定是相同的**
- 操作接口
	- 创建单元素集合：给定不在任何一个集合中的元素，创建只含有$x$的单元素集合
	- 并：合并两个集合$S_x,S_y$
	- 查找：对某元素$x$，返回包含元素$x$的集合
- 应用：判断一个无向图的连通分量数
	- 实现：![[Pasted image 20250422080858.png]]![[Pasted image 20250422080909.png]]
- 应用：Kruskal算法
	- 描述：[[Chapter 3 树#^6a4dd6|图论与代数结构——最小支撑树]]
	- 判断回路，加入边的操作均可以使用并查集高效完成
# 并查集的链表实现
- 实现：如图![[Pasted image 20250422082255.png]]
	- 合并操作分析：采用聚合法分析创建n个元素的并查集的过程![[Pasted image 20250422082532.png]]总复杂度：$\sum_{i=1}^{n-1}i=\Theta(n^2)$，摊还复杂度$\Theta(n)$，是不可接受的
- 优化：
	- 带权并查集：在并查集中额外维护一个数值，表示集合的长度
	- 每次合并时，选取长度更短的集合，遍历节点调整指针的指向
	- 复杂度分析：可以证明，对规模为n的并查集，只考虑合并和创建操作，复杂度上界$O(n\lg n)$
		- 证明：
			- 最终合并到同一个集合，一共进行了$n-1$次合并操作
			- 考虑某一特定元素$x$，每当$x$的指针被更新时，$x$元素一定处于这次合并时相对更小的链表中
			- 每当$x$的指针被更新时，其一定被合并到了一个更大的子集合中，这一集合的大小至少是原来的2倍
			- 因此，如果x被更新了$\lceil\lg n\rceil$次，集合至少变成大小为$n$的集合，也即总复杂度的上界是$O(n\lg n)$
# 并查集的森林实现
- 实现：
	- 将每个集合表示为一个树，根节点代表整个集合
	- 每个节点指向父节点，根节点指向自己
	- 示意图：![[Pasted image 20250422083343.png]]
	- 操作接口：
		- 创建单元素集合：创建单节点树
		- 并：合并两棵树，调整根节点指针
		- 查找：对确定的某元素，依指针上溯找到对应树的根节点
	- 优化：
		- 按秩合并：每个根节点同时维护一个秩，表示树的高度上界，合并时总是将秩小的树合并到秩大的树
		- 路径压缩：每次查找操作时，将查找路径上的每个节点直接与树根相连，以压缩树的实际高度
	- 伪码实现：
		- 创建与合并：![[Pasted image 20250422084406.png]]![[Pasted image 20250422084413.png]]
		- 查找：递归函数![[Pasted image 20250422084437.png]]
- 定理：
	- 只使用按秩合并，对规模为n的m次操作并查集，复杂度为$O(m\lg n)$
	- 只使用路径压缩，对规模为n的并查集，至多n-1次合并操作，f次寻找操作，复杂度为$\Theta(n+f(1+\log_{2+\frac{f}{n}}n))$
	- 二者同时使用，复杂度为$O(m\alpha(n))$，其中$\alpha(n)$是一个增长极为缓慢的函数，可以视为常数
# 复杂度分析
- 阿克曼函数：定义在整数$j$上，以$k$为参数（阶次）的函数：$$A_k(j)=\begin{cases}j+1&\text{if }k=0\\A_{k-1}^{(j+1)}(j)&\text{if }k\geq1\\\end{cases}$$其中，$A_{k-1}^{(j+1)}(j)$表示一个迭代函数（具体定义见[[L1 基础知识#^cbcb00|迭代定义的函数]]），称角标参数$k$为函数的等级
	- 一些简单的性质：
		- $A_{k-1}^{(0)}(j)=j$
		- 当$i>1$时，$A_{k-1}^{(i)}(j)=A_{k-1}(A_{k-1}^{(i-1)}(j))$
		- 对任意的$j\geq1$，有$A_1(j)=2j+1$
		- 对任意的$j\geq1$，有$A_2(j)=2^{j+1}-1$
		- 类似，可以计算得到，$A_3(1)=2047$，且有：$$A_4(1)=A_3(A_3(1))=A_3(2047)=A_2^{(2048)}(2047)\gg A_2(2047)\gg 10^{80}$$
	- 定义：$\alpha(n)=\min\{k:A_k(1)\geq n\}$，也即其**逆函数**在整数上的表示
		- 由上述的计算，可以推导出一个分段的表示：$$\alpha(n)=\begin{cases}0&\text{for }0\leq n\leq 2\\1&\text{for } n=3\\2&\text{for }4\leq n\leq 7\\3&\text{for }8\leq n\leq 2047\\4&\text{for }2048\leq n\leq 10^{80}\\\end{cases}$$
- 分析：势能法均摊分析
	- 对节点的秩：节点的秩总不大于其对应的根节点的秩（等号只在节点为根节点时取得），同时，一旦节点不是根，其秩不再发生改变
	- 对一条到根节点的路径上，节点的秩严格单调增，且秩的最大值是$n-1$
	- 引理：对一个由$m$次创建集合、合并、查找组成的操作序列$S$，运行复杂度为$O(m\alpha(n))$，以及一个由$m'$次操作组成的序列$S'$，如果二者最后的操作结果相同，则其复杂度为$O(m'\alpha(n))$（也即**操作的过程对单次复杂度没有影响**）
	- 定义每个节点的势能函数$\phi_q(x)$表示经过$q$次操作后节点$x$的势能，整个结构的势能$\Phi_q=\sum_x\phi_q(x)$
		- 定义level函数：$\text{level}(x)=\max\{k:x.p.\text{rank}\leq A_k(x.\text{rank})\}$，也即用Ackermann函数的反函数表示一个节点的等级
		- 定义iter函数：$\text{iter}(x) = \max\{i : x.p.\text{rank} ≥ A^i_{\text{level}(x)}(x.\text{rank})\}$
		- 对单个节点，定义势能函数：$$\phi_q(x)=\begin{cases}\alpha(n)\cdot x.\text{rank} &\text {若x是树根}\\ (\alpha(n)-\text{level}(x))\cdot x.\text{rank} - \text{iter}(x) &\text{若x不是树根且x的秩不小于1}\\\end{cases}$$
		- 引理：对每个节点，在第q次操作后，都有：$0\leq \phi_q(x)\leq \alpha(n)\cdot x.\text{rank}$
		- 引理：对非根节点$x$，第$q$个操作是合连接或查找，那么在第$q$个操作之后，$\phi_q(x) ≤ \phi_{q−1}(x)$；此外，如果$x.\text{rank} ≥ 1$并且由于第$q$个操作$\text{level}(x)$或$\text{iter}(x)$发生变化，则$\phi_q(x) ≤ \phi_{q−1}(x) − 1$。也即，$x$的势能不增，且如果它秩不为0并且$\text{level}(x)$或$\text{iter}(x)$发生变化，则$x$的势能至少下降1
			- 证明略去，可以查询课件或教材
	- 摊还分析：
		- 创建集合的均摊复杂度为$O(1)$
		- 连接操作的均摊复杂度为$O(\alpha(n))$
		- 查找操作的均摊复杂度为$O(\alpha(n))$
---
[[L8 串匹配]]