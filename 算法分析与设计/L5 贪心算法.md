# 活动选择问题
- 问题描述：给定若干个时间上相互有重叠的活动，求最大的相容的（不重叠的）活动的集合
	- 活动集合$S=\{a_1,a_2,\cdots,a_n\}$
	- 对$a_i$，有开始时间$s_i$与结束时间$f_i$
- 动态规划求解：
	- 活动子集$S_{ij}=\{a_k\in S:f_i\leq s_k<f_k\leq s_j\}$，加入初始时间$f_0$与结束时间$s_{n+1}=\infty$，则活动全集描述为$S_{0,n+1}$
	- 选择$a_k$为中间的分隔活动，则$S_{ij}$被分割为$S_{ik}$与$S_{kj}$
	- 对$S_{ij}$，最优子集合为$A_{ij}$，则$A_{ij}=A_{ik}]\cup \{a_k\}\cup A_{kj}$，动态转移方程：$$c[i,j]=\begin{cases}0,&当S_{ij}= \emptyset\\\\\max_{i\leq k\leq j}\{c[i,k]+c[k,j]+1\}&当S_{ij}\neq \emptyset\\\end{cases}$$
- 动态规划的贪心化：
	- 定理：对从$f_k$开始的活动集合$S_k=\{a_i\in S:s_i\geq f_k\}$，$a_m$为其中最早结束的活动，则$a_m$一定在最优求解之中
	- 证明：反证构造法
	- 贪心实现：![[Pasted image 20250401094655.png]]
		- 复杂度：$\Theta(n)$
# 贪心算法的要素
- 步骤：
	1. 对整个问题，划分为一个子问题和一步的执行
	2. 证明执行一步最优的操作之后，可以得到正确的原问题的最优解的一步，也即证明贪心算法的正确性
	3. 通过迭代的方式完成问题的求解
- 对比动态规划：
	- 贪心算法的前提是全局最优解可以通过局部最优解来到达
	- 因此，其一定有最优子结构的性质，也即**贪心算法是动态规划的特殊情况**
- 背包问题：
	- 问题：给定指定容积的背包和数个有一定价值的物品，0-1背包问题试求一种装物方式使得装物的价值最大。分数背包问题去掉了装物只能装整个的限制。
	- 无论是0-1背包问题还是分数背包问题，都有最优子结构的性质，理论可以用动态规划求解
	- 同时，分数背包问题可以用贪心算法求解得到，即每次选取单位重量价值最大的物品。而0-1背包问题由于整数物品的限制，无法用动态规划求解
	- 例：![[Pasted image 20250408082653.png]]
# 哈夫曼编码
- [[L6 二叉树#^b9196c|问题描述&最优编码树]]
- 实现：
	- 伪代码：![[Pasted image 20250408083859.png]]
	- 每次都选取两个最小的值，是一个贪心算法
	- 复杂度：采用优先级队列维护，建堆时间为$\Theta(n)$，$n$次对堆的操作复杂度为$\Theta(n\lg n)$，总复杂度为$\Theta(n\lg n)$
- 正确性证明：
	- 引理：对一个字母表和其中的两个出现频率最多的字母$x,y$，则在最优编码中$x,y$的编码是等长的且只在最后一位有区别
		- 证明：构造法：![[Pasted image 20250408084508.png]]
		- 说明：证明贪心选择性
	- 引理：
		- 证明：
		- 说明：证明最优子结构
	- 因此，前述的伪代码可以得到最优的Huffman编码树
# 离线缓存
- 问题描述：
	- 现代计算机的内存是分级存储机制，每级存储的速度不同，大小不同
	- 高速缓存内存容量有限，最多装有k个缓存块
	- 对某次访问的内存块b
		- 若b在缓存中，直接访问，称为缓存命中
		- 若b不在缓存中且缓存块未满，则直接加载缓存
		- 若b不在缓存中且缓存块已满，则选择一块缓存弹出，加载缓存块b
	- 算法试图优化缓存机制，以合适的方式进行缓存的弹出与加载，使得缓存命中的情况最多，未命中的情况尽可能少