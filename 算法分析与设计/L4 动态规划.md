- 引入：求最大子段和问题
	- 暴力求解，复杂度为$\Theta(n^2)$
	- 采用分治法，复杂度为$\Theta(n\lg n)$
	- 采用动态规划的方式，其复杂度为$\Theta(n)$
- 动态规划：
	- 和分治法比较：
		- 相同：都是将问题拆分成子问题，再从子问题求解原问题
		- 不同：DP算法中子问题之间有重合，常用于最优化问题中
	- 步骤：
		1. 分析最优解的结构
		2. 定义最优解的表达式（动态转移方程）
		3. 自底向上依次求解每一个子问题的最优解
		4. 利用记录的信息，构造出详细的最优解的其他信息
# 钢条切割问题
- 问题描述：给定定长钢条的售价表，与一个长为n的钢条。试切割钢条，以使整个钢条的售价最大
- 问题分析：
	- 最优解结构：对最优解的切割方式，其切割中间一次后，两侧的切割方式也一定是最优的切割方式$$r_n=\max(p_n,r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1)$$
	- 考虑最优切割的最左侧一次，可以将子问题的性质转化为：$$r_n=\max_{1\leq i\leq n}(p_i+r_{n-1})$$
- 动态规划求解：
	- 递归求解：递归可以求解![[Pasted image 20250325083428.png]]
		- 复杂度：$T(n)=2^n$
	- 备忘录法：
		- 加入备忘录记录子问题求解过程：![[Pasted image 20250325083653.png]]![[Pasted image 20250325083711.png]]
		- 问题：复杂度难以直接求出
	- 自底向上的求解：
		- 实现：![[Pasted image 20250325083935.png]]
		- 复杂度：$\Theta(n^2)$
		- 记录最优解信息：![[Pasted image 20250325084251.png]]
# 矩阵链式乘法
- 问题描述：给定n个矩阵，求其连乘积。每个矩阵大小是常数量级的
	- 矩阵乘法满足结合律，不同的乘法顺序，其运算量是有差异的
	- 因而，期望找到一个最佳的乘法方式，使得运算的次数最少
	- 括号化方法：
		- 对$n$个矩阵的加括号方法$P(n)$，可以推导出$P(n)$的增长下界为$\Omega(\frac{4^n}{n^{1.5}})$
		- 因而遍历寻找最佳的括号方式（运算顺序）是不现实的
- 动态规划求解：
	1. 寻找最优解的结构
		- 对最优解的一个切割方式，其两侧子问题也一定是最优的运算顺序
		- 证明：采用反证法
	2. 定义动态转移方程：
		- 对$A_iA_{i+1}...A_j$的矩阵序列，其乘法次数的最小值记为$m[i,j]$，$p_i$为矩阵$A_i$的列数
		- 则有：$$m[i,j]=\begin{cases}0 &\text{if }i=j,\\\min\{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j\} &\text{if }i<j.\\\end{cases}$$
	3. 计算最优乘法次数：
		- 实现：![[Pasted image 20250325091332.png]]![[Pasted image 20250325091837.png]]
		- 示意图：![[Pasted image 20250325091854.png]]![[Pasted image 20250325091905.png]]
		- 复杂度：$\Theta(n^3)$
# 动态规划的要素
- 特点：**最优子结构**与**重叠子问题**：
	- 选择一个切割子问题的方式，寻找其子问题的空间
	- 一般而言常常选择在一侧切割的方式分割子问题，使子问题的空间最简单，从而更好的推导后续的表达式
	- 复杂度：原问题被**分割为了多少个子问题**，以及找到最优子问题时**需要多少种选择**，决定DP算法的复杂度
	- 例：![[Pasted image 20250325092913.png]]
- 反例：无权图的最长简单路径问题
	- 分割子问题后，一段的路径并非是最优子结构，因为可能会影响路径的简单性
	- 例：![[Pasted image 20250325093227.png]]
	- 原因：子问题之间不是独立的，而是互相影响的
- 备忘录法求解：
	- 保存一个表，在递归求解每次遇到子问题时，先在表中查找，如果没有，则求解并存储
	- 当求解原问题时，子问题并不需要全部被求解，而只需要被求解很少的一部分时，备忘录法在求解过程中有时间上的优势
# 最长公共子序问题
- 问题描述：递增的一组下标，对应一个数组中的子序列。最长公共子序问题希望找到两个数组的最长的公共子序的长度和内容。
- 最优子结构分析：从右侧进行问题的分割
	- 假设对串$X_m$与$Y_n$，最长公共子序列为$Z_k$
	- 若$x_m = y_n$，则$z_k = x_m = y_n$且$Z_{k−1}$是$X_{m-1}$与$Y_{n-1}$的最长公共子序列
	- 若$x_m \neq y_n$，则：若$z_k \neq x_m$，则$Z$是$X_{m-1}$与$Y_{n}$的最长公共子序列
	- 若$x_m \neq y_n$，则：若$z_k \neq y_n$，则$Z$是$X_{m}$与$Y_{n-1}$的最长公共子序列
- 定义动态转移方程：
	- $c[i,j]$表示$X_i,Y_j$的最长公共子序列
	- 动态转移方程：$$c[i,j]=\begin{cases}0,&当i=0或j=0\\c[i-1,j-1]+1&当i,j>0且x_i=y_j\\\max(c[i,j-1],c[i-1,j])&当i,j>0且x_i\neq y_j\\\end{cases}$$
- 算法实现：
	- 初始化长度矩阵：![[Pasted image 20250401083039.png]]
	- 动态规划求解：![[Pasted image 20250401083049.png]]
	- 输出子序列的内容：![[Pasted image 20250401083330.png]]
	- 复杂度：$\Theta(mn)$
# 最优二叉搜索树
- 问题描述：
	- 对一组键值$K=<k_1,k_2,\cdots,k_n>$，以及用于描述关键值之间查不到的情况的一组哑元$d_0,d_1,\cdots,d_n$
	- 对每个键值$k_i$，其为查找结果的概率为$p_i$，对哑元$d_i$则为$q_i$，有$$\sum_{i=1}^np_i+\sum_{i=0}^nq_i=1$$
	- 最优二叉搜索树希望构建一棵搜索树，使得期望的总查找次数最少
	- 期望计算：$$\begin{align}E&=\sum_{i=1}^n(\text{depth}_T(k_i)+1)p_i+\sum_{i=0}^n(\text{depth}_T(d_i)+1)q_i\\&=1+\sum_{i=1}^n\text{depth}_T(k_i)p_i+\sum_{i=0}^n\text{depth}_T(d_i)q_i\end{align}$$
- 最优子结构分析：
	- 树具有递归性，因此对于二叉搜索树，其左右子树一定是最优子问题
	- 对包含从$k_i,\cdots,k_j$的树$T$，若$k_r$为其根节点，则其左右子树$k_i,\cdots,k_{r-1}$与$k_{r+1},\cdots,k_j$一定是最优子结构
- 定义动态转移方程：
	- $e[i,j]$为从$i$到$j$的搜索期望
	- $$e[i, j ] = p_r + (e[i , r − 1] + w(i , r − 1))+ (e[r + 1,j]+w(r+1,j))$$其中w表示其中的元素多比较一次的情况
	- 根据搜索树，$w(i,j)=\sum_{l=1}^jp_l+\sum_{l=i-1}^jq_l$
	- 故：$e(i , j) = e[i , r − 1] + e[r + 1, j ] + w(i , j)$
	- 则动态转移方程为：$$e[i,j]=\begin{cases}q_{i-1},&当j=i-1\\\min_{i\leq r\leq j}\{e[i , r − 1]
+e[r + 1, j ] + w(i , j)\}&当i\leq j\\\end{cases}$$
- 实现：基于三重循环，动态规划处理$e$矩阵的右上部分
	- ![[Pasted image 20250401090955.png]]
	- 例：![[Pasted image 20250401091022.png]]
	- 复杂度：$\Theta(n^3)$，可以优化到$\Theta(n^2)$
---
[[L5 贪心算法]]