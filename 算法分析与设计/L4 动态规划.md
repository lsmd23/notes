- 引入：求最大子段和问题
	- 暴力求解，复杂度为$\Theta(n^2)$
	- 采用分治法，复杂度为$\Theta(n\lg n)$
	- 采用动态规划的方式，其复杂度为$\Theta(n)$
- 动态规划：
	- 和分治法比较：
		- 相同：都是将问题拆分成子问题，再从子问题求解原问题
		- 不同：DP算法中子问题之间有重合，常用于最优化问题中
	- 步骤：
		1. 分析最优解的结构
		2. 定义最优解的表达式（动态转移方程）
		3. 自底向上依次求解每一个子问题的最优解
		4. 利用记录的信息，构造出详细的最优解的其他信息
# 钢条切割问题
- 问题描述：给定定长钢条的售价表，与一个长为n的钢条。试切割钢条，以使整个钢条的售价最大
- 问题分析：
	- 最优解结构：对最优解的切割方式，其切割中间一次后，两侧的切割方式也一定是最优的切割方式$$r_n=\max(p_n,r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1)$$
	- 考虑最优切割的最左侧一次，可以将子问题的性质转化为：$$r_n=\max_{1\leq i\leq n}(p_i+r_{n-1})$$
- 动态规划求解：
	- 递归求解：递归可以求解![[Pasted image 20250325083428.png]]
		- 复杂度：$T(n)=2^n$
	- 备忘录法：
		- 加入备忘录记录子问题求解过程：![[Pasted image 20250325083653.png]]![[Pasted image 20250325083711.png]]
		- 问题：复杂度难以直接求出
	- 自底向上的求解：
		- 实现：![[Pasted image 20250325083935.png]]
		- 复杂度：$\Theta(n^2)$
		- 记录最优解信息：![[Pasted image 20250325084251.png]]
# 矩阵链式乘法
- 问题描述：给定n个矩阵，求其连乘积。每个矩阵大小是常数量级的
	- 矩阵乘法满足结合律，不同的乘法顺序，其运算量是有差异的
	- 因而，期望找到一个最佳的乘法方式，使得运算的次数最少
	- 括号化方法：
		- 对$n$个矩阵的加括号方法$P(n)$，可以推导出$P(n)$的增长下界为$\Omega(\frac{4^n}{n^{1.5}})$
		- 因而遍历寻找最佳的括号方式（运算顺序）是不现实的
- 动态规划求解：
	1. 寻找最优解的结构
		- 对最优解的一个切割方式，其两侧子问题也一定是最优的运算顺序
		- 证明：采用反证法
	2. 定义动态转移方程：
		- 对$A_iA_{i+1}...A_j$的矩阵序列，其乘法次数的最小值记为$m[i,j]$，$p_i$为矩阵$A_i$的列数
		- 则有：$$m[i,j]\begin{cases}0 &\text{if }i=j,\\\min\{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j\} &\text{if }i<j.\\\end{cases}$$
	3. 计算最优乘法次数：
		- 实现：![[Pasted image 20250325091332.png]]![[Pasted image 20250325091837.png]]
		- 示意图：![[Pasted image 20250325091854.png]]![[Pasted image 20250325091905.png]]
		- 复杂度：$\Theta(n^3)$
# 动态规划的要素
- 特点：**最优子结构**与**重叠子问题**：
	- 选择一个切割子问题的方式，寻找其子问题的空间
	- 一般而言常常选择在一侧切割的方式分割子问题，使子问题的空间最简单，从而更好的推导后续的表达式
	- 复杂度：原问题被**分割为了多少个子问题**，以及找到最优子问题时**需要多少种选择**，决定DP算法的复杂度
	- 例：![[Pasted image 20250325092913.png]]
- 反例：无权图的最长简单路径问题
	- 分割子问题后，一段的路径并非是最优子结构，因为可能会影响路径的简单性
	- 例：![[Pasted image 20250325093227.png]]
	- 原因：子问题之间不是独立的，而是互相影响的
- 备忘录法求解：
	- 保存一个表，在递归求解每次遇到子问题时，先在表中查找，如果没有，则求解并存储
	- 