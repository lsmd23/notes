# 快速排序
- 思想：分治法
	- 划分：按枢轴元pivot划分为大小两个数组
	- 解决：递归解决
	- 合并：显然
- 伪码实现：
	- 对$[p,r]$区间以$A[r]$为枢轴进行分区![[Pasted image 20250311080733.png]]
- 复杂度分析：
	- 最坏情况下：每次分区一侧只有一个元素$$T(n)=T(0)+T(n-1)+\Theta(n)=\Theta(n^2)$$
	- 最好情况下：每次都均匀地分成两部分$$T(n)=2T(n/2)+\Theta(n)=\Theta(n\lg n)$$即使不是最好情况，通过递归树推导，依然可以得到复合渐进紧界的表达式$$c_1n\lg n\leq T(n)\leq c_2n\lg n$$
	- 交替出现时，例如：$$L(n)=2U(n/2)+\Theta(n),U(n)=L(n-1)+\Theta(n),$$依然可以分析得到其复杂度：$$L(n) = 2(L(n/2 − 1) + \Theta(n/2)) + \Theta(n)= 2L(n/2 − 1) + \Theta(n)= \Theta(n \lg n)$$
- 随机化快速排序：
	- 实现：取随机的元素作为分区的枢轴![[Pasted image 20250311083124.png]]
	- 期望值分析——归纳法证明：
		- 对每次分区，只有一个使之达到最坏的分区情况，每个元素被最坏分割的期望值$X_k=\frac{1}{n}$
		- 对递归式的所有情况求和：![[Pasted image 20250311083922.png]]
		- 利用期望的性质，进行化简：![[Pasted image 20250311084242.png]]![[Pasted image 20250311084323.png]]
		- 采用归纳法证明上下界即可，举上界为例，由归纳假设，只需证：$$E[T(n)]\leq \frac{2}{n}\sum_{k=2}^{n-1}ak\lg k+\Theta(n)$$由数学推导可得：$$\sum_{k=2}^{n-1}k\lg k\leq \frac{1}{2}n^2\lg n-\frac{1}{8}n^2$$进而可以得到：$$E[T(n)]\leq an\lg n-(\frac{an}{4}-\Theta(n))\leq an\lg n$$
	- 期望值分析——随机变量分析：
		- 直接从算法本身开始分析，每次比较的次数是随机变量，记为$X$，则每次子问题的解决需要$O(n+X)$
		- 定义指标随机变量$X_{ij}$表示$i,j$两元素是否被比较，则：$$X=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}$$
		- 求期望：$$E[X]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E[X_{ij}]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}P(z_i元素和z_j元素发生比较)$$
		- 由概率分析，当且仅当$z_i$和$z_j$中间的元素被选为枢轴时，二者不会发生比较，故$P(z_i元素和z_j元素发生比较)=\frac{2}{j-i+1}$
		- 进而：$$E[X]<\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{k}=\sum_{i=1}^{n-1}O(\lg n)=O(n\lg n)$$
- 快速排序的优势：每次访问的是连续的内存，对大规模的数据，可以有效减少不连续内存的访问，进而**高效地利用缓存机制，减少不同层次内存之间的I/O次数**
# 线性复杂度排序算法
## 比较排序的下界
- 建立决策树模型，每次比较顺序的决策都决定了一部分的顺序，树的叶子节点表示排序的结果
- 排序方式要是完备的，则树的叶子节点必须包含一个序列的全部排列情况；同时，对一棵决策树，树的深度即为完成叶子节点的排序的用时；相同排列对应的叶子节点，最深的即为用时的上界，最浅的即为下界
- 因此，树的叶子节点数至少有$n!$个，树的高度为$h$，则树的叶子节点数至多为$2^h$，则$n!\leq 2^h$，因此：$h\geq \lg(n!)=\Omega(n\lg n)$
## 计数排序
- 思想：利用一个辅助空间实现排序
- 实现：
	- 伪代码：![[Pasted image 20250311094117.png]]
		- 第一遍，$C[i]$的每个位置上是$A[i]$中等于$i$的元素的数目
		- 第二遍，$C[i]$的每个位置上是$A[i]$中小于等于$i$的元素的数目
		- 最后按照映射关系，将原数组的数映射到新数组即可
	- 例：![[Pasted image 20250318080923.png]]
	- 分析：
		- 时间复杂度：$O(n+k)$
		- 空间复杂度：$O(k)$
		- 缺点：$k$的范围应当包含原数组中数据的范围，当这个范围很大时，排序需要极大的空间，效率低下
## 基数排序
- 思路：按数据的每一位进行桶排序。一般从低位向高位排序，实现容易，且是稳定的排序算法
- 正确性：用归纳法易证其是正确的
- 分析：
	- 计算机中，用二进制存储数据，在实际使用时将$b$位的数据分成长度为$r$的“片”，需排序$b/r$次
	- 基数排序需要一个辅助空间，因此分长度为$r$为单位排序时，需要的时间为$O(n+2^r)$
	- 因此，$T(n,b)=\Theta(\frac{b}{r}(n+2^r))$，当$r=\lg n$时，可以取得最小的时间$\Theta(bn/\lg n)$
## 桶排序
- 当数据以高精度集中在一个小范围（例如排序(0,1)之间的一系列数时）
- 实现：![[Pasted image 20250318083807.png]]
	- 创建i个桶，对每个桶内进行插入排序
- 复杂度分析：
	- $T(n)=\Theta(n)+\sum_{i=0}^{n-1}O(n_i^2)$，其中$n_i$是每个桶内元素的数目
	- 定义随机变量$X_i=I\{A[j]进入桶i\}$，则$n_i=\sum_{j=1}^nX_{ij}$，则：$$\begin{align}E[n_i^2]=E&[(\sum_{j=1}^nX_{ij})^2]=E[\sum_{j=1}^n\sum_{k=1}^nX_{ij}X_{ik}]\\=E\end{align}$$
# 中值问题与统计
- 希望在线性的时间内，可以在一个数组中选取出第k大的元素
## 快速选择
- 实现：![[Pasted image 20250318085722.png]]
	- 分区函数和快速排序的分区相同
- 复杂度分析：
	- 计算其期望，定义随机变量$X_k$：当分区的一侧数组恰好有k个元素![[Pasted image 20250318091105.png]]
- 优化的快速选择：
	- 步骤：
		1. 将数据分成5个元素一组，余下的自成一组——**线性的**
		2. 在每组内进行插入排序，选取中值——**常数×线性的**
		3. 递归地，以这些中值为新元素，重复选取，直到得到唯一的中值x——**T(n/5)**
		4. 以x为枢轴，对原数组进行划分——**线性的**
		5. 类似快速选择，对划分后的情况进行讨论，寻找直到第k个元素——递归
	- 复杂度分析
		- 由于选择与划分的原理，选取的枢轴元素至少比原数组中$\frac{3}{10}$的元素要大，比$\frac{3}{10}$的元素要少，因此最后一步递归的复杂度为$T(\frac{7}{10}n-6)$
		 
