# 多项式时间
- 对算法而言，多项式的时间复杂度是实际运行允许的，因而是可行的好的算法
	- 多项式时间复杂度的算法和实际问题的模型无关
	- 多项式时间复杂度的算法具有运算的封闭性
- 问题：
	- 抽象问题：二元关系$Q:S\times I$，其中$I$是问题集合，$S$是问题解集合
		- 最简单的问题是判定问题：$S=\{0,1\}$，复杂问题一般都可以抽象成判定问题的组合
	- 具体问题：计算机中将抽象问题的问题集合形式化并编码为二进制的串，称为具体问题
		- 问题的编码：除非使用很单一的编码方式（例如单元编码），否则一个问题的两种编码之间的转换可以在多项式时间内完成
		- 也即，编码方式基本不影响问题的多项式可解性
	- **多项式时间可解**：存在一个复杂度$O(n^k)$的算法求解这个问题，其中$n$是具体问题的长度，$k$是某个长常数
	- 复杂度类：多项式时间可解的**具体判定问题集合**
- 形式语言框架：
	- 使用形式语言的框架描述问题的集合：[[形式语言与自动机/L0 绪论#形式语言基础|形式语言的基本概念]]
	- 一个判定问题$Q$，可以视为在字母表$\Sigma = \{0,1\}$上的一个语言：$L=\{x\in\Sigma^*:Q(x)=1\}$，也即判定为1的字符串集合
	- 一个算法也即一个映射，其接受一个字符串当且仅当输出的值为1，不接受一个字符串当且仅当输出的值为0
	- 语言被算法接受当且仅当其包含的所有的字符串都被算法所接受
	- 一个语言被算法判定，当且仅当语言L中所有的串被算法接受，不属于语言的所有的串被算法拒绝
	- 多项式时间：
		- 语言在多项式时间内**被接受**：存在多项式时间算法**接受**所有的属于该语言的串
		- 语言在多项式时间内**被判定**：存在多项式时间算法**接受**所有的语言的串，并**拒绝**所有不属于语言的串
	- 复杂度类$P$：可以在多项式时间内**判定**的语言的集合 ^39f5c2
		- 定理：$P$可以被表示为被某个算法在多项式时间内**接受**的语言的集合
	- 验证：
		- 验证算法：二元的映射$A$，其中一个参数是平凡的描述问题的串$x$，另一个参数$y$称为证书
		- 验证：算法$A$验证$x$，当且仅当存在一个证书$y$使得$A(x,y)=1$
			- 语言$L$被算法所验证：$L=\{x\in\{0,1\}^*:\exists y\in\{0,1\}^*,s.t.A(x,y)=1\}$
		- 复杂度类$NP$：可以被某个算法在多项式时间内被**验证**的问题集合 ^b18476
# NP-完全性
- 归约：
	- 定义：称语言$L_1$可多项式时间被归约到$L_2$，当且仅当$\exists f:\{0,1\}^*\rightarrow\{0,1\}^*(f是多项式可计算的),s.t. \forall x\{0,1\}^*,x\in L_1\Leftrightarrow f(x)\in L_2$，记作$L_1\leq_p L_2$。称$f$为归约函数，计算$f$的算法$F$称为归约算法
		- 示意：![[Pasted image 20250520080830.png]]
	- 引理：若$L_1,L_2\in\{0,1\}^*,L_1\leq_pL_2$，则$L_2\in P\Rightarrow L_1\in P$
		- 证明是平凡的：![[Pasted image 20250520081030.png]]
- NP-完全性：
	- 定义：称语言$L$是**NP-完全的**，当$L\in NP$，且$\forall L'\in NP,L'\leq_p L$（也即其是NP问题中最难的问题）。若其仅满足$\forall L'\in NP,L'\leq_p L$，则称其为**NP-难的**
	- 定理：若任意的NP-完全问题是多项式时间可解决的，则$P=NP$；或者说，若存在一个NP问题是多项式时间不可解的，则不存在多项式时间可解的NP-完全问题
	- 电路满足性问题：
		- 描述：给定由与门、或门、非门组合成的组合电路，是否存在一个输入函数，使其输出的值可以为真
		- 显然，要判定该问题，是指数复杂度的（需要枚举全部的输入），但对给定的输入，验证该问题是多项式时间内可完成的，因此其是**NP问题**
		- 引理：电路满足性问题是**NP-难的**
		- 因此，电路满足性问题是**NP-完全的**
	- NP-完全性证明：
		- 引理：若存在语言$L,L'$，$L'\in NPC$，$L'\leq_p L$，则$L$是NP-难的问题。此外，若$L\in NP$，则$L\in NPC$
			- 证明：![[Pasted image 20250520082650.png]]
		- 由上述引理，可以获取一个证明步骤：
			1. 证明$L\in NP$
			2. 选取一个NP-完全语言$L'$
			3. 找到一个算法$f$，可以将任意的二进制串$x\in L'$映射到另一个串$f(x)\in L$
			4. 证明：$\forall x\in\{0,1\}^*$，$x\in L'$当且仅当$f(x)\in L$（也即映射$f$是双射）
			5. 证明算法$f$在多项式时间内运行
		- 例：公式满足性问题：给定含与、或、非、蕴含、双蕴含逻辑运算符的布尔函数，是否存在一个输入使其为真
			- 显然，公式满足性问题是NP-问题
			- 可以找到多项式时间的算法，使其对任意的$x\in L'$（$L'$为电路满足问题的语言）可以映射到公式满足性问题$L$上
			- 可以证明这样的映射是双射，也即证明了：电路满足性问题 $\leq_p$ 公式满足性问题
			- 由此，**公式满足性问题是NP-完全的**
# 典型的NP-完全问题
- 三合取范式满足性问题：
	- 问题描述：[[L2 命题逻辑的等值和推理演算#范式|合取范式]]，三合取范式即由三元的析取式合取形成的范式
	- 证明：
		- 取公式满足性问题为$L'$
		- 等价性证明，只需证明任意一个公式都可以转化为三合取范式即可
		- 任意的逻辑表达式都可写出一个解析树
			- 例：![[Pasted image 20250520084316.png]]
		- 对任意二叉树节点上的子句，可以转化为三合取范式
		- 也即找到了一个多项式时间可计算的从三合取范式满足性问题到公式满足性问题的双射
		- 因此，三合取范式问题是NP-完全的
- 团问题：
	- 问题描述：寻找一个无向图中的最大的连通分量（完全子图）的大小
	- 若连通分量的大小是常数，则其是多项式时间可判定的（暴力枚举即可）；若给定一个可能的解，可以在多项式时间内验证其是否属于该问题的解，因此其是NP问题
	- 从三合取范式构造一张无向图：
		- 对每个单元的逻辑变量，创建一个节点
		- 节点之间的边：属于同一析取式的节点之间没有边，二者互为相反元的节点之间没有边
		- 例：![[Pasted image 20250520090331.png]]
		- 该无向图的构造即为一个映射$f$
	- 证明等价性：
		- 从合取范式到图：有k个子句，则满足时，至少有k个取1的顶点，这些顶点一定相互连通，也即有一个k大小的完全子图
		- 从图到合取范式，同样，只需按三个顶点分组，即可得到一个三合取范式
- 顶点覆盖问题： ^34a912
	- 问题描述：顶点覆盖，即为取一个顶点的子集，使其对于图中的所有边，其中一个顶点一定属于这个子集。顶点覆盖问题即为找到顶点覆盖的最小集合
		- 例：![[Pasted image 20250520091100.png]]
	- 证明：补图的最大完全子图和原图的顶点覆盖是互补的
- 哈密顿回路问题：
	- 描述：[[Chapter 2 道路与回路#哈密顿道路与回路|图论——哈密顿回路]]
	- 证明：归约到顶点覆盖或公式满足问题，证明细节略去，可参考的证明：[CSDN——SAT归约哈密顿回路证明NP完全](https://blog.csdn.net/weixin_58140705/article/details/137030103)
- 旅行商问题：
	- 描述：[[Chapter 2 道路与回路#旅行商问题|图论——旅行商问题]]
	- 证明：归约到哈密顿回路问题
		- 对一个哈密顿回路，将其赋权，回路上的边赋权值0，回路外的边赋权值1，则旅行商问题解即为哈密顿回路，权值和为0
		- 对一个旅行商问题，同样规定上限的权值和为0，则旅行商问题的解就是一条哈密顿回路，得证
- 子集合问题：
	- 问题描述：是否存在某仅含自然数的一个集合的一个子集，使得其中元素之和为给定的目标值$t$
		- 例：![[Pasted image 20250520092614.png]]
	- 证明：归约到三合取范式问题
		- 对有$n$个变量的$k$个子句，按十进制构造$n+k$位的整数
		- 集合内共有$2n+2k$个整数，每个整数按如下构造：
			- 按$n$个变量，构造$2n$个整数，分别对应变量和其逆。这些数的高位取值决定于变量，分别对每个变量的位置取1，其他取0；低位对应子句，子句中出现变量的位置为1，未出现的为0
			- 按$k$个子句，构造$2k$个整数，其高位（变量位）全部取0，子句位分别取1和2
		- 例：![[Pasted image 20250520100039.png]]
		- 对使得原公式成真的一组赋值，分别取对应变量元为1的一组对应的数，这些数之和恰好可以使高位满足这样的和。对低位，则通过取子句对应的数的方式，可以凑出4的数，因此二者之间相互对应