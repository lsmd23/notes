# 单一终态的NFA
- 定理：**任意NFA都等价于只有一个终态的NFA**
	- 构造方式：对原NFA，去掉原来的终态，对原每个终态增添一个$\epsilon$-转移到另外一个终态即可
	- 例：![[Pasted image 20250312102200.png]]
# 正则语言的运算性质
- 语言的并：**正则语言的并仍是正则语言**
	- 构造方式：将两个NFA的初态通过$\epsilon$-转移连接到新的NFA的初态即可![[Pasted image 20250312103014.png]]
- 语言的交：**正则语言的交仍是正则语言**
	- 构造方式：将两个NFA通过$\epsilon$-转移串联即可，若某个NFA有多个终态，先转换成只有一个终态的NFA![[Pasted image 20250312103133.png]]
- 语言的\*闭包：**正则语言的\*闭包仍是正则语言**
	- 构造方式：用$\epsilon$-转移循环的方式构造闭包的NFA；注意，为保证NFA接受这个空串，需要添加一个$\epsilon$-转移直接到终态![[Pasted image 20250312103535.png]]
- 语言的反转：**正则语言的反转仍是正则语言**
	- 构造方式：转化为只有一个终态的自动机，之后反转所有的迁移，将初态变为终态，终态变为初态![[Pasted image 20250312104312.png]]
- 语言的补：**正则语言的补仍是正则语言**
	- 构造方式：设计原语言对应的DFA，将所有终态和非终态互换![[Pasted image 20250312104553.png]]
# 正则表示
- 正则表示可以描述一个语言：
	- 归纳定义：
		- 基础：$\emptyset,\epsilon,a$
		- 对应的，$r_1+r_2,r_1\cdot r_2,r_1^*,(r_1)$都是正则表示
		- 运算优先级：$*>\cdot>+$
		- 正则表示r的语言记为$L(r)$
	- 含义：
		- 归纳基础：$L(\emptyset)=\emptyset,L(\epsilon)=\{\epsilon\},L(a)=\{a\}$
		- 归纳：
			- $L(r_1+r_2)=L(r_1)+L(r_2)$
			- $L(r_1\cdot r_2)=L(r_1)L(r_2)$
			- $L(r_1^*)=(L(r_1))^*$
			- $L((r_1))=L(r_1)$
		- 例：
			- $r=(0+1)^*00(0+1)^*$表示至少含有两个0的字符串
			- $r=(1+01)^*(0+\epsilon)$表示没有两个连续0的字符串
- 正则表示的等价：
	- 定义：对正则表示$r_1,r_2$，若$L(r_1)=L(r_2)$，则称$r_1,r_2$是等价的，记为$r_1=r_2$
	- 例：对0,1交替的串，以下表示等价：
		- $(01)^*+(10)^*+0(10)^*+1(01)^*$
		- $(1+\epsilon)(01)^*(0+\epsilon)$
		- $(0+\epsilon)(10)^*(1+\epsilon)$
- 定理：**正则表示的语言是正则语言**
	- 任何正则表示r的语言是正则的：利用归纳基础和正则语言的封闭性易证
	- 任何正则语言存在正则表示：构造对应的自动机
		- 方法——状态消去法：
			- **\*闭包运算对应自环，连接运算对应不同状态间的转移弧**，由此，可以构建正则表示的输入的自动机
			1. 对每一终态$q$，依次消去除$q$和初态$q_0$之外的其他状态
			2. 若$q\neq q_0$，得到如下自动机，其表示为：$R^*T(U+SR^*T)^*$或$(R+TU^*S)^*TU^*$![[Pasted image 20250312120639.png]]
			3. 若$q= q_0$，得到如下自动机，其正则表示为$R^*$![[Pasted image 20250312120807.png]]
			4. 最终的表示为每一终态的表示相加的结果
			- 例：![[Pasted image 20250312120915.png]]
		- 方法——路径迭代法：