# 正则语言的判定性质
## 基本问题
- 问题：给定正则语言$L$与字符串$w$，如何判断$w\in L$
	- 以DFA表示：判定DFA是否接受字符串
		- 复杂度：$O(n)$，n为字符串长度
	- 以NFA表示：作NFA，转化为DFA或直接判定
		- 复杂度：$O(ns^2)$，s为状态数
	- 以正则表达式表示：转化为NFA执行
- 问题：给定正则语言$L$，如何判断$L$是否为空
	- 以DFA表示：若某终态可达，则该语言非空
		- 解决方式：从初态开始进行归纳
		- 复杂度：$O(n^2)$，n为状态数
	- 以正则表达式表示：归纳表示
		- 复杂度：$O(n)$，n为正则表示的符号数
- 问题：给定两正则语言$L_1,L_2$，如何判断$L_1=L_2$
	- 算法：转化为DFA，判断等价性
		- 适当重命名使状态不重名
		- 将两DFA相并构造新的DFA
		- 对M用填表算法，证明原初态是否等价
	- 复杂度：
		- 上限：$O(n^4)$
		- 适当设计数据结构，可以降低至$O(n^2)$
- 问题：给定正则语言$L$，判断$L$是否无限
	- 方式：取接受语言$L$的DFA，判断初态和终态之间是否有环路
## 泵引理
- 问题：如何判定语言是非正则的
	- 引理：有限的语言一定是正则的
- 鸽巢原理：若对字符串$w$，其长度多于自动机的状态数，则$w$的转移路径一定含有环路，即一定有重复的状态
- 泵引理：正则语言的必要条件
	- 推导：
		- 取一无限正则语言$L$及其DFA
		- 取串$w\in L$，存在一条转移路径$w$
		- 若$|w|\geq n$，则一定有路径重复出现，设$q$为重复出现的第一个状态
		- 拆分自动机的每个部分，接受字符串对应的一部分：$|xy|\leq n,|y|\geq 1$![[Pasted image 20250326103742.png]]则$w=xy^iz$
	- 内容：给定一无限正则语言$L$，一定存在正整数$m$，使得：对$\forall w\in L,|w|\geq m,\exists x,y,z;w=xyz$，满足：$|xy|\leq m \wedge |y|\geq 1$，则有：$w_i=xy^iz\in L,i\in \mathbb N$
## 非正则语言的判定
- 根据命题逻辑，找正则条件的否定：
	- 步骤：
		1. 选取任意的$m$
		2. 找到长度至少为$m$的串$w\in L$
		3. 选取满足$w=xyz\wedge y\neq \epsilon \wedge |xy|\leq m$的$x,y,z$
		4. 找到一个$k\geq 0$，使得$xy^kz\notin L$
	- 例：
		- ![[Pasted image 20250326103331.png]]
		- ![[Pasted image 20250326103936.png]]![[Pasted image 20250326104402.png]]![[Pasted image 20250326104410.png]]
		- ![[Pasted image 20250326110110.png]]![[Pasted image 20250326110137.png]]![[Pasted image 20250326110152.png]]
# DFA的优化
## 集合与等价关系
[[L7 关系#等价关系和划分]]
## DFA状态集上的等价关系
- 状态的等价：
	- 二元关系：设DFA，$D=()$，定义二元关系$R$：$\forall p,q\in Q,pRq$，当且仅当$\forall w\in\Sigma^*,\delta^*(p,w)\Leftrightarrow\delta^*(q,w)\in F$
		- 可以证明：该二元关系是等价关系
		- 进而，这一关系可以导出一个状态集的划分，同一划分块中的状态是相互等价的
## 状态集划分的算法——填表法
- 填表算法：
	- 递归基础：若$p$为终态，$q$为非终态，则$p$与$q$是可区分的
	- 递归：若$p$与$q$是可区分的，状态$r,s$通过输入符号$a$可以分别转移到$p$和$q$，即$\delta(r,a)=p,\delta(s,a)=q$，则$r$和$s$也是可区别的
	- 例：![[Pasted image 20250326115744.png]]![[Pasted image 20250326115752.png]]
- 正确性证明：略
## 最优DFA
- 步骤：
	1. 删除从初态不可达的状态及其相关的边，得到DFA：$A=(Q,\Sigma,\delta,q_0,F)$
	2. 使用填表法找出所有的等价类
	3. 计算当前状态集的划分块，用$[q]$表示
	4. 构造等价的DFA：$B=(Q_B,\Sigma,\delta_B,[q_0],F_B)$，其中：$Q_B=\{[q]|q\in Q\},F_B=\{[q]|q\in F\},\delta_B([q],a)=[\delta(q,a)]$
- 可以证明，这样化简得到的自动机，是状态数目的最小值，即最优DFA
# 有限自动机的扩展
## Moore自动机
- DFA和NFA的输出，只有接受和拒绝两种结果；但有时，需要自动机输出一个字符串而不仅仅是一个布尔型的结果
- Moore自动机：
	- 定义输出字母表$\Lambda$，每个状态上，定义输出符号$\omicron\in\Lambda$，且输出符号**仅与当前状态相关**
	- 即：Moore自动机是六元组$A=(Q,\Sigma,\Lambda,\delta,q_0,G)$，其中$G:Q\rightarrow \Lambda$为输出函数
	- 例：![[Pasted image 20250326120339.png]]
## Mealy自动机
- 输出函数不仅仅与状态相关，而是和输入也相关
- Mealy自动机：
	- 定义输出字母表$\Lambda$，每个状态上，定义输出符号$\omicron\in\Lambda$，且输出符号**与当前状态和输入符号相关**
	- 即：Mealy自动机是六元组$A=(Q,\Sigma,\Lambda,\delta,q_0,G)$，其中$G:Q\times\Sigma\rightarrow \Lambda$为输出函数
	- 例：![[Pasted image 20250402141451.png]]
## 有限自动机的计算复杂性
- 对DFA$(Q,\Sigma,\delta,q_0,F)$和输入串$w$：
	- 空间复杂度：$O(1)$，只需记录当前走到的状态
	- 时间复杂度：$O(|w|)$，通过优化查询转移规则的算法，在常数时间内完成查询操作
- 对NFA$(Q,\Sigma,\delta,q_0,F)$和输入串$w$：
	- 上界：转化为DFA，则有上界$O(2^{|Q|}\cdot |w|)$
	- 非回溯法执行：维护$\epsilon$-闭包
		- 计算$\epsilon$-闭包：时间，空间复杂度均为$O(|Q|^2)$
		- 维护$\epsilon$-闭包：对每个字符，空间复杂度$O(|Q|)$，时间复杂度$O(|Q|^2)$
		- 综上，空间复杂度$O(|Q|^2)$，时间复杂度$O(|Q|^2\cdot |w|)$
	- 回溯法执行：类似BFS的搜索
		- 最坏情况即搜索的最坏复杂度
		- 采用搜索中的剪枝法，可以降低复杂度，减少重复的搜索过程，将时间复杂度降低到$O(|Q|\cdot |w|)$
		- 采用栈维护搜索的边缘集，最坏情况下，空间复杂度为$O(|Q|\cdot |w|)$
---
[[L6 上下文无关文法(CFG)]]