# C语言、汇编语言和机器码
- C语言的编译过程：
	- 如图：![[Pasted image 20251013101923.png]]
		- 汇编代码示例：![[Pasted image 20251013102450.png]]汇编代码是可读的
		- 机器代码示例：![[Pasted image 20251013102517.png]]初步的文件还需经过链接才能成为真正的可执行文件
		- 反汇编：一些反汇编工具可以将机器码转换为汇编代码
			- `objdump -d a.out`或者`gdb a.out    disassemble a`，可以查看可执行文件的汇编代码
# 汇编指令基础
- **指令集架构**（Instruction Set Architecture, ISA）：计算机系统中，软件和硬件之间的接口
	- 定义了机器指令的格式、操作码、寄存器、寻址方式等
	- 常见的指令集架构有x86、ARM、MIPS等
	- 不同的指令集有很大的差别，相同的指令集也可以用不同的方式实现
- 计算机内部的程序员视角：
	- PC：程序计数器，存储下一条要执行的指令的地址
	- 寄存器：CPU内部的高速存储单元，用于存储临时数据和地址
	- 条件码寄存器：存储上一次算术或逻辑运算的结果状态，如零标志、符号标志等
	- 内存：存储程序和数据
	- 示意图：![[Pasted image 20251013104739.png]]
- 汇编指令的数据类型：以`%`开头，表示寄存器，对x86-64架构，常见的寄存器有：
	- 通用寄存器：`%rax`, `%rbx`, `%rcx`, `%rdx`, `%rsi`, `%rdi`, `%rsp`, `%rbp`, `%r8`,`%r9`, `%r10`, `%r11`, `%r12`, `%r13`, `%r14`, `%r15`
		- 当使用名称：`%eax`, `%ebx`, `%ecx`, `%edx`, `%esi`, `%edi`, `%esp`, `%ebp`,`r8d`……时，表示对应寄存器的低32位，用于兼容32位程序
	- 32位寄存器的用途：
		- `%eax`：累加器，通常用于算术运算
		- `%ebx`：基址寄存器，通常用于存储数据的基地址
		- `%ecx`：计数器，通常用于循环计数
		- `%edx`：数据寄存器，通常用于存储乘法和除法的结果
		- `%esi`：源变址寄存器，通常用于字符串和数组操作
		- `%edi`：目的变址寄存器，通常用于字符串和数组操作
		- `%esp`：**栈指针寄存器**，指向当前栈顶
		- `%ebp`：**基指针寄存器**，指向当前**栈帧**的基地址
- 汇编指令的操作：
	1. ==`mov`指令==：数据传送指令，将数据从源操作数复制到目的操作数
		- 语法：`movq <source>, <destination>`，其中`q`表示操作数为64位（quad word），如果是32位操作数，则使用`movl`
		- 例：`movq %eax, %ebx`，将`%eax`的值复制到`%ebx`
		- 类型：
			1. 立即数到寄存器：`movq $5, %eax`，其中`$`开头表示立即数，也即常数
			2. 寄存器到寄存器：`movq %eax, %ebx`
				- 注：不要将专用的寄存器（如`%esp`, `%ebp`）作为源操作数
			3. 内存到寄存器：`movq (%raz), %rdx`，加括号表示以寄存器的值作为地址，访问内存进行数据的读取
			- 注：`movq`指令不支持内存到内存的直接传送，也即不支持`movq (%rax), (%rbx)`这样的指令
		- 地址偏移：可以在括号内使用偏移量，如`movq 8(%rax), %rbx`，表示从`%rax+8`地址处读取数据到`%rbx`
		- 通用表达式：`D(Rb, Ri, S)`，表示地址`D + Rb + Ri * S`
			- `D`：位移量（偏移量），可以是正数或负数
			- `Rb`：基址寄存器
			- `Ri`：变址寄存器
			- `S`：比例因子，可以是1、2、4或8，如果省略，则默认为1
			- 例：`movq 16(%rax, %rbx, 4), %rcx`，表示从地址`16 + %rax + %rbx * 4`处读取数据到`%rcx`
	2. ==`lea`指令==：装载有效地址指令，用于计算地址
		- 语法：`leaq <source>, <destination>`，其中`q`表示操作数为64位
		- 例：`leaq 8(%rax, %rbx, 4), %rcx`，将地址`8 + %rax + %rbx * 4`计算出来，存储到`%rcx`
	3. ==二元算数运算指令==：
		- `addq <source>, <destination>`：加法，将`destination`加上`source`，结果存储到`destination`
		- `subq <source>, <destination>`：减法，将`destination`减去`source`，结果存储到`destination`
		- `imulq <source>, <destination>`：乘法，将`destination`乘以`source`，结果存储到`destination`
		- `salq $<num>, <destination>`：左移，将`destination`左移`num`位，右侧补0
		- `sarq $<num>, <destination>`：算术右移，将`destination`右移`num`位，左侧补最高位
		- `shrq $<num>, <destination>`：逻辑右移，将`destination`右移`num`位，左侧补0
		- `xorq <source>, <destination>`：按位异或，将`destination`和`source`进行按位异或，结果存储到`destination` 
		- `andq <source>, <destination>`：按位与，将`destination`和`source`进行按位与，结果存储到`destination`
		- `orq <source>, <destination>`：按位或，将`destination`和`source`进行按位或，结果存储到`destination`
	4. ==一元算数运算指令==：
		- `incq <operand>`：加1，将`operand`加1
		- `decq <operand>`：减1，将`operand`减1
		- `negq <operand>`：取反，将`operand`取反，结果存储到`operand`
		- `notq <operand>`：按位取反，将`operand`按位取反，结果存储到`operand`
	- 例：![[Pasted image 20251013115051.png]]
---
[[L4 机器指令-控制]]