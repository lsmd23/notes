# 存储器结构抽象
- 总线：连接核心处理器和存储器的通信通道
- 内存读操作：以指令`movq A, %rax`为例
	- CPU将地址A放在地址总线上![[Pasted image 20251215103343.png]]
	- 主存从地址总线上读取地址A，并将对应的数据放在数据总线上![[Pasted image 20251215103402.png]]
	- CPU从数据总线上读取数据，并存入寄存器`%rax`![[Pasted image 20251215103411.png]]
- 内存写操作：以指令`movq %rax, A`为例
	- CPU将地址A放在地址总线上，主存读取该地址并等待待写入数据到达![[Pasted image 20251215103422.png]]
	- CPU将寄存器`%rax`中的数据放在数据总线上![[Pasted image 20251215103449.png]]
	- 主存从数据总线上读取数据，并存入地址A对应的存储单元![[Pasted image 20251215103454.png]]
# 存储器技术
- 参见[[L7 半导体存储电路#大规模半导体存储器|数字电子技术基础——半导体存储器件]]
- 易失性存储器的类型：断电后数据丢失
	- RAM：随机存取存储器，可以根据地址随机访问数据
		- SRAM：静态随机存储器
			- 每个位单元由1个晶体管和1个电容组成，需持续供电且不断刷新
			- 常用于CPU缓存
		- DRAM：动态随机存储器
			- 每个位单元由6个晶体管组成，无需不断刷新
			- 速度大约比SRAM慢10倍，但成本比SRAM低100倍
			- 常用于主存
	- DRAM的存储组织：
		- 存储单元按行和列组织成矩阵，通过一组坐标读写数据![[Pasted image 20251215104844.png]]
		- 数据读取过程：
			- 行地址锁存（Row access strobe, RAS）：将行地址送入地址总线，并通过RAS信号锁存行地址
			- 存储器将对应行的数据读入行缓冲区![[Pasted image 20251215105142.png]]
			- 列地址锁存（Column access strobe, CAS）：将列地址送入地址总线，并通过CAS信号锁存列地址
			- 存储器将对应列的数据单元从行缓冲区送入数据总线
			- CPU从数据总线上读取数据![[Pasted image 20251215105220.png]]
		- 数据组织：对一个字节，通常按位组织成8个位单元，分别存储在不同的DRAM芯片中；对一个单元，通常按字节组织成8个字节单元，分别存储在不同的DRAM芯片中
			- ![[Pasted image 20251215105304.png]]
- 非易失存储器的类型：断电后数据仍然保留
	- 机械硬盘（HDD）：
		- 概述：
			- 数据存储在一个高速旋转的磁盘上
			- 数据通过磁头读写，磁头通过机械臂移动到指定位置从而读写指定位置的数据
		- 结构：
			- 示意图：![[Pasted image 20251215104732.png]]
			- 结构详述：
				- 每个磁盘都由多个盘片（platter）组成，每个盘片有两个磁道面（surface）
				- 每个盘面都包含同心圆形的磁道（track）
				- 每个磁道被间隙（gap）分成多个扇区（sector），扇区是磁盘读写的最小单位![[Pasted image 20251215112703.png]]
		- 磁盘容量：磁盘所能存储的最大字节数
			- 记录密度（recording density）：每英寸磁道上所能存储的位数
			- 磁道密度（track density）：径向每英寸所能存储的磁道数
			- 面密度（areal density）：每平方英寸磁盘表面所能存储的位数，也即记录密度与磁道密度的乘积
		- 工作原理：
			- 对单一盘片，盘片绕主轴（spindle）高速旋转，读写头通过机械臂（actuator arm）移动到指定位置进行读写![[Pasted image 20251215112953.png]]
			- 一个主轴上往往有多个盘片，读写头在多个盘片上同步移动实现多个盘片的读写![[Pasted image 20251215113039.png]]
			- 读写过程示意图：![[Pasted image 20251215113100.png]]
		- 访问时间：
			- 总访问时间：$$T_\text{access} = T_\text{avg seek} + T_\text{avg rotation} + T_\text{avg transfer}$$
			- 寻道时间（seek time，$T_\text{avg seek}$）：读写头移动到指定磁道所需的时间，通常为几毫秒
			- 旋转延迟时间（rotational latency，$T_\text{avg rotation}$）：等待指定扇区旋转到读写头下方所需的时间，计算方法为：$$T_\text{avg rotation} = \frac{1}{2} \times \frac{60}{\text{RPM}}$$一般为几毫秒
			- 传输时间（transfer time，$T_\text{avg transfer}$）：将数据从磁盘传输到内存所需的时间，计算为：$$T_\text{avg transfer} = \frac{1}{\text{RPM}} \times \frac{1}{\text{number of sectors per track}} \times 60$$通常为几微秒
			- 例：
				- 磁盘转速：7200 RPM
				- 平均寻道时间：9 ms
				- 每磁道扇区数：400
				- 则平均访问时间为：
				$$T_\text{access} = 9 \text{ ms} + \frac{1}{2} \times \frac{60}{7200} + \frac{1}{7200} \times \frac{1}{400} \times 60 \approx 13.02 \text{ ms}$$
		- 向磁盘中读写数据：
			- CPU和磁盘通过I/O总线和I/O桥进行通信![[Pasted image 20251215115233.png]]
			- **CPU发起请求**：CPU先向硬盘控制器的端口写入指令，触发磁盘读写操作![[Pasted image 20251215115321.png]]
			- **DMA传输数据**：硬盘控制器通过DMA控制器将数据直接传输到内存，减少CPU负担![[Pasted image 20251215115410.png]]这一过程无需CPU干预，提高了数据传输效率
			- **中断通知完成**：数据传输完成后，硬盘控制器向CPU发送中断信号，通知读写操作已完成![[Pasted image 20251215115440.png]]
	- 固态硬盘（SSD）：
		- 结构：![[Pasted image 20251215115831.png]]
			- 闪存转换层（Flash Translation Layer, FTL）：负责将逻辑地址映射到物理地址，并处理垃圾回收等操作
			- DRAM缓存：用于缓存数据，提高读写速度
			- 闪存芯片：用于存储数据，通常采用NAND闪存技术
		- 读写规则：按页为单位读写，读写前需要擦除整个块
			- 页（page）：SSD中数据读写的最小单位，通常为4KB或8KB
			- 块（block）：SSD中数据擦除的最小单位，通常包含多个页，如128页或256页
			- 读操作：可以直接读取单个页的数据
			- 写操作：只能将数据写入空闲页，不能覆盖已有数据
			- 擦除操作：必须将整个块的数据擦除后，才能重新写入数据
		- 性能特点：
			- 读写速度快：SSD的读写速度远高于HDD，尤其是在随机读写方面表现突出
			- 低延迟：SSD的访问延迟远低于HDD，通常在微秒级别
			- 高耐久性：SSD没有机械部件，抗震性能好，但闪存有有限的擦写次数
				- 读写选择均衡（wear leveling）：FTL通过均匀分配写入操作，延长闪存寿命
# 局部性原理
- 背景：对不同层级的内存，其访问速度往往是指数级别的差异
	- 示意图：![[Pasted image 20251215112428.png]]
- **局部性原理**：
	- 内容：多数程序在运行时对内存的访问具有局部性特征
		- 时间局部性：如果某个数据被访问，那么在不久的将来它很可能会被再次访问
		- 空间局部性：如果某个数据被访问，那么在不久的将来它附近的数据很可能会被访问
	- 例：
		- 一维数组的顺序访问：
			```cpp
			sum = 0;
			for (i = 0; i < N; i++) {
			    sum += A[i];
			}
			return sum;
			``` 
			可见，数组每次访问时，都访问了相邻的内存单元，体现了空间局部性；每个循环指令被多次执行，体现了时间局部性
		- 二维数组的访问：
			- 按行访问：			
				```cpp
			int sum_array_rows(int A[N][N]) {
			    int i, j;
			    int sum = 0;
			    for (i = 0; i < N; i++) 
			        for (j = 0; j < N; j++) 
			            sum += A[i][j];
			    return sum;
			}
				```
				如果数组A按行优先存储，则每次访问都访问了相邻的内存单元，体现了空间局部性；此时访问效率较高
			- 按列访问：
				```cpp
				int sum_array_cols(int A[N][N]) {
			    int i, j;
			    int sum = 0;
			    for (j = 0; j < N; j++) 
			        for (i = 0; i < N; i++) 
			            sum += A[i][j];
			    return sum;
			    }
			    ```
			    如果数组A按行优先存储，则每次访问都跳过了大量的内存单元，空间局部性较差；此时访问效率较低
# 层次化存储结构
- 概述：根据存储器的访问速度、容量和成本等特性，将存储器划分为多个层次，以提高整体存储系统的性能
	- 示意图：![[Pasted image 20251215114604.png]]
		- 寄存器：速度最快，容量最小，成本最高
		- L1-L3缓存：速度较快，容量较小，成本较高，介质为SRAM
		- 主存：速度较慢，容量较大，成本较低，介质为DRAM
		- 外部存储器：速度最慢，容量最大，成本最低，介质为HDD或SSD
		- 云存储：通过网络访问的远程存储，容量巨大但访问速度较慢
- 存储器的权衡：
	- 通过不同层级存储器的选择，在速度、容量和成本之间进行权衡，以满足不同应用的需求
	- 缓存与缓存命中：
		- 参考[[L3 程序性能优化#^a27f93|程序优化中的缓存命中机制]]
		- 缓存（cache）：位于CPU和主存之间的高速存储器，用于存储频繁访问的数据
		- 在每次读取数据时，CPU首先检查缓存中是否存在所需数据
			- 如果存在，称为缓存命中（cache hit），CPU直接从缓存中读取数据，速度较快
			- 如果不存在，称为缓存未命中（cache miss），CPU需要从主存中读取数据以及附近的数据块，并将其存入缓存，以便下次访问
			- 缓存缺失的类型：
				- 冷缺失（compulsory miss）：首次访问某个数据时发生的缺失，无法通过缓存预取来避免
				- 容量缺失（capacity miss）：由于缓存容量有限，无法存储所有需要的数据而导致的缺失，可以通过增加缓存容量来减少
				- 冲突缺失（conflict miss）：由于不同数据映射到同一缓存位置而导致的缺失，可以通过改进缓存映射策略来减少
	- 存储器之间的趋势和比较：![[Pasted image 20251215121243.png]]