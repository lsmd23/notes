- SEQ处理器：也即顺序执行处理器，其指令按顺序逐条执行，是最简单的处理器类型
# SEQ处理器架构
- 示意图：![[Pasted image 20251124135626.png]]
	- 所有蓝色方框表示预先设计好的模块，例如指令内存，数据内存，PC寄存器，ALU等
	- 所有灰色方框表示控制逻辑模块，用于生成控制信号以控制各个模块的工作，可以由HCL语言描述
	- 白色椭圆表示变量名（见[[L3.2 电路逻辑设计#^d653bc|指令中变量的编码]]）
	- 粗线表示字值信号，为64位宽（8字节）
	- 细线表示位信号，4-8位宽
	- 虚线表示单位的控制信号
# SEQ处理器设计
## 取指模块
- 示意图：![[Pasted image 20251124140335.png]]
- 说明：
	- 预定义模块：
		- 指令内存（Instruction Memory）：根据PC寄存器的值，将读取到的指令存储（应能容纳10字节长度）。若读取出错，应当发出错误信号`imem_error`
		- Split模块：取指令的第0字节，拆分出`icode`和`ifun`字段
		- Align模块：取指令的后面字节，拆分出`rA`、`rB`、`valC`字段
		- PC寄存器（PC Increment）：计算下一条指令的地址，需要根据`icode`的值，决定PC寄存器增加的字节数（由后文所说的`need_regids`和`need_valC`直接控制）
	- 控制逻辑：
		- 指令有效性`Instr_valid`：根据取出的`icode`判断指令是否合法
			- HCL描述：
			```python
			bool instr_valid = 
				icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IIRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ };
			```
		- `icode`与`ifun`：若指令无效，应当将`icode`和`ifun`置为10（即`nop`指令）
			- HCL描述：
			```python
			# Determine instruction code 
			int icode = [ 
				imem_error: INOP; 
				1: imem_icode; 
			]; 
			# Determine instruction function 
			int ifun = [ 
				imem_error: FNONE; 
				1: imem_ifun; 
			]; 
			```
		- `need_regids`与`need_valC`：判断指令是否需要寄存器ID和常数字段
			- HCL描述：
			```python
			# need_regids
			bool need_regids = 
				icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ };
			# need_valC
			bool need_valC = 
				icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL };
			```
## 译码模块
- 示意图：![[Pasted image 20251124142014.png]]
- 说明：
	- 寄存器文件（Register File）：存储16个64位寄存器的值
		- 读端口：`rA`和`rB`寄存器编号
		- 写端口：`dstE`和`dstM`寄存器编号
		- 地址规则：见[[L3.1 指令集架构#^e530f7|Y86-64指令结构-寄存器编码]]
	- 控制逻辑：
		- `srcA`与`srcB`：根据`rA`和`rB`，决定读取哪个寄存器的值
			- HCL描述：
			```python
			# Determine source A register
			int srcA = [
				icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ }: rA;
				icode in { IPOPQ, IRET }: RRSP;
				1: RNONE; # Don't need srcA
			]
			# Determine source B register is similar to srcA
			```
		- `dstE`与`dstM`：根据`rA, rB`和`icode`，决定写回哪个寄存器的值
			- HCL描述：
			```python
			# Determine destination E register
			int dstE = [
				icode in { IRRMOVQ } && Cnd: rB;
				icode in { IIRMOVQ, IOPQ }: rB;
				icode in { IPUSHQ, IPOPQ, ICALL, IRET }: RRSP;
				1: RNONE; # Don't need dstE
			]
			# Determine destination M register is similar to dstE
			```
	- 信号：
		- `Cnd`：条件移动的条件码，决定是否执行条件移动指令（在执行模块中计算）
## 执行模块
- 示意图：![[Pasted image 20251124142811.png]]
- 说明：
	- ALU模块：执行算术和逻辑运算
		- 输入：`aluA`和`aluB`操作数，`aluFun`操作类型
		- 输出：`valE`结果以及条件码
	- 条件码模块CC：根据ALU的输出，设置零标志ZF，符号标志SF，溢出标志OF
	- cond模块：根据条件码和`ifun`字段，决定条件移动信号`Cnd`的值
	- 控制逻辑：
		- `set_cc`：决定是否更新条件码
		- `aluA`与`aluB`：根据指令类型，加载ALU的第一个和第二个操作数
			- HCL描述：
			```python
			# Determine ALU A input
			int aluA = [
				icode in { IRRMOVQ, IOPQ }: valA;
				icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ }: valC;
				icode in { IPUSHQ, ICALL }: -8;
				icode in { IPOPQ, IRET }: 8;
				1: 0; # Default
			]
			# Determine ALU B input is similar to aluA
			```
		- `alu_fun`：根据`icode`和`ifun`，决定ALU的操作类型
			- HCL描述：
			```python
			# Determine ALU function
			int alu_fun = [
				icode == IOPQ: ifun;
				1: ALUADD; # Default
			]
			```
## 访存模块
- 示意图：![[Pasted image 20251124143719.png]]
- 说明：
	- 数据内存（Data Memory）：用于读写数据
	- 控制逻辑：
		- `stat`：控制处理器状态（报错、停机等）
			- HCL描述：
			```python
			# Determine instruction status
			int Stat = [
				imem_error || dmem_error: SADR;
				icode == IHALT: SHLT;
				!instr_valid: SINS;
				1: SAOK; # Default
			]
			```
		- `mem_read`：决定是否从数据内存读取数据
			- HCL描述：
			```python
			# Determine memory read signal
			bool mem_read = 
				icode in { IMRMOVQ, IPOPQ, IRET };
			```
		- `mem_write`：决定是否向数据内存写入数据
		- `mem_addr`：决定访问的数据内存地址
			- HCL描述：
			```python
						# Determine memory address
			int mem_addr = [
				icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ }: valE;
				icode in { IPOPQ, IRET }: valA;
				1: 0; # Default
			]
			```
		- `mem_data`：决定写入数据内存的数据
## 更新PC模块
- 示意图：![[Pasted image 20251124144327.png]]
- 说明：
	- `new_pc`：决定下一条指令的地址
		- HCL描述：
		```python
		# Determine new PC value
		int new_pc = [
			icode == IJXX && Cnd: valC;
			icode == ICALL: valC;
			icode == IRET: valM;
			1: valP; # Default
		]
		```
# SEQ处理器执行流程
- 模块组成：如图![[Pasted image 20251124144549.png]]
	- 状态寄存器：存储处理器当前状态，包含PC寄存器，条件码寄存器，寄存器文件、数据内存
		- 均在信号上升沿被触发更新
	- 组合逻辑模块：ALU，控制逻辑，内存读写等
- 处理器执行：按照**流水线组织**，在每个时钟周期内，不同模块实际上是**并行工作**的
	- 示例：以这样的指令组合为例：![[Pasted image 20251124145333.png]]
		- 当时钟位于上述位置时，CPU结束了第2个周期的上升沿触发，状态应该如下所示：![[Pasted image 20251124145423.png]]
		- 进入第3个周期时，CPU执行组合逻辑的运算指令，CPU状态如下：![[Pasted image 20251124145533.png]]
		- 在第3个周期结束时，在上升沿被触发更新，CPU状态如下：![[Pasted image 20251124145552.png]]
		- 此时，新的数据已经被读取，紧接着会进行下一条指令的计算：![[Pasted image 20251124145627.png]]