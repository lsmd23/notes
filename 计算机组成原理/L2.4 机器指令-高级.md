# x86内存分配
- 在x86架构中，整个内存按照下图方式进行组织：![[Pasted image 20251103100148.png]]
	- 栈向低地址增长，堆向高地址增长
	- 最低地址处存储代码段，主要存储一些可执行的机器指令，只有可读权限
	- 次低地址处存储数据段，主要存储全局变量和静态变量，具有读写权限
	- 再向上是堆区，用于动态分配内存，具有读写权限
	- 中间部分是未分配区域，用于分配大内存占用的某些变量等
- 内存分配示例：
	- 代码如下：
	```c
	char big_array[1L<<24];/* 16 MB*/
	char huge_array[lL<<31]; /* 2 GB */
	int global = 0;
	int useless() { return O; }
	int main()
	{
		void *phugel, *psmall2, *phuge3, *psmall4;
		int local = 0;
		phugel = malloc(1L << 28); /* 256MB */
		psmal12 = malloc(1L<<8); /* 256B */
		phuge3 = malloc(1L << 32); /* 4 GB */
		psmal14 = malloc(1L<< 8); /* 256B */
		/*	Some print statements	*/
	}
	```
	- 实际分配情况：![[Pasted image 20251103100641.png]]
# 缓冲区溢出
## 利用缓冲区溢出的攻击
- 缓冲区溢出（Buffer Overflow）：当向缓冲区写入超出其容量的数据时，导致相邻内存区域被覆盖，从而引发程序异常或安全漏洞
	- 例：
		- 代码：
		```c
		typedef struct { 
			int a[2];
			double d;
		} struct_t;
		double fun(int i) {
			volatile struct_t s;
			s.d = 3.14;
			s.a[i] = 1073741824; /* Possibly out of bounds */
			return s.d;
		}
		```
		- 结果：
			```txt
			fun(0) -> 3.1400000000
			fun(1) -> 3.1400000000
			fun(2) -> 3.1399998665
			fun(3) -> 2.0000006104
			fun(6) -> Stack smashing detected
			fun(8) -> Segmentation fault
		  ```
		  - 原因：![[Pasted image 20251103104354.png]]
	- 事实上，在C语言等低级语言中，编译器不会检查数组访问是否越界等缓冲区溢出问题，因此程序员需要自己确保不会发生溢出
		- 例：库函数`gets()`和`puts()`的缓冲区溢出
			- 代码：
				```c
				/* Echo Line */
				void echo() {
					char buf [4]; /* Way too small! */*
					gets(buf);
					puts(buf);
				}
				void call_echo() {
					echo();
				}
			  ```
			- 行为：当输入串`0123456789012345678901201234567890123456789012`时，不报错但实际发生了溢出，当输入串`01234567890123456789012012345678901234567890123`时，报`Segmentation fault`错误并退出
			- 原因：
				- 初始状态：![[Pasted image 20251103105048.png]]
				- 函数调用：![[Pasted image 20251103105103.png]]
				- 情况1：![[Pasted image 20251103105117.png]]
				- 情况2：修改返回地址导致程序错误![[Pasted image 20251103105133.png]]
- 代码注入攻击：利用缓冲区溢出漏洞，将恶意代码注入到程序的内存栈中，并通过修改返回地址等手段，使程序执行这些恶意代码，从而实现攻击目的
	- 步骤：
		1. 将某个字符串输入给程序，包含可执行代码的字节编码，也即攻击代码
		2. 某些字节用指向攻击代码的地址覆盖返回地址，使得主机在函数返回时跳转到攻击代码处执行
	- 例：
		- 正常代码结构：![[Pasted image 20251103105957.png]]
		- 执行攻击：![[Pasted image 20251103110005.png]]
## 防范缓冲区溢出攻击
1. 使用安全的函数：避免使用不安全的函数，改用更安全的替代函数，并指定缓冲区大小
	- 使用`fgets()`替代`gets()`
	- 使用`snprintf()`替代`sprintf()`
	- 使用`strncpy()`替代`strcpy()`
	- 不使用`scanf()`读取字符串，改用`fgets()`并指定长度
2. 系统级防护机制：
	- 栈随机化（Stack Randomization）：在每次程序运行时，随机化分配一段栈的地址，造成栈的偏移，从而使攻击者难以预测返回地址
		- 攻击者可以使用很长的一段NOP指令（No Operation, 空操作）来填充栈空间，NOP指令的作用就是不做任何操作，直接跳转到下一条指令，这样即使攻击者无法准确预测返回地址，但只要返回地址落在NOP指令范围内，就能顺利跳转到攻击代码处执行
	- 不可执行栈（Non-executable Stack）：引入新的标记位，将栈区域标记为不可执行，防止注入的代码在栈上执行
3. 栈保护机制（Stack Canaries）：在栈帧中的缓冲区的边界处放置一个特殊的标记值（canary），在函数返回时检查该标记值是否被篡改，若被篡改则说明发生了缓冲区溢出攻击，从而终止程序执行
	- 例：
		- 实例：![[Pasted image 20251103112123.png]]
		- 指令的实现：![[Pasted image 20251103112201.png]]