- 指令集是计算机中软硬件之间的接口，定义了处理器可以执行的指令类型和格式
	- 对于程序设计者，只需要知道指令集的功能和用法即可实现程序设计
	- 对于硬件设计者，只需要实现出能够高效执行这些指令的处理器
- 常见的指令集：
	- CISC（复杂指令集计算机）：如x86架构，内含多达1338条指令，功能强大但复杂
	- RISC（精简指令集计算机）：如ARM架构，用更少的指令实现更高效的性能
# Y86-64指令集架构
- Y86-64是一个简化版的x86-64指令集，设计用于教学目的
	- 包含了x86-64中的基本指令和概念，但去掉了一些复杂和不常用的指令
	- 便于理解计算机体系结构和汇编语言编程
## Y86-64处理器结构
- 15个通用寄存器：
	- `%rax`, `%rcx`, `%rdx`, `%rbx`, `%rsp`, `%rbp`, `%rsi`, `%rdi`, `%r8`, `%r9`, `%r10`, `%r11`, `%r12`, `%r13`, `%r14`
	- 每个寄存器都是64位宽
- 3个条件码：
	- ZF（零标志）：上一次运算结果是否为零
	- SF（符号标志）：上一次运算结果的符号（正或负）
	- OF（溢出标志）：上一次有符号运算是否产生了溢出
- PC（程序计数器）：存储下一条要执行的指令的地址
- 程序状态：指示程序当前的状态，如正常运行、错误等
- 内存：存储程序和数据
	- 采用小端表示法存储数据
## Y86-64指令结构
- 指令格式：
	- 大多数指令长度为1到10字节不等
	- 每个指令的第一个字节指示指令的类型和格式，后续字节根据指令类型包含操作数和地址信息
	- 示意图：![[Pasted image 20251110102708.png]]
- 寄存器编码：
	- 每个寄存器用4位二进制编码表示，如下表所示：
		- ![[Pasted image 20251110103943.png]]
	- 15号寄存器（编码为`1111`）表示无寄存器，用于某些特殊指令
	- 注：Y86-64指令只支持对寄存器的操作，不支持直接对内存的操作
## Y86-64基本指令
- 算术运算和逻辑运算指令（OPq）：执行算术和逻辑运算的指令，以`6`开头，长度为2字节
	- `addq rA rB`指令：加法，机器码为`60 rA rB`
	- `subq rA rB`指令：减法，机器码为`61 rA rB`
	- `andq rA rB`指令：按位与，机器码为`62 rA rB`
	- `xorq rA rB`指令：按位异或，机器码为`63 rA rB`
- 数据传送指令（MOVq）：在寄存器之间传送数据的指令
	- `rrmovq rA rB`指令：寄存器到寄存器传送，机器码为`20 rA rB`，长度为2字节
	- `irmovq V rB`指令：立即数到寄存器传送，机器码为`30 F rB V`，其中`F`表示无寄存器，`V`为立即数，长度为10字节
	- `rmmovq rA D(rB)`指令：寄存器到内存传送，机器码为`40 rA rB D`，将`rA`的值存储到地址`D + rB`，长度为10字节
	- `mrmovq D(rB) rA`指令：内存到寄存器传送，机器码为`50 rA rB D`，将地址`D + rB`的值加载到`rA`，长度为10字节
- 条件移动指令（CMOVXX）：根据条件码的状态，将寄存器的值移动到另一个寄存器（长度为2字节）
	- `cmovle rA rB`指令：小于等于，机器码为`21 rA rB`
	- `cmovl rA rB`指令：小于，机器码为`22 rA rB`
	- `cmove rA rB`指令：等于，机器码为`23 rA rB`
	- `cmovne rA rB`指令：不等于，机器码为`24 rA rB`
	- `cmovge rA rB`指令：大于等于，机器码为`25 rA rB`
	- `cmovg rA rB`指令：大于，机器码为`26 rA rB`
- 跳转指令（JXX）：根据条件码跳转到不同的代码块（长度为9字节）
	- `jmp Dest`指令：无条件跳转，机器码为`70 Dest`
	- `jle Dest`指令：小于等于，机器码为`71 Dest`
	- `jl Dest`指令：小于，机器码为`72 Dest`
	- `je Dest`指令：等于，机器码为`73 Dest`
	- `jne Dest`指令：不等于，机器码为`74 Dest`
	- `jge Dest`指令：大于等于，机器码为`75 Dest`
	- `jg Dest`指令：大于，机器码为`76 Dest`
- 栈操作指令：
	- `pushq rA`指令：将寄存器`rA`的值压入栈中，机器码为`A0 rA F`，长度为2字节
		- 栈指针`%rsp`减小8
		- 将`rA`的值存储到地址`%rsp`
	- `popq rA`指令：将栈顶的值弹出到寄存器`rA`，机器码为`B0 rA F`，长度为2字节
		- 将地址`%rsp`的值加载到`rA`
		- 栈指针`%rsp`加大8
- 调用和返回指令：
	- `call Dest`指令：调用过程，机器码为`80 Dest`，长度为9字节
		- 将返回地址压入栈中
		- 跳转到`Dest`地址处执行
	- `ret`指令：返回过程，机器码为`90`，长度为1字节
		- 从栈中弹出返回地址
		- 跳转到该地址处继续执行
- 其他指令：
	- `halt`指令：停机，机器码为`00`，长度为1字节
	- `nop`指令：无操作，机器码为`10`，长度为1字节
- 程序状态码：
	- `AOK`：程序正常运行，代码为`1`
	- `HLT`：程序执行了`halt`指令，代码为`2`
	- `ADR`：程序访问了无效的内存地址，代码为`3`
	- `INS`：程序遇到了无效的指令，代码为`4`
# *Y86-64机器码编写*
- 由于Y86-64是x86-64的子集，因此可以使用类似x86-64的汇编语法来从高级语言生成Y86-64机器码
- 流程：高级语言代码 -> 汇编代码 -> Y86-64机器码
---
[[L3.2 电路逻辑设计]]