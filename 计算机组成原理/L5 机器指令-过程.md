# 过程控制的机制
- 过程控制：指程序在执行过程中如何管理和控制不同的代码块（如函数或子程序）的调用和返回
	- 例：如下两个代码块：
```
# 代码块P，主程序
P(...) {
	...
	...
	y = Q(x);
	print(y)
	...
}

# 代码块Q，被调用的子程序
int Q(int i) {
	int t = 3*i;
	int v[10];
	...
	...
	return v[t];
}
```
- 过程控制的关键问题：
	- 传递控制：在调用代码块Q时，如何保存当前代码块P的执行状态以及节点，以便在Q执行完毕后能够正确返回到P的正确位置继续执行
	- 传递数据：在调用代码块Q时，如何传递参数（如x）以及如何返回结果（如y）
	- 内存管理：在调用代码块Q时，如何管理Q所需的临时数据（如变量t和数组v）的存储空间，在结束Q后如何释放这些空间
- 所有的这些问题被定义在了应用二进制接口（Application Binary Interface，ABI）中
	- ABI定义了程序在机器级别上如何调用和返回函数，包括参数传递、返回值处理、寄存器使用约定、栈帧布局等
	- 不同的操作系统和编译器可能有不同的ABI规范
# 运行时栈的结构
- x86-64中的运行时栈：
	- 内存被视为一维的字节数组，地址从0开始递增x86-64系统使用栈结构管理内存
	- 不同的地址区域被分配给不同的用途，如代码段、数据段、堆和栈等![[Pasted image 20251020144907.png]]
	- 栈区域通常位于内存的**高地址部分**，并**向低地址增长**，由通用寄存器中的==`%rsp`==（栈指针寄存器）指向当前**栈顶**，由==`%rbp`==（基指针寄存器）指向当前栈帧的**基地址**，也即栈底，在`%rsp`和`%rbp`之间的区域即为当前**栈帧** ![[Pasted image 20251020144732.png]]
- 栈相关指令：
	- `pushq <src>`：将`<src>`的值压入栈顶，`%rsp`减8![[Pasted image 20251027134000.png]]
	- `popq <dst>`：将栈顶的值弹出到`<dst>`，`%rsp`加8![[Pasted image 20251027134134.png]]
		- 注意：弹出值的操作是一个拷贝操作，栈顶的值**并不会被清除**
# 过程调用的实现
## 转移控制
- 过程控制流：使用栈进行调用和返回
	- 过程调用指令：==`call <target>`==
		- 将返回地址压入栈顶，然后跳转到`<target>`地址处执行
		- 返回地址：即`call`指令的下一条指令的地址
	- 过程返回指令：==`ret`==
		- 从栈顶弹出返回地址，然后跳转到该地址处继续执行
	- *指令后加`q`表示在64位机器上的指令*
- 控制流示例：
	1. 执行到调用指令： ![[Pasted image 20251027135223.png]]
	2. 调用`call`指令：![[Pasted image 20251027135249.png]]
	3. 执行子过程直至`ret`指令：![[Pasted image 20251027135325.png]]
	4. 执行`ret`指令：![[Pasted image 20251027135349.png]]
## 数据传送
- 过程调用时，需要传递函数的参数和返回值
	- 参数传递：
		- x86-64 ABI规定，前六个整数或指针类型的参数通过寄存器传递，分别为==`%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`==
		- 超过六个参数的通过栈传递，每次传递时，需要先将参数压入栈顶，最后一个参数最先压入栈顶
		- 示意图：![[Pasted image 20251027140816.png]]
	- 返回值传递：函数的返回值通过==`%rax`==寄存器传递
## 管理存储
- 基于栈的语言：
	- C、C++、java等都是基于栈的语言，支持递归调用操作
	- 在这类语言中，单个过程可以有多个在整个栈上的实例，以实现递归调用过程
		- 例：递归的调用链![[Pasted image 20251027141404.png]]
	- 对这些不同的实例，每个实例要有自己的局部变量和参数存储空间，以及各自的返回值指针地址
		- 在x86-64中，这些信息都存储在各自的栈帧中
		- 栈帧管理：
			- 进入过程时，通过“Set-up”代码段创建栈帧和相关的空间
			- 退出过程时，通过“Finish”代码段释放栈帧和相关的空间
	- 例：
		- ![[Pasted image 20251027141658.png]]
		- ![[Pasted image 20251027141712.png]]
		- ![[Pasted image 20251027141727.png]]
		- ![[Pasted image 20251027141737.png]]
		- 退栈，直到执行结束
- 栈帧的结构与行为：
	- x86-64栈帧的总体结构：
		- ![[Pasted image 20251027144015.png]]
		- 说明：
			- 当前栈帧：
				- 参数构建区：用于存储传递给即将被调用的过程的参数
				- 局部变量区：用于存储当前过程的无法存在寄存器的局部变量
				- 保存区：用于保存调用过程前的一些寄存器值
				- 旧帧指针（可选）：保存调用过程前的`%rbp`值
			- 调用者栈帧：
				- 返回地址：调用过程时压入栈顶的返回地址
				- 调用参数：传递给当前过程的参数
	- **局部变量**：局部变量区存储必须在栈上的局部变量，如数组、被取地址的变量、结构体等
			- 例：![[Pasted image 20251027144542.png]]
	- 寄存器保存约定：
		- 调用者保存寄存器（Caller-saved registers）：调用过程前，调用者需要保存这些寄存器的值，过程返回后再恢复
			- `%rax`：保存**返回值**，**调用者保存**，可以被覆盖
			- `%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`：保存**参数**，**调用者保存**，可以被覆盖
			- `%r10`、`%r11`：**临时寄存器**，**调用者保存**，可以被覆盖
		- 被调用者保存寄存器（Callee-saved registers）：过程开始时，被调用者需要保存这些寄存器的值，过程结束时再恢复
			- `%rbx`、`%r12`、`%r13`、`%r14`、`%r15`：被调用者保存，过程开始时保存，结束时恢复
			- `%rbp`：**基指针**寄存器，被调用者保存，过程开始时保存，结束时恢复
			- `%rsp`：**栈指针**寄存器，被调用者保存，过程开始时保存，结束时恢复
- 小结：
	- 寄存器组是可以被所有过程共享的
	- 在过程调用时，需要保存和恢复寄存器的值，以保证各个过程之间的独立性
# 递归过程举例
- 示例代码：
```c
/* Recursive popcount */ 
long pcount_r(unsigned long x) { 
	if (x == 0) 
		return 0; 
	else 
		return (x & 1) + pcount_r(x >> 1); 
}
```
- 汇编代码实现：
```assembly
pcount_r: 
	movl $0, %eax  
	testq %rdi, %rdi  
	je .L6  
	pushq %rbx  
	movq %rdi, %rbx  
	andl $1, %ebx  
	shrq %rdi  
	call pcount_r  
	addq %rbx, %rax  
	popq %rbx  
.L6:  
	rep; ret
```
- 说明：
	- `x == 0`分支：![[Pasted image 20251027145447.png]]
	- 递归调用：
		- 保存调用者寄存器`%rbx`：![[Pasted image 20251027145546.png]]
		- 准备参数：![[Pasted image 20251027145619.png]]
		- 调用递归：![[Pasted image 20251027145650.png]]
		- 处理返回并出栈：略去
- 总结：
	- 得益于栈帧和过程调用的机制，递归过程的每个实例都能正确地维护自己的局部变量和参数，无需特殊处理
	- 在调用中，合理的寄存器保存和恢复，确保了各个过程实例之间的独立性，防止数据的冲突
	- 栈的调用遵循后进先出（LIFO）的原则，确保了递归调用的正确返回顺序