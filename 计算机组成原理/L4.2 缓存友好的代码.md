# 缓存组织和操作
- 缓存的基本概念：
	- [[L4.1 存储器体系结构#^b6c466|缓存的概念]]
	- 缓存可以提高程序性能的原理：[[L4.1 存储器体系结构#局部性原理|局部性原理]]
	- [[L4.1 存储器体系结构#^46f26b|缓存缺失]]
- 缓存组织方式：
	- 缓存索引组织：
		- 示意图：![[Pasted image 20251222103223.png]]
		- $S$：缓存中的组数，$S=2^s$，$s$为组索引的位数
		- $E$：每组中的行数（也即组相连的路数），$E=2^e$，$e$为组内行索引的位数
		- $B$：每行中的字节数，$B=2^b$，$b$为块内字节偏移的位数
		- 缓存容量：$C = S \times E \times B = 2^{s+e+b}$
		- 地址划分：从高位到低位
			- 标签（tag）：用于唯一标识主存块，占剩余地址的高位部分
			- 组索引（set index）：用于定位缓存中的组
			- 块内字节偏移（block offset）：用于定位块内的具体字节
			- **组索引位选择**：一般选用中间位作为组索引位，以减少地址映射冲突
				- 示意图：对6位的地址，若使用高二位为组索引，各个地址的映射如下：![[Pasted image 20251223161429.png]]若使用中间二位为组索引，各个地址的映射如下：![[Pasted image 20251223161447.png]]可见，在满足局部性的情况下，使用中间位作为组索引位可以减少冲突，提高缓存命中率
	- 一路组相连（直接映射，Direct Mapped）：每个主存块映射到唯一的缓存行
		- 示意图：![[Pasted image 20251222102137.png]]
		- 访问模式：
			- 一组地址索引到达，先按组索引定位到组
			- 在组内比较标签，判断是否匹配
			- 若匹配且该缓存块有效，则为命中，按块内偏移读取数据；否则为缺失，从主存加载数据到缓存，按块内偏移写入缓存
			- 例：![[Pasted image 20251222114834.png]]
	- 二路组相连（2-way Set Associative）：每个主存块可以映射到两个缓存行中的任意一个
		- 示意图：![[Pasted image 20251223155511.png]]
		- 访问模式：
			- 一组地址索引到达，先按组索引定位到组
			- 在组内的两行中比较标签，判断是否匹配
			- 若匹配且该缓存块有效，则为命中，按块内偏移读取数据
			- 若未匹配或有效位为0，则为缺失，从主存加载数据到缓存，并遵循一定的策略（随机替换，LRU策略等）选择一行进行替换，按块内偏移写入缓存
			- 例：![[Pasted image 20251223155819.png]]
	- 现代缓存组织：以intel core i7为例![[Pasted image 20251223160319.png]]
		- L1缓存由每个核心独享，分为指令缓存（i-cache）和数据缓存（d-cache），各为32KB，8路组相连，块大小为64字节，访问延迟为4个时钟周期
		- L2缓存由每个核心独享，容量为256KB，8路组相连，块大小为64字节，访问延迟为10个时钟周期
		- L3缓存由所有核心共享，容量为8MB，16路组相连，块大小为64字节，访问延迟为40-75个时钟周期
- 缓存写入：向缓存/内存中写入数据
	- 核心问题：对应一个地址的数据会在不同的内存层级中存在多个副本，写入时需要考虑数据的一致性
	- 写命中策略：要写的数据已在缓存中
		- 写直达（write-through）：同时将数据写入缓存和主存，保证数据一致性，但频繁访问主存，性能较低
		- 写回（write-back）：
			- 在缓存中引入一个“脏位”（dirty bit），表示该缓存块的数据是否被修改![[Pasted image 20251223161016.png]]
			- 写入时只更新缓存，并将脏位置为1
			- 当该缓存块被替换时，若脏位为1，则将数据写回主存，否则直接替换
	- 写缺失策略：要写的数据不在缓存中
		- 写分配（write allocate）：将数据块从主存加载到缓存，然后进行写入操作，适用于后续可能会访问该数据的情况
		- 非写分配（no write allocate）：直接将数据写入主存，不加载到缓存，适用于不太可能再次访问该数据的情况
	- 例：写回+写分配（地址X）
		- 命中：更新缓存块内容，并设置脏位为1
		- 缺失：将主存块加载到缓存，执行写操作，设置脏位为1
		- 替换：若被替换块的脏位为1，则将其写回主存，清除脏位，替换为新块
- 缓存的性能指标：
	- 缺失率（miss rate）：缓存访问中发生缺失的比例
		- L1缓存一般在3%-10%
		- L2缓存一般在1%以下
	- 命中时间：缓存命中所需的时间
		- L1缓存一般在4个时钟周期
		- L2缓存一般在10个时钟周期
	- 缺失代价：缓存缺失需要访问主存所需的时间
		- 一般在50-200个时钟周期
- 缓存友好代码原则：
	- 优化代码的核心循环
	- 减小步长（优化空间局部性），重复访问相同数据（优化时间局部性）
# 缓存对性能的影响
## “存储器山”
- 读吞吐量（read bandwidth）：单位时间内可以从存储器读取的数据量，通常以MB/s或GB/s为单位
- 以读吞吐量为纵轴，以访问步长和工作集大小为横轴，画出三维图表，形成“存储器山”（memory mountain）
	- 示意图：![[Pasted image 20251222111359.png]]![[Pasted image 20251222111407.png]]
	- 特点：
		- **阶梯式下降**：垂直于工作集大小轴的是四条“山脊”，分别对应于工作集完全在L1高速缓存、L2高速缓存、L3高速缓存和主存内的时间局部性区域
			- L1山脊的最高点(6GB/s)与主存山脊的最低点(600MB/s)之间的差别可以达到一个数量级
		- 在L2，L3和主存山脊上随着步长的增加有一个空间局部性的斜坡，空间局部性下降
			- 即使程序完全工作在主存中，主存山脊的最高点也比它的最低点高大约7倍
			- 观察步长维度的吞吐量转折点，可以推测缓存的块大小![[Pasted image 20251222111543.png]]
		- 对于步长1和2垂直于步长轴，此时读吞吐量相对保持不变,为4.5 GB/s
			- 这是由于Core i7存储器系统中的硬件预取（prefetching）机制，它会自动地确认存储器引用模式，试图在一些块被访问之前，将他们取到高速缓存中
		- 从这个图像可以明显看到时间局部性和空间局部性对程序访存性能的影响
## 循环重排：“提升空间局部性
- 程序实例：矩阵乘法
	- 数学定义：设有两个矩阵$A$和$B$，其乘积矩阵$C$的元素定义为：		$$ C[i][j] = \sum_{k=0}^{N-1} A[i][k] \times B[k][j] $$
	- 基本代码实现：简单的按上面的公式实现矩阵乘法
		```cpp
	    /* ijk */
	    for (int i = 0; i < N; i++) {
	        for (int j = 0; j < N; j++) {
	            sum = 0.0;
	            for (int k = 0; k < N; k++) {
	                sum += A[i][k] * B[k][j];
	            }
	            C[i][j] = sum;
	        }
	    })
		```
	- 复杂度：$O(N^3)$
- 缓存性能分析：
	- 假设每个缓存块大小为32字节（可供存储4个double类型数据），矩阵大小为$N \times N$，且$N$足够大（也即工作集大于缓存容量）
	- 在c语言中，数组采用行优先存储，`a[i][j] = a[i * N + j]`
		- 行优先访问：步长为1
		- 列优先访问：步长为N
	- 按i-j-k序列访问的缓存分析：
		- 示意图：![[Pasted image 20251222113326.png]]
		- 对A矩阵，步长为1，缓存块为4，因此缺失率为0.25
		- 对B矩阵，步长为N，假设N远大于缓存块大小，因此每次访问都会导致缓存缺失，缺失率为1.0
		- C矩阵的访问不是主要瓶颈，忽略C中的缓存缺失
	- 按k-i-j序列访问的缓存分析：
		- 示意图：![[Pasted image 20251222113601.png]]
		- 可见，此时对A矩阵1访问不是主要瓶颈，且对B和C两个矩阵的访问步长均为1，缺失率均为0.25
	- 按j-k-i序列访问的缓存分析：
		- 示意图：![[Pasted image 20251222113917.png]]
		- 此时对B矩阵的访问不是主要瓶颈，且对A和C两个矩阵的访问步长均为N，缺失率均为1.0
	- 实际运行结果：在有缓存预取机制的i7处理器上运行：![[Pasted image 20251222114007.png]]
## 分块：提升时间局部性
- 不分块的矩阵乘法：
	- 假设缓存大小为8个矩阵元素，矩阵大小远大于缓存容量
	- 按i-j-k遍历，按行访问缺失率为$\frac{1}{8}$，按列访问缺失率为1，每次迭代的缺失数为$\frac{N}{8} + N = \frac{9N}{8}$，总缺失数为$\frac{9N^3}{8}$
	- 示意图：![[Pasted image 20251222115310.png]]
- 分块矩阵乘法：
	- 思想：将矩阵划分为多个较小的子矩阵（块），每次操作一个块，以提高缓存命中率
	- 代码实现：
		```c
	    /* Blocked ijk */
        c = (double*) calloc(sizeof(double), n * n);
        void mm(double *a, double *b, double *c, int n, int B) {
			for (int i = 0; i < n; i += B) {
			    for (int j = 0; j < n; j += B) {
			        for (int k = 0; k < n; k += B) {
			            // Multiply block (i, k) of A with block (k, j) of B
			            for (int ii = i; ii < i + B; ii++) {
			                for (int jj = j; jj < j + B; jj++) {
			                    for (int kk = k; kk < k + B; kk++) {
			                        c[ii * n + jj] += a[ii * n + kk] * b[kk * n + jj];
			                    }
			                }
			            }
			        }
			    }
			}
		}                   
		```
	- 缓存分析：
		- 示意图：![[Pasted image 20251222115736.png]]
		- 假设块大小为$B \times B$，且$B$足够小，缓存中可以存储3个块
		- 对第一个块迭代，每个块的访问步长均为1，缺失率均为$\frac{1}{8}$，缺失数为$\frac{B^2}{8}$
		- 迭代共有$\frac{2n}{B}$个块（每个矩阵有$\frac{n}{B}$个块，A和B矩阵共$2 \times \frac{n}{B}$个块），因此单遍历的缺失数为$\frac{2n}{B} \times \frac{B^2}{8} = \frac{nB}{4}$
		- 总缺失数为$\frac{nB}{4} \times \frac{n}{B} \times \frac{n}{B} = \frac{n^3}{4B}$
	- 选择块大小：为了最小化缺失数，需要选择合适的块大小$B$，使得$B$尽可能大，同时满足缓存容量限制