- SEQ处理器必须保证每个时钟周期内能完成所有的指令处理步骤，因而时钟周期较长，在一个时钟周期内，有大量的硬件单元处于闲置状态，导致资源利用率较低，处理器性能受限
# 流水线设计原理
- [[L7 半导体存储电路#寄存器 Register|数字电子技术基础——寄存器与流水线]]
	- 可以看到，相比总体式的设计，划分成流水线虽然增大了计算延迟，但对计算吞吐率有显著提升
		- 三级流水及其工作原理：![[Pasted image 20251201102912.png]]![[Pasted image 20251201102919.png]]![[Pasted image 20251201103028.png]]
	- 限制：如果每个组合逻辑电路的工作时间不同，则会导致大量的流水线停顿![[Pasted image 20251201103507.png]]
		- 解决方法：将组合逻辑电路划分成多个子电路，并在子电路间插入寄存器![[Pasted image 20251201103513.png]]这虽然会导致在寄存器上的时延，但能显著提升流水线的吞吐量以及工作频率
- 处理器中的流水线：
	- 由于处理器是不断循环执行的，因此其流水线和一般的无环流水线有所不同
	- 流水线的数据依赖：在每个指令执行周期，需要用到前一个指令的输出作为下一个指令的输入![[Pasted image 20251201110043.png]]
	- 流水线的数据冒险：如果前一个指令的结果还未写回寄存器，就被后一个指令使用，则会导致数据冒险![[Pasted image 20251201110140.png]]
		- 例：写后读的操作（RAW）就有可能导致数据冒险
			 ```assembly
			 irmovq $50, %rax  # 第1条指令
			 addq %rax, %rbx   # 第2条指令，使用了第1条指令的结果
			 mrmovq 100(%rbx), %rcx # 第3条指令，使用了第2条指令的结果
			 ```
# 流水线处理器设计
- 思路：向每个阶段插入寄存器，保存每个阶段的中间结果，从而实现各个阶段的并行工作
	- 示意图：![[Pasted image 20251201110708.png]]
- 信号处理：
	- 由于寄存器将整个流水线划分成了多个阶段，因此每个阶段的信号需要相互独立，不能直接使用统一的信号
	- 架构示意图：![[Pasted image 20251201110955.png]]可以看到，使用带前缀的信号名`<stage>_<signal>`来表示某个阶段的信号
- 反馈路径与PC预测：
	- 对CPU而言，有相当多的指令都会在不同阶段间产生反馈路径，其中最关键的是PC读取时涉及`ret`、`jXX`等指令的跳转
		- ![[Pasted image 20251201112234.png]]
	- 如图所示，按逻辑，下一个指令的进入，需要等到访存和写回阶段的结果才能确定PC的值![[Pasted image 20251201112656.png]]从而导致流水线停顿，降低性能
	- 解决：PC预测技术
		- 先假设不发生跳转，继续顺序执行指令，根据访存阶段的`valA`信号修正后续的指令流
		- PC预测值：
			- 一般指令：`PC = valP`
			- 调用指令`call`，无条件跳转：`PC = valC`
			- 条件跳转指令`jXX`：`PC = valC`（总是假设跳转）
			- 返回指令`ret`：暂缓预测，等待后续信号到达
- 执行问题：
	- 数据冒险：对于如下的指令流：
		```assembly
		 irmovq $10, %rdx
		 irmovq $3, %rax
		 nop * n
		 addq %rdx, %rax
		 ``` 
		 如果`nop`的数量为3或更多，则不会发生数据冒险，否则，由于`addq`指令在译码阶段需要使用`%rdx, %rax`的值，该值如果未写回寄存器，则会导致数据冒险
		- 示意：两个`nop`![[Pasted image 20251201114142.png]]一个`nop`![[Pasted image 20251201114110.png]]
	- 控制冒险：
		- `jXX`指令：对于如下的指令流：
			```assembly
			  	xorq %rax, %rax
				jne t
			 t:
				 irmovq $1, %rbx
				 irmovq $2, %rcx
				 irmovq $3, %rdx
			```
			理论上，不应该跳转到`t`标签处执行，但由于流水线的PC预测机制，会错误地将指令流跳转到`t`标签处，使得流水线中进入了错误的指令
			- 示意图：![[Pasted image 20251201114415.png]]
		- `ret`指令：对于如下的指令流
			```assembly
			ret
			irmovq $1, %rbx
			irmovq $2, %rcx
			irmovq $3, %rdx
			irmovq $5, %rsi
			```
			由于`ret`指令的返回地址只能在访存阶段才能确定，因此之后进入的指令流均是不应该被执行的错误指令
			- 示意图：![[Pasted image 20251201114737.png]]
	- 解决：可以简单的插入`nop`指令来避免冒险的发生，但会降低流水线的性能（插入过多的`nop`指令会使得流水线退化为顺序执行）
