- SEQ处理器必须保证每个时钟周期内能完成所有的指令处理步骤，因而时钟周期较长，在一个时钟周期内，有大量的硬件单元处于闲置状态，导致资源利用率较低，处理器性能受限
# 流水线设计原理
- [[L7 半导体存储电路#寄存器 Register|数字电子技术基础——寄存器与流水线]]
	- 可以看到，相比总体式的设计，划分成流水线虽然增大了计算延迟，但对计算吞吐率有显著提升
		- 三级流水及其工作原理：![[Pasted image 20251201102912.png]]![[Pasted image 20251201102919.png]]![[Pasted image 20251201103028.png]]
	- 限制：如果每个组合逻辑电路的工作时间不同，则会导致大量的流水线停顿![[Pasted image 20251201103507.png]]
		- 解决方法：将组合逻辑电路划分成多个子电路，并在子电路间插入寄存器![[Pasted image 20251201103513.png]]这虽然会导致在寄存器上的时延，但能显著提升流水线的吞吐量以及工作频率
- 处理器中的流水线：
	- 由于处理器是不断循环执行的，因此其流水线和一般的无环流水线有所不同
	- 流水线的数据依赖：在每个指令执行周期，需要用到前一个指令的输出作为下一个指令的输入![[Pasted image 20251201110043.png]]
	- 流水线的数据冒险：如果前一个指令的结果还未写回寄存器，就被后一个指令使用，则会导致数据冒险![[Pasted image 20251201110140.png]]
		- 例：写后读的操作（RAW）就有可能导致数据冒险
			 ```assembly
			 irmovq $50, %rax  # 第1条指令
			 addq %rax, %rbx   # 第2条指令，使用了第1条指令的结果
			 mrmovq 100(%rbx), %rcx # 第3条指令，使用了第2条指令的结果
			 ```
# 流水线处理器设计
## PIPE-处理器结构
- 思路：向每个阶段插入寄存器，保存每个阶段的中间结果，从而实现各个阶段的并行工作
	- 示意图：![[Pasted image 20251201110708.png]]
- 信号处理：
	- 由于寄存器将整个流水线划分成了多个阶段，因此每个阶段的信号需要相互独立，不能直接使用统一的信号
	- 架构示意图：![[Pasted image 20251201110955.png]]可以看到，使用带前缀的信号名`<stage>_<signal>`来表示某个阶段的信号
- 反馈路径与PC预测：
	- 对CPU而言，有相当多的指令都会在不同阶段间产生反馈路径，其中最关键的是PC读取时涉及`ret`、`jXX`等指令的跳转
		- ![[Pasted image 20251201112234.png]]
	- 如图所示，按逻辑，下一个指令的进入，需要等到访存和写回阶段的结果才能确定PC的值![[Pasted image 20251201112656.png]]从而导致流水线停顿，降低性能
	- 解决：PC预测技术
		- 先假设不发生跳转，继续顺序执行指令，根据访存阶段的`valA`信号修正后续的指令流
		- PC预测值：
			- 一般指令：`PC = valP`
			- 调用指令`call`，无条件跳转：`PC = valC`
			- 条件跳转指令`jXX`：`PC = valC`（总是假设跳转）
			- 返回指令`ret`：暂缓预测，等待后续信号到达
- 执行问题：
	- 数据冒险：对于如下的指令流：
		```assembly
		 irmovq $10, %rdx
		 irmovq $3, %rax
		 nop * n
		 addq %rdx, %rax
		 ``` 
		 如果`nop`的数量为3或更多，则不会发生数据冒险，否则，由于`addq`指令在译码阶段需要使用`%rdx, %rax`的值，该值如果未写回寄存器，则会导致数据冒险
		- 示意：两个`nop`![[Pasted image 20251201114142.png]]一个`nop`![[Pasted image 20251201114110.png]]
	- 控制冒险：
		- `jXX`指令：对于如下的指令流：
			```assembly
			  	xorq %rax, %rax
				jne t
			 t:
				 irmovq $1, %rbx
				 irmovq $2, %rcx
				 irmovq $3, %rdx
			```
			理论上，不应该跳转到`t`标签处执行，但由于流水线的PC预测机制，会错误地将指令流跳转到`t`标签处，使得流水线中进入了错误的指令
			- 示意图：![[Pasted image 20251201114415.png]]
		- `ret`指令：对于如下的指令流
			```assembly
			ret
			irmovq $1, %rbx
			irmovq $2, %rcx
			irmovq $3, %rdx
			irmovq $5, %rsi
			```
			由于`ret`指令的返回地址只能在访存阶段才能确定，因此之后进入的指令流均是不应该被执行的错误指令
			- 示意图：![[Pasted image 20251201114737.png]]
	- 解决：可以简单的插入`nop`指令来避免冒险的发生，但会降低流水线的性能（插入过多的`nop`指令会使得流水线退化为顺序执行）
## PIPE处理器设计
### 数据冒险处理
- 数据冒险：暂停（Stalling）
	- 原理：当检测到数据冒险时，向流水线中插入气泡`bubble`，使得后续指令暂停执行，等待数据准备好再进入流水线
		- `bubble`在编译成指令流时实现
		- 例：![[Pasted image 20251208101427.png]]
	- 方法：
		- 引起数据冒险的指令进入译码阶段时，就可以发现数据冒险
		- 此时，向该指令之后的所有流水线模块插入气泡，直至后面所有模块都只有气泡（也即指令执行完毕），再继续执行
		- 例：![[Pasted image 20251208101928.png]]
	- 电路实现：
		- 增加一个贯穿五级流水的控制单元![[Pasted image 20251208102432.png]]
		- 控制单元负责处理数据是否加载，引入暂停信号`stall`以及气泡信号`bubble`，根据信号控制时钟上升沿后数据是否加载到寄存器![[Pasted image 20251208102546.png]]
- 数据冒险：数据转发（Data Forwarding）
	- 原理：当数据已经经过执行和访存阶段后，数据已经计算完成但没有存入到寄存器中，此时可以直接将数据从执行或访存阶段转发到后续指令的译码阶段
		- 例：![[Pasted image 20251208103009.png]]
	- 数据来源：
		- 执行阶段的输出`E_valE`
		- 访存阶段的输出`M_valE`和`M_valM`
		- 写回阶段的输出`W_valE`和`W_valM`
		- 示意图：![[Pasted image 20251208104206.png]]
	- 转发优先级：
		- 如果数据同时存在多个阶段，则优先选择最近的阶段
		- 按照**执行-访存-写回**的顺序选择数据，和指令的串行语义保持一致
		- 示意图：![[Pasted image 20251208105211.png]]
	- 实现：
		- 增加数据通路使得数据可以直接从后续阶段传递到译码阶段![[Pasted image 20251208110630.png]]
		- 控制逻辑：
		 ```python
		 # Determine forwarding for srcA
		 int d_valA = [
			 # use incremented PC
			 D_icode in { ICALL, IJXX }: D_valP;
			 # forward val_E from execute stage
			 d_srcA == e_dstE: e_valE;
			 # forward val_M from memory stage
			 d_srcA == M_dstM: m_valM;
			 # forward val_E from memory stage
			 d_srcA == M_dstE: M_valE;
			 # forward val_E from writeback stage
			 d_srcA == W_dstM: W_valM;
			 # forward val_E from writeback stage
			 d_srcA == W_dstE: W_valE;
			 # use value read form register file
			 1: d_rvalA; # Default
		 ]
		 
		 # Determine forwarding for srcB is similar
		 ```
	- **加载-使用冒险**：
		- 问题：
			- 对`mrmovq`指令，其在访存阶段，才能从内存中获得正确的数据
			- 如果直接在`mrmovq`指令后面紧跟使用该数据的指令，则会导致数据冒险
			- 例：![[Pasted image 20251208105639.png]]
		- 解决：在`mrmovq`指令后面插入一个气泡，等待数据准备好
			- 例：![[Pasted image 20251208105738.png]]
		- 实现：
			- 条件码`load_use_hazard`：
			 ```python
			 # Detect load-use hazard
			 bool load_use_hazard = E_icode in { IMRMOVQ, IPOPQ } && E_dstM in { d_srcA, d_srcB };
			 ```
			- 控制逻辑：
			 ```python
			 # Control signals for stalling and bubbling
			 bool stall_F = load_use_hazard;
			 bool stall_D = load_use_hazard;
			 bool bubble_E = load_use_hazard;
			 ``` 
			- 示意图：![[Pasted image 20251208110449.png]]
### 控制冒险处理
- 控制冒险：分支跳转
	- 原理：分支跳转总是预测其跳转，当发现预测错误后，需要借助气泡来清除错误的指令
	- 方法：
		- 一个`jXX`指令最多引入两个错误指令
		- 错误指令尚未到写回阶段，不会对内存有影响，因此可以通过简单的停机进行恢复
		- 将此时的译码和执行阶段插入气泡，等待正确的指令流进入流水线
		- 示意图：![[Pasted image 20251208114034.png]]
	- 实现：
		- 条件码`branch_mispredict`：
		 ```python
		 # Detect branch misprediction
		 bool branch_mispredict = (E_icode = IJXX & !E_Cnd);
		 ```
		- 控制逻辑：
		 ```python
		 # Control signals for stalling and bubbling
		 bool bubble_D = branch_mispredict;
		 bool bubble_E = branch_mispredict;
		 ``` 
		- 示意图：![[Pasted image 20251208114140.png]]
- 控制冒险：返回指令
	- 原理：返回指令的目标地址只能在访存阶段才能确定，因此需要等待访存阶段的结果到达后，才能确定正确的指令流
	- 方法：
		- 当`ret`指令进入流水线的译码及以后阶段时，暂停取值阶段以阻止错误指令进入流水线
		- 向译码阶段插入气泡，以清除错误指令
		- `ret`进入写回阶段后，解除取指阶段的暂停，开始取正确的指令流
		- 示意图：![[Pasted image 20251208114409.png]]
	- 实现：
		- 条件码`processing_ret`：
		 ```python
		 # Detect processing ret instruction
		 bool processing_ret = (IRET in { D_icode, E_icode, M_icode });
		 ```
		- 控制逻辑：如下图所示，暂停取指阶段，向译码阶段插入气泡![[Pasted image 20251208115858.png]]
		- 
		 
		 