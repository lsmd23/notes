# 位与信息
- 计算机中，用0/1的二进制表示数字和信息，每个0/1叫做**位**
- 每个**字节**，由8个位组成，是表示数的常用的单位，也是多数计算机的**可寻址的最小存储单位**
- 每个字节都对应了唯一的一组编码，表示它在计算机中的位置，称为**地址**
- **字长**：计算机中用于表示地址的位数，常见的有32位和64位，字长同时也意味着**虚拟地址空间的大小**
- 字节的顺序：大端法和小端法
	- 变量一般都不会仅占一个字节，而是多个字节
	- 大端法：高位字节存放在低地址处
	- 小端法：低位字节存放在低地址处
	- 例：![[Pasted image 20250929105312.png]]
		- 注：对字符串，每个字符占一个字节，因此字符串的存储顺序和字节的顺序是一致的
# 位运算
- 位运算：对整数的二进制表示进行逐位操作
- 常见的位运算符：
	- `&`：按位与，两个位都为1时结果为1，否则为0
	- `|`：按位或，两个位有一个为1时结果为1，否则为0
	- `^`：按位异或，两个位不同结果为1，相同结果为0
	- `~`：按位取反，0变1，1变0
	- `<<`：左移，将二进制表示整体左移若干位，右侧补0
	- `>>`：右移，将二进制表示整体右移若干位
		- 逻辑右移：左侧补0
		- 算术右移：左侧补最高位
		- 注：对移位运算，如果左/右移的位数大于等于该类型的位数，结果是未定义的
		- 注：实际的编译器中，对有符号数的右移通常是算术右移
# 计算机中的整数
## 无符号数与有符号数
- 无符号数：所有位都用于表示数值，范围为$0\sim 2^n-1$，其中$n$为位数，数学表示为：$\sum_{i=0}^{n-1}b_i2^i$
	- 例：8位无符号数，范围为$0\sim 255$，数126的表示为`01111110`
- 有符号数：采用**补码表示**，范围为$-2^{n-1}\sim 2^{n-1}-1$，数学表示为：$-b_{n-1}2^{n-1}+\sum_{i=0}^{n-2}b_i2^i$
	- 例：8位有符号数，范围为$-128\sim 127$，数126的表示为`01111110`，数-126的表示为`10000010`
	- 注：有符号数的最高位为符号位，0表示正数，1表示负数
## 无符号数和有符号数的转换
- 原则：二者之间的转化，位的表示不变
- 例：8位无符号数`11111111`表示255，转为有符号数表示-1
- 在计算机中，进行某些运算时，会对其进行隐式类型转换，往往造成不同的结果
	- ![[Pasted image 20250929110418.png]]
	- 因此，在编程时，需注意变量的类型，避免隐式类型转换带来的问题，最好的方式是仅使用有符号数
## 位扩展与截断
- 补码在位扩展时，在左侧扩展最高位即可
- 截断时，直接丢弃高位即可（可能造成溢出）
## 算术运算
- 取相反数：`-x==~x+1`
	- 例：`x=5=00000101`，`-x=11111010+1=11111011=-5`
- 加法：直接相加，如有溢出，忽略溢出的位
	- 本质：**一般的加法结果对$2^n$取模**
- 乘法：直接相乘，如有溢出，忽略溢出的位
	- 本质：**一般的乘法结果对$2^n$取模**
- 移位运算与乘除法的关系
	- 左移一位，相当于乘以2
	- 右移一位，相当于除以2（向下取整）
		- 编译器中，由于移位运算的效率更高，因此对于乘除以2的操作，通常会被编译器优化为移位运算
---
[[L2 浮点数的表示]]