# x86内存分配
- 在x86架构中，整个内存按照下图方式进行组织：![[Pasted image 20251103100148.png]]
	- 栈向低地址增长，堆向高地址增长
	- 最低地址处存储代码段，主要存储一些可执行的机器指令，只有可读权限
	- 次低地址处存储数据段，主要存储全局变量和静态变量，具有读写权限
	- 再向上是堆区，用于动态分配内存，具有读写权限
	- 中间部分是未分配区域，用于分配大内存占用的某些变量等
- 内存分配示例：
	- 代码如下：
	```c
	char big_array[1L<<24];/* 16 MB*/
	char huge_array[lL<<31]; /* 2 GB */
	int global = 0;
	int useless() { return O; }
	int main()
	{
		void *phugel, *psmall2, *phuge3, *psmall4;
		int local = 0;
		phugel = malloc(1L << 28); /* 256MB */
		psmal12 = malloc(1L<<8); /* 256B */
		phuge3 = malloc(1L << 32); /* 4 GB */
		psmal14 = malloc(1L<< 8); /* 256B */
		/*	Some print statements	*/
	}
	```
	- 实际分配情况：![[Pasted image 20251103100641.png]]
# 缓冲区溢出
- 缓冲区溢出（Buffer Overflow）：当向缓冲区写入超出其容量的数据时，导致相邻内存区域被覆盖，从而引发程序异常或安全漏洞
	- 例：
		- 代码：
		```c
		typedef struct { 
			int a[2];
			double d;
		} struct_t;
		double fun(int i) {
			volatile struct_t s;
			s.d = 3.14;
			s.a[i] = 1073741824; /* Possibly out of bounds */
			return s.d;
		}
		```
		- 结果：
			```txt
			fun(0) -> 3.1400000000
			fun(1) -> 3.1400000000
			fun(2) -> 3.1399998665
			fun(3) -> 2.0000006104
			fun(6) -> Stack smashing detected
			fun(8) -> Segmentation fault
		  ```
		  - 原因：![[Pasted image 20251103104354.png]]
	- 事实上，在C语言等低级语言中，编译器不会检查数组访问是否越界等缓冲区溢出问题，因此程序员需要自己确保不会发生溢出
		- 例：库函数`gets()`和`puts()`的缓冲区溢出
			- 代码：
				```c
				/* Echo Line */
				void echo() {
					char buf [4]; /* Way too small! */*
					gets(buf);
					puts(buf);
				}
				void call_echo() {
					echo();
				}
			  ```
			- 行为：当输入串`0123456789012345678901201234567890123456789012`时，不报错但实际发生了溢出，当输入串`01234567890123456789012012345678901234567890123`时，报`Segmentation fault`错误并退出
			- 原因：
				- 初始状态：![[Pasted image 20251103105048.png]]
				- 函数调用：![[Pasted image 20251103105103.png]]
				- 情况1：![[Pasted image 20251103105117.png]]
				- 情况2：修改返回地址导致程序错误![[Pasted image 20251103105133.png]]
- 代码注入攻击：