- 程序的性能并非仅由[[L1 基础知识#算法的增长速度|渐进复杂度]]决定，还受常数因子的影响，因此在实际编程中需要关注程序的性能优化
# 编译器进行的优化
- [[L8 代码优化|编译器在代码生成时就会进行大量的优化]]，以提升生成代码的执行效率
- 常见优化技术：
	- [[L8 代码优化#^e9c8ad|代码移动]]
	- [[L8 代码优化#^f0220a|强度削减]]
	- [[L7 代码生成#^498c21|公共子表达式消除]]
	- 内联过程调用
	- ……
- 编译器的优化总是**偏向于保守**，以确保生成代码的正确性，因此程序员仍需关注代码的性能优化
# 编译器优化瓶颈
- 过程调用：
	- 例：大小写转换程序：
		```c
		void lower(char* s)
		{
			int i;
			for (i = 0; i < strlen(s); i++) {
				if (s[i] >= 'A' && s[i] <= 'Z')
					s[i] -= ('A' - 'a');
			}
		}
		```
		- 问题：`strlen(s)`在每次循环中都会被调用，且库函数中调用是$O(N^2)$复杂度的，导致不必要的重复计算
	- 优化：将过程调用移出循环
		```c
		void lower2(char* s)
		{
			int i;
			int len = strlen(s);
			for (i = 0; i < len; i++) {
				if (s[i] >= 'A' && s[i] <= 'Z')
					s[i] -= ('A' - 'a');
			}
		}
		```
	- 性能提升：由平方级复杂度提升为线性复杂度![[Pasted image 20251229101456.png]]
	- 编译器瓶颈：编译器总是将调用过程视为黑箱，参与一个过程有可能改变全局的一些状态，从而影响其他代码，因此无法确定将调用移出循环是否安全
- 内存别名：
	- 例：二维数组每行求和
		```c
		void sum_rows1(double *a, double *b, long n) {  
			long i, j;  
			for (i = 0; i < n; i++) {  
				b[i] = 0;  
				for (j = 0; j < n; j++)  
					b[i] += a[i*n + j];  
			}  
		}
		```
		- 问题：假设`b`指向`a`的第二行，则会得到如下的执行结果![[Pasted image 20251229101920.png]]
	- 优化：使用临时变量
		```c
		void sum_rows2(double *a, double *b, long n) {  
			long i, j;  
			for (i = 0; i < n; i++) {  
				double temp = 0;  
				for (j = 0; j < n; j++)  
					temp += a[i*n + j];  
				b[i] = temp;  
			}  
		}
		```
	- 编译器瓶颈：编译器无法确定指针`a`和`b`是否会指向同一块内存区域，从而影响代码的正确性，因此在没有足够信息的情况下，无法进行该优化
# 指令级并行(ILP)
- 现代CPU架构：
	- 示意图：![[Pasted image 20251229103316.png]]
	- 超标量处理器：能在一个周期内发射多条指令进行并行执行，从顺序指令流中动态调度指令实现指令级并行（Instruction Level Parallelism, ILP）
	- 例：Nehalem架构CPU
		- 可以并行执行1次加载（带地址计算）、1次存储（带地址计算）、2次简单整数运算、1次复杂整数运算、1次浮点乘法、1次浮点加法
		- 多于1个时钟周期的指令可以被流水线化，以提升吞吐量
- 循环优化提升ILP：以向量求和/乘积为例
	- 结构体和方法：![[Pasted image 20251229103918.png]]
	- 未优化代码：
		```c
		void combine1(vec_ptr v, data_t *dest)
		{
			long int i;
		    *dest = IDENT;
		    for (i = 0; i < vec_length(v); i++) 
		    {
			    data_t val;
			    get_vec_element(v, i, &val);
			    *dest = *dest OP val;
			}		        
		}
		```
		- 性能指标：用CPE衡量，也即每次运算所需的时钟周期数
		- 基准表现：![[Pasted image 20251229105522.png]]（`O1`优化为编译器基本优化等级）
	- 基础优化：进行代码移动和减少内存访问
		```c
		void combine4(vec_ptr v, data_t *dest)
		{
			long int i;
		    data_t t = IDENT;
		    long int length = vec_length(v);
		    data_t *d = get_vec_start(v);
		    for (i = 0; i < length; i++) 
		    {
			    t = t OP d[i];
			}	
			*dest = t;	        
		}
		```
		- 性能提升：![[Pasted image 20251229110221.png]]
	- 循环展开优化：
		- 循环展开：在一个循环内，每次迭代执行多个循环体，从而使得这些指令可以被现代CPU并行执行，增加指令级并行性
		- 未优化的数据依赖：![[Pasted image 20251229110326.png]]
		- 二路循环展开：![[Pasted image 20251229110418.png]]
			- 性能：![[Pasted image 20251229110429.png]]可以看到仅提升了整数乘法，其他运算因并不改变数据依赖顺序，无法提升
		- 二路循环展开重结合（Reassociation）：![[Pasted image 20251229110527.png]]
			- 性能：![[Pasted image 20251229110536.png]]可以看到提升了整数乘法和双精度加法、乘法的性能
			- 数据依赖示意：![[Pasted image 20251229110606.png]]
		- 二路并行展开，分别累积到两个临时变量中：![[Pasted image 20251229110635.png]]
			- 性能：![[Pasted image 20251229110642.png]]可以看到进一步提升了所有运算的性能
			- 数据依赖示意：![[Pasted image 20251229110650.png]]
	- 循环展开的局限：循环展开的性能提升是有上限的，受制于CPU的并行度和本身的数据依赖关系
		- 双精度浮点数相乘：![[Pasted image 20251229112320.png]]
		- 整数相加：![[Pasted image 20251229112330.png]]

